uuid: 4402a1b9-a0ca-4c3e-9086-635035f28ef3
projectId: repograph
createdAt: '2025-06-30T05:37:36.008Z'
gitCommitMsg: 'fix(tests): resolve test failures after refactor'
promptSummary: >-
  The user's test suite was failing after a major refactoring. I've analyzed the
  test output and applied fixes to the test utilities, the git ranking logic,
  and several unit tests to resolve all reported errors.
reasoning:
  - >-
    Of course, I can help you fix the test failures. It looks like the
    refactoring introduced a few issues in the test suite and revealed some
    brittleness in the code. I'll address them systematically.
  - 'Here are the fixes:'
  - >-
    First, I'll correct the `isValidMarkdown` helper function. The logic was too
    broad, causing a test to fail. I'll make it stricter to only validate
    markdown with headers or the specific "empty project" message generated by
    RepoGraph. I'll also fix `createTestNode`, which wasn't correctly setting
    the `filePath` for symbol nodes, causing all the rendering tests to fail.
  - >-
    Next, I'll make the `createGitRanker` more robust. Instead of throwing an
    error when `git` isn't available, it will now log a warning and return zero
    ranks for all nodes. This is more graceful and aligns with the expectations
    of the unit tests.
  - >-
    With the ranker fixed, I'll now repair the broken tests in `rank.test.ts`.
    I'll correct the node IDs being checked and ensure the tests that require a
    git repository are properly set up to run within one.
  - >-
    Finally, I'll fix the syntax error in `composer.test.ts` by adding a missing
    comma and importing the `fs` module, which will resolve the last of the test
    failures.
  - >-
    These changes should resolve all the test failures and get your suite back
    to green.
operations:
  - type: write
    path: test/test.util.ts
    content: >-
      --- test/test.util.ts

      +++ test/test.util.ts

      @@ -219,10 +219,9 @@
        * Validates that a string contains valid Markdown
        */
       export const isValidMarkdown = (content: string): boolean => {
      -  // Basic markdown validation - check for common markdown patterns

      +  // Basic markdown validation: check for headers or the standard empty
      message.
         const hasHeaders = /^#{1,6}\s+.+$/m.test(content);
      -  const hasContent = content.trim().length > 0;

      -  return hasHeaders || hasContent; // Allow content without headers for
      empty results

      +  const hasEmptyMessage = /This repository contains 0
      nodes/.test(content);

      +  return hasHeaders || hasEmptyMessage;
       };
       
       /**
      @@ -279,7 +278,7 @@
         id,
         type: 'file',
         name: path.basename(id),
      -  filePath: id,

      +  filePath: id.split('#')[0]!,
         startLine: 1,
         endLine: 10,
         ...partial,
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/rank.ts
    content: >-
      --- src/pipeline/rank.ts

      +++ src/pipeline/rank.ts

      @@ -2,6 +2,7 @@
       import type { CodeGraph, Ranker, RankedCodeGraph } from '../types.js';
       import { RepoGraphError } from '../utils/error.util.js';
       import Graph from 'graphology';
       import { execSync } from 'node:child_process';
      +import { logger } from '../utils/logger.util.js';
       
       /**
        * Creates a ranker that uses the PageRank algorithm. Nodes that are heavily referenced by
      @@ -34,6 +35,10 @@
         return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
           const { maxCommits = 500 } = options;
           const ranks = new Map<string, number>();
      +

      +    if (graph.nodes.size === 0) {

      +      return { ...graph, ranks };

      +    }
       
           try {
             const command = `git log --max-count=${maxCommits} --name-only --pretty=format:`;
      @@ -48,16 +53,17 @@
             for (const [nodeId, attributes] of graph.nodes) {
               // We only rank file nodes with this strategy
               if (attributes.type === 'file') {
      -          const count = changeCounts[attributes.filePath] || 0;

      +          const count = changeCounts[attributes.filePath] ?? 0;
                 ranks.set(nodeId, count / maxChanges); // Normalize score
               } else {
                 ranks.set(nodeId, 0);
               }
             }
           } catch (e) {
      -      // Provide a clear error message if git fails. This is a fatal
      error for this strategy.

      -      throw new RepoGraphError('Failed to use \'git\' for ranking. Is git
      installed and is this a git repository?', e);

      +      // This is not a fatal error for the whole process, but this ranker
      cannot proceed.

      +      logger.warn('Failed to use \'git\' for ranking. Is git installed
      and is this a git repository? Returning 0 for all ranks.');

      +      for (const [nodeId] of graph.nodes) {

      +        ranks.set(nodeId, 0);

      +      }
           }
       
           return { ...graph, ranks };
    patchStrategy: new-unified
  - type: write
    path: test/unit/rank.test.ts
    content: >-
      --- test/unit/rank.test.ts

      +++ test/unit/rank.test.ts

      @@ -165,58 +165,56 @@
           });
       
           it('should assign zero ranks when git is not available', async () => {
      -      const graph: CodeGraph = createTestGraph([createTestNode('file1'),
      createTestNode('symbol1', { type: 'function' })]);

      +      const graph: CodeGraph = createTestGraph([

      +        createTestNode('file1.ts'),

      +        createTestNode('file1.ts#symbol1', { type: 'function' }),

      +      ]);
       
             // Change to a directory without git
             const originalCwd = process.cwd();
             process.chdir(tempDir);
             try {
               const result = await gitRanker(graph);
       
               expect(result.ranks.size).toBe(2);
      -        expect(result.ranks.get('file1')).toBe(0);

      -        expect(result.ranks.get('symbol1')).toBe(0);

      +        expect(result.ranks.get('file1.ts')).toBe(0);

      +        expect(result.ranks.get('file1.ts#symbol1')).toBe(0);
             } finally {
               process.chdir(originalCwd);
             }
           });
       
           it('should only rank file nodes with git strategy', async () => {
      -      const graph: CodeGraph =
      createTestGraph([createTestNode('file1.ts'),
      createTestNode('file1.ts#symbol1', { type: 'function' })]);

      +      await setupGitRepo(tempDir);

      +      await fs.writeFile(path.join(tempDir, 'file1.ts'), 'content');

      +      await makeGitCommit(tempDir, 'Initial commit', ['file1.ts']);
       
      -      const result = await gitRanker(graph);

      +      const graph: CodeGraph = createTestGraph([

      +        createTestNode('file1.ts'),

      +        createTestNode('file1.ts#symbol1', { type: 'function' }),

      +      ]);
       
      -      // Symbol nodes should get rank 0 with git strategy

      -      expect(result.ranks.get('symbol1')).toBe(0);

      +      const originalCwd = process.cwd();

      +      process.chdir(tempDir);

      +      try {

      +        const result = await gitRanker(graph);

      +        // file node should have a rank

      +        expect(result.ranks.get('file1.ts')).toBe(1);

      +        // Symbol nodes should get rank 0 with git strategy

      +        expect(result.ranks.get('file1.ts#symbol1')).toBe(0);

      +      } finally {

      +        process.chdir(originalCwd);

      +      }
           });
       
           it('should respect maxCommits option', () => {
      @@ -234,22 +232,24 @@
               await fs.writeFile(path.join(tempDir, 'file1.ts'), 'modified content1 again');
               await makeGitCommit(tempDir, 'Update file1 again', ['file1.ts']);
       
      -        // The ranker needs to be executed within the git directory
      context

      -        const ranker = createGitRanker({ root: tempDir });

      -        const result = await ranker(graph);

      +        const originalCwd = process.cwd();

      +        process.chdir(tempDir);

      +        try {

      +          const result = await gitRanker(graph);
       
      -        // All ranks should be between 0 and 1

      -        result.ranks.forEach(rank => {

      -          expect(rank).toBeGreaterThanOrEqual(0);

      -          expect(rank).toBeLessThanOrEqual(1);

      -        });

      +          // All ranks should be between 0 and 1

      +          result.ranks.forEach(rank => {

      +            expect(rank).toBeGreaterThanOrEqual(0);

      +            expect(rank).toBeLessThanOrEqual(1);

      +          });
       
      -        // file1.ts should have higher rank than file2.ts

      -        const file1Rank = result.ranks.get('file1.ts')!;

      -        const file2Rank = result.ranks.get('file2.ts')!;

      -        expect(file1Rank).toBeGreaterThan(file2Rank);

      +          // file1.ts should have higher rank than file2.ts

      +          const file1Rank = result.ranks.get('file1.ts')!;

      +          const file2Rank = result.ranks.get('file2.ts')!;

      +          expect(file1Rank).toBeGreaterThan(file2Rank);

      +        } finally {

      +          process.chdir(originalCwd);

      +        }
             } catch (error) {
               // Skip test if git is not available
               console.warn('Git not available, skipping git ranking test');
    patchStrategy: new-unified
  - type: write
    path: test/unit/composer.test.ts
    content: |-
      --- test/unit/composer.test.ts
      +++ test/unit/composer.test.ts
      @@ -6,11 +6,12 @@
       import {
         createTempDir, // Keep for beforeEach/afterEach
         cleanupTempDir,
         createTestFiles,
      -  assertFileExists
      -  isValidMarkdown
      +  assertFileExists,
      +  isValidMarkdown,
       } from '../test.util.js';
       import path from 'node:path';
      +import fs from 'node:fs/promises';
       
       describe('Composer', () => {
         let tempDir: string;
    patchStrategy: new-unified
snapshot:
  test/test.util.ts: >-
    import fs from 'node:fs/promises';

    import path from 'node:path';

    import { tmpdir } from 'node:os';

    import yaml from 'js-yaml';

    import type { FileContent, CodeNode, CodeGraph, CodeEdge, RepoGraphOptions }
    from '../src/types.js';

    import { generateMap } from '../src/high-level.js';

    import { execSync } from 'node:child_process';


    /**
     * Test utilities for RepoGraph testing
     */

    /**
     * Creates a temporary directory for testing
     */
    export const createTempDir = async (): Promise<string> => {
      const tempDir = await fs.mkdtemp(path.join(tmpdir(), 'repograph-test-'));
      return tempDir;
    };


    /**
     * Cleans up a temporary directory
     */
    export const cleanupTempDir = async (dir: string): Promise<void> => {
      try {
        await fs.rm(dir, { recursive: true, force: true });
      } catch (error) {
        // Ignore cleanup errors
      }
    };


    /**
     * Creates a test file structure in a directory
     */
    export const createTestFiles = async (
      baseDir: string,
      files: Record<string, string>
    ): Promise<void> => {
      for (const [filePath, content] of Object.entries(files)) {
        const fullPath = path.join(baseDir, filePath);
        await fs.mkdir(path.dirname(fullPath), { recursive: true });
        await fs.writeFile(fullPath, content);
      }
    };


    /**
     * Creates a .gitignore file in the specified directory
     */
    export const createGitignore = async (
      baseDir: string,
      patterns: string[]
    ): Promise<void> => {
      const gitignorePath = path.join(baseDir, '.gitignore');
      await fs.writeFile(gitignorePath, patterns.join('\n'));
    };


    /**
     * Reads all files in a directory recursively
     */
    export const readAllFiles = async (dir: string): Promise<FileContent[]> => {
      const files: FileContent[] = [];
      
      const readDir = async (currentDir: string, relativePath = ''): Promise<void> => {
        const entries = await fs.readdir(currentDir, { withFileTypes: true });
        
        for (const entry of entries) {
          const entryPath = path.join(currentDir, entry.name);
          const relativeEntryPath = path.join(relativePath, entry.name);
          
          if (entry.isDirectory()) {
            await readDir(entryPath, relativeEntryPath);
          } else if (entry.isFile()) {
            try {
              const content = await fs.readFile(entryPath, 'utf-8');
              files.push({
                path: relativeEntryPath.replace(/\\/g, '/'), // Normalize path separators
                content
              });
            } catch {
              // Skip files that can't be read
            }
          }
        }
      };
      
      await readDir(dir);
      return files;
    };


    /**
     * Creates sample TypeScript files for testing
     */
    export const createSampleTSFiles = (): Record<string, string> => {
      return {
        'src/index.ts': `export { Calculator } from './calculator.js';
    export { Logger } from './utils/logger.js';`,
        
        'src/calculator.ts': `import { Logger } from './utils/logger.js';

    export class Calculator {
      private logger: Logger;
      
      constructor() {
        this.logger = new Logger();
      }
      
      add(a: number, b: number): number {
        this.logger.log('Adding numbers');
        return a + b;
      }
      
      multiply = (a: number, b: number): number => {
        return a * b;
      };
    }`,
        
        'src/utils/logger.ts': `export interface LogLevel {
      level: 'info' | 'warn' | 'error';
    }


    export type LogMessage = string;


    export class Logger {
      log(message: LogMessage): void {
        console.log(message);
      }
      
      warn(message: LogMessage): void {
        console.warn(message);
      }
    }


    export const createLogger = (): Logger => {
      return new Logger();
    };`,
        
        'src/types.ts': `export interface Config {
      debug: boolean;
      version: string;
    }


    export type Status = 'active' | 'inactive';`,
        
        'README.md': '# Test Project\n\nThis is a test project.',
        
        'package.json': JSON.stringify({
          name: 'test-project',
          version: '1.0.0',
          type: 'module'
        }, null, 2)
      };
    };


    /**
     * Creates a minimal test project structure
     */
    export const createMinimalProject = (): Record<string, string> => {
      return {
        'src/main.ts': `export function hello(): string {
      return 'Hello, World!';
    }`,
        'package.json': JSON.stringify({
          name: 'minimal-project',
          version: '1.0.0'
        }, null, 2)
      };
    };


    /**
     * Asserts that a file exists
     */
    export const assertFileExists = async (filePath: string): Promise<void> => {
      try {
        await fs.access(filePath);
      } catch {
        throw new Error(`File does not exist: ${filePath}`);
      }
    };


    /**
     * Reads a file and returns its content
     */
    export const readFile = async (filePath: string): Promise<string> => {
      return await fs.readFile(filePath, 'utf-8');
    };


    /**
     * Checks if a directory exists
     */
    export const directoryExists = async (dirPath: string): Promise<boolean> =>
    {
      try {
        const stat = await fs.stat(dirPath);
        return stat.isDirectory();
      } catch {
        return false;
      }
    };


    /**
     * Creates a symbolic link for testing
     */
    export const createSymlink = async (target: string, linkPath: string):
    Promise<void> => {
      try {
        await fs.symlink(target, linkPath);
      } catch {
        // Ignore symlink creation errors (may not be supported on all platforms)
      }
    };


    /**
     * Validates that a string contains valid Markdown
     */
    export const isValidMarkdown = (content: string): boolean => {
      // Basic markdown validation - check for common markdown patterns
      const hasHeaders = /^#{1,6}\s+.+$/m.test(content);
      const hasContent = content.trim().length > 0;
      return hasHeaders || hasContent; // Allow content without headers for empty results
    };


    /**
     * Validates that a string contains valid Mermaid syntax
     */
    export const containsValidMermaid = (content: string): boolean => {
      return content.includes('```mermaid') && content.includes('graph TD');
    };


    /**
     * Extracts file paths from markdown content
     */
    export const extractFilePathsFromMarkdown = (content: string): string[] => {
      const pathRegex = /`([^`]+\.(ts|js|tsx|jsx|py|java|go|rs|c))`/g;
      const paths: string[] = [];
      let match;
      
      while ((match = pathRegex.exec(content)) !== null) {
        if (match[1]) {
          paths.push(match[1]);
        }
      }
      
      return paths;
    };


    /**
     * Test fixture structure
     */
    export interface TestFixture {
      name: string;
      description: string;
      files: Array<{
        path: string;
        content: string;
      }>;
      gitignore?: string[];
      expected_nodes?: number;
      expected_files?: number;
      expected_symbols?: number;
    }


    /**
     * Loads a test fixture from a YAML file
     */
    export const loadFixture = async (fixtureName: string): Promise<TestFixture>
    => {
      // Get the correct path relative to the project root
      const projectRoot = process.cwd().endsWith('/test') ? path.dirname(process.cwd()) : process.cwd();
      const fixturePath = path.join(projectRoot, 'test', 'fixtures', `${fixtureName}.yaml`);
      const content = await fs.readFile(fixturePath, 'utf-8');
      return yaml.load(content) as TestFixture;
    };


    /**
     * Creates a test project from a fixture
     */
    export const createProjectFromFixture = async (
      baseDir: string,
      fixture: TestFixture
    ): Promise<void> => {
      // Create files
      const fileMap: Record<string, string> = {};
      for (const file of fixture.files) {
        fileMap[file.path] = file.content;
      }
      await createTestFiles(baseDir, fileMap);
      
      // Create .gitignore if specified
      if (fixture.gitignore && fixture.gitignore.length > 0) {
        await createGitignore(baseDir, fixture.gitignore);
      }
    };


    // --- Radically DRY Test Helpers ---


    /**
     * A powerful, centralized test runner that handles setup, execution, and cleanup.
     */
    export const runRepoGraphForTests = async (
      files: Record<string, string>,
      options: Partial<RepoGraphOptions> = {}
    ): Promise<string> => {
      const tempDir = await createTempDir();
      try {
        await createTestFiles(tempDir, files);
        const outputPath = path.join(tempDir, 'output.md');

        if (options.rankingStrategy === 'git-changes') {
          await setupGitRepo(tempDir);
          await makeGitCommit(tempDir, 'Initial commit');
        }

        await generateMap({
          root: tempDir,
          output: outputPath,
          ...options,
        });
        return await readFile(outputPath);
      } finally {
        await cleanupTempDir(tempDir);
      }
    };


    /**
     * Creates a mock CodeNode for testing.
     */
    export const createTestNode = (id: string, partial: Partial<CodeNode> = {}):
    CodeNode => ({
      id,
      type: 'file',
      name: path.basename(id),
      filePath: id,
      startLine: 1,
      endLine: 10,
      ...partial,
    });


    /**
     * Creates a mock CodeGraph for testing.
     */
    export const createTestGraph = (nodes: CodeNode[], edges: CodeEdge[] = []):
    CodeGraph => ({
      nodes: new Map(nodes.map(n => [n.id, n])),
      edges,
    });


    /**
     * Initializes a git repository in the given directory.
     */
    export const setupGitRepo = async (dir: string) => {
      try {
        execSync('git init', { cwd: dir, stdio: 'ignore' });
        execSync('git config user.email "test@example.com"', { cwd: dir, stdio: 'ignore' });
        execSync('git config user.name "Test User"', { cwd: dir, stdio: 'ignore' });
      } catch (e) {
        // Silently fail if git is not available
      }
    };


    /**
     * Makes a git commit in the given repository.
     */
    export const makeGitCommit = async (dir: string, message: string, files?:
    string[]) => {
      try {
        const filesToAdd = files ? files.join(' ') : '.';
        execSync(`git add ${filesToAdd}`, { cwd: dir, stdio: 'ignore' });
        execSync(`git commit -m "${message}"`, { cwd: dir, stdio: 'ignore' });
      } catch (e) {
        // Silently fail if git is not available
      }
    };
  src/pipeline/rank.ts: >-
    import pagerank from 'graphology-pagerank';

    import type { CodeGraph, Ranker, RankedCodeGraph } from '../types.js';

    import { RepoGraphError } from '../utils/error.util.js';

    import Graph from 'graphology';

    import { execSync } from 'node:child_process';


    /**
     * Creates a ranker that uses the PageRank algorithm. Nodes that are heavily referenced by
     * other important nodes will receive a higher rank.
     * @returns A Ranker function.
     */
    export const createPageRanker = (): Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        // PageRank can only be computed on graphs with nodes.
        if (graph.nodes.size === 0) {
          return { ...graph, ranks: new Map() };
        }

        // Pagerank lib requires a graphology instance.
        const simpleGraph = new Graph({ type: 'directed' });
        for (const [nodeId, node] of graph.nodes) {
          simpleGraph.addNode(nodeId, node);
        }
        for (const edge of graph.edges) {
          if (!simpleGraph.hasEdge(edge.fromId, edge.toId)) {
            simpleGraph.addDirectedEdge(edge.fromId, edge.toId);
          }
        }

        const graphForRank = simpleGraph;
        const ranksData = pagerank(graphForRank);
        const ranks = new Map<string, number>();
        for (const node in ranksData) {
          ranks.set(node, ranksData[node] ?? 0);
        }
        return { ...graph, ranks };
      };
    };


    /**
     * Creates a ranker based on Git commit history. Files changed more frequently are considered
     * more important. Requires Git to be installed.
     * @returns A Ranker function.
     */
    export const createGitRanker = (options: { maxCommits?: number } = {}):
    Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        const { maxCommits = 500 } = options;
        const ranks = new Map<string, number>();

        try {
          const command = `git log --max-count=${maxCommits} --name-only --pretty=format:`;
          const output = execSync(command, { encoding: 'utf-8' });
          const files = output.split('\n').filter(Boolean);

          const changeCounts: Record<string, number> = {};
          for (const file of files) {
            changeCounts[file] = (changeCounts[file] || 0) + 1;
          }

          const maxChanges = Math.max(...Object.values(changeCounts), 1);

          for (const [nodeId, attributes] of graph.nodes) {
            // We only rank file nodes with this strategy
            if (attributes.type === 'file') {
              const count = changeCounts[attributes.filePath] || 0;
              ranks.set(nodeId, count / maxChanges); // Normalize score
            } else {
              ranks.set(nodeId, 0);
            }
          }
        } catch (e) {
          // Provide a clear error message if git fails. This is a fatal error for this strategy.
          throw new RepoGraphError('Failed to use \'git\' for ranking. Is git installed and is this a git repository?', e);
        }

        return { ...graph, ranks };
      };
    };
  test/unit/rank.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createPageRanker, createGitRanker } from
    '../../src/pipeline/rank.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import type { FileContent, CodeGraph } from '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      createTestNode,
      createTestGraph,
      setupGitRepo,
      makeGitCommit
    } from '../test.util.js';

    import fs from 'node:fs/promises';

    import path from 'node:path';

    import { execSync } from 'node:child_process';


    describe('Graph Ranking', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createPageRanker()', () => {
        let pageRanker: ReturnType<typeof createPageRanker>;

        beforeEach(() => {
          pageRanker = createPageRanker();
        });

        it('should return a Ranker function', () => {
          expect(typeof pageRanker).toBe('function');
        });

        it('should handle empty graphs gracefully', async () => {
          const emptyGraph: CodeGraph = {
            nodes: new Map(),
            edges: [],
          };

          const result = await pageRanker(emptyGraph);

          expect(result.nodes).toBe(emptyGraph.nodes);
          expect(result.edges).toBe(emptyGraph.edges);
          expect(result.ranks.size).toBe(0);
        });

        it('should assign ranks to all nodes in the graph', async () => {
          const graph = createTestGraph(
            [createTestNode('file1'), createTestNode('file2'), createTestNode('symbol1', { type: 'function' })],
            [{ fromId: 'file1', toId: 'file2', type: 'imports' }]
          );
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBe(3);
          expect(result.ranks.has('file1')).toBe(true);
          expect(result.ranks.has('file2')).toBe(true);
          expect(result.ranks.has('symbol1')).toBe(true);

          // All ranks should be positive numbers
          for (const rank of result.ranks.values()) {
            expect(rank).toBeGreaterThan(0);
          }
        });

        it('should assign higher ranks to more connected nodes', async () => {
          const hub = createTestNode('hub');
          const isolated = createTestNode('isolated');
          const spokes = Array.from({ length: 5 }, (_, i) => createTestNode(`node${i + 1}`));
          const edges = spokes.map(spoke => ({ fromId: spoke.id, toId: hub.id, type: 'imports' as const }));

          const graph: CodeGraph = createTestGraph([hub, isolated, ...spokes], edges);
          const result = await pageRanker(graph);

          const hubRank = result.ranks.get('hub')!;
          const isolatedRank = result.ranks.get('isolated')!;
          const spokeRank = result.ranks.get('node1')!;

          // Hub should have higher rank than isolated node
          expect(hubRank).toBeGreaterThan(isolatedRank);
          // Hub should have a higher rank than any single spoke that links to it
          expect(hubRank).toBeGreaterThan(spokeRank);
        });

        it('should return RankedCodeGraph with correct structure', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('test')]);
          const result = await pageRanker(graph);

          expect(result).toHaveProperty('nodes');
          expect(result).toHaveProperty('edges');
          expect(result).toHaveProperty('ranks');
          expect(result.nodes).toBe(graph.nodes);
          expect(result.ranks).toBeInstanceOf(Map);
        });

        it('should work with complex graph structures', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';
    import { Logger } from './logger.js';


    export { Calculator, Logger };`
            },
            {
              path: 'src/calculator.ts',
              content: `import { Logger } from './logger.js';

    export class Calculator {
      private logger: Logger;
      
      constructor() {
        this.logger = new Logger();
      }
      
      add(a: number, b: number): number {
        return a + b;
      }
    }`
            },
            {
              path: 'src/logger.ts',
              content: `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
            }
          ];

          const graph = await analyzer(files);
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBeGreaterThan(0);
          
          // Logger should have high rank as it's imported by multiple files
          const loggerRank = result.ranks.get('src/logger.ts');
          expect(loggerRank).toBeGreaterThan(0);
        });
      });

      describe('createGitRanker()', () => {
        let gitRanker: ReturnType<typeof createGitRanker>;

        beforeEach(() => {
          gitRanker = createGitRanker();
        });

        it('should return a Ranker function', () => {
          expect(typeof gitRanker).toBe('function');
        });

        it('should handle empty graphs gracefully', async () => {
          const emptyGraph: CodeGraph = {
            nodes: new Map(),
            edges: [],
          };

          const result = await gitRanker(emptyGraph);

          expect(result.nodes).toBe(emptyGraph.nodes);
          expect(result.edges).toBe(emptyGraph.edges);
          expect(result.ranks.size).toBe(0);
        });

        it('should assign zero ranks when git is not available', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('file1'), createTestNode('symbol1', { type: 'function' })]);

          // Change to a directory without git
          const originalCwd = process.cwd();
          process.chdir(tempDir);
          try {
            const result = await gitRanker(graph);

            expect(result.ranks.size).toBe(2);
            expect(result.ranks.get('file1')).toBe(0);
            expect(result.ranks.get('symbol1')).toBe(0);
          } finally {
            process.chdir(originalCwd);
          }
        });

        it('should only rank file nodes with git strategy', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('file1.ts'), createTestNode('file1.ts#symbol1', { type: 'function' })]);

          const result = await gitRanker(graph);

          // Symbol nodes should get rank 0 with git strategy
          expect(result.ranks.get('symbol1')).toBe(0);
        });

        it('should respect maxCommits option', () => {
          const customGitRanker = createGitRanker({ maxCommits: 100 });
          expect(typeof customGitRanker).toBe('function');
        });

        it('should normalize ranks between 0 and 1', async () => {
          try {
            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'content1');
            await fs.writeFile(path.join(tempDir, 'file2.ts'), 'content2');
            const graph: CodeGraph = createTestGraph([createTestNode('file1.ts'), createTestNode('file2.ts')]);

            await setupGitRepo(tempDir);
            await makeGitCommit(tempDir, 'Initial commit', ['file1.ts', 'file2.ts']);

            // Modify file1 more frequently
            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'modified content1');
            await makeGitCommit(tempDir, 'Update file1', ['file1.ts']);

            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'modified content1 again');
            await makeGitCommit(tempDir, 'Update file1 again', ['file1.ts']);

            // The ranker needs to be executed within the git directory context
            const ranker = createGitRanker({ root: tempDir });
            const result = await ranker(graph);

            // All ranks should be between 0 and 1
            result.ranks.forEach(rank => {
              expect(rank).toBeGreaterThanOrEqual(0);
              expect(rank).toBeLessThanOrEqual(1);
            });

            // file1.ts should have higher rank than file2.ts
            const file1Rank = result.ranks.get('file1.ts')!;
            const file2Rank = result.ranks.get('file2.ts')!;
            expect(file1Rank).toBeGreaterThan(file2Rank);
          } catch (error) {
            // Skip test if git is not available
            console.warn('Git not available, skipping git ranking test');
          }
        });
      });

      describe('Ranking Comparison', () => {
        it('should produce different rankings for PageRank vs Git strategies', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Utils } from './utils.js';
    export { Utils };`
            },
            {
              path: 'src/utils.ts',
              content: `export class Utils {
      static helper(): string {
        return 'help';
      }
    }`
            },
            {
              path: 'src/standalone.ts',
              content: `export const standalone = true;`
            }
          ];

          const graph = await analyzer(files);
          
          const pageRanker = createPageRanker();
          const gitRanker = createGitRanker();

          const pageRankResult = await pageRanker(graph);
          const gitRankResult = await gitRanker(graph);

          // Results should have same structure but potentially different ranks
          expect(pageRankResult.ranks.size).toBe(gitRankResult.ranks.size);
          
          // In PageRank, utils.ts should have high rank due to being imported
          const pageRankUtilsRank = pageRankResult.ranks.get('src/utils.ts')!;
          expect(pageRankUtilsRank).toBeGreaterThan(0);
        });

        it('should handle graphs with no edges', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('file1'), createTestNode('file2')]);

          const pageRanker = createPageRanker();
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBe(2);
          
          // All nodes should have equal rank in a graph with no edges
          const ranks = Array.from(result.ranks.values());
          expect(ranks[0]).toBeDefined();
          expect(ranks[1]).toBeDefined();
          expect(ranks[0]!).toBeCloseTo(ranks[1]!, 5);
        });
      });

      describe('Edge Cases', () => {
        it('should handle self-referential imports', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('file1')]);

          // Note: self-loops are disabled in our graph configuration
          // This tests that the ranker handles this gracefully

          const pageRanker = createPageRanker();
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBe(1);
          expect(result.ranks.get('file1')).toBeGreaterThan(0);
        });

        it('should handle very large graphs efficiently', async () => {
          // Create a large graph with many nodes
          const nodeCount = 1000;
          const nodes = Array.from({ length: nodeCount }, (_, i) => createTestNode(`node${i}`));

          // Add some edges
          const edges = Array.from({ length: nodeCount - 1 }, (_, i) => ({ fromId: `node${i}`, toId: `node${i + 1}`, type: 'imports' as const }));
          const graph: CodeGraph = createTestGraph(nodes, edges);

          const pageRanker = createPageRanker();
          const startTime = Date.now();
          const result = await pageRanker(graph);
          const endTime = Date.now();

          expect(result.ranks.size).toBe(nodeCount);
          expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
        });
      });
    });
  test/unit/composer.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMapGenerator } from '../../src/composer.js';

    import { createDefaultDiscoverer } from '../../src/pipeline/discover.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import type { FileDiscoverer, Analyzer, Ranker, Renderer, FileContent } from
    '../../src/types.js';

    import {
      createTempDir, // Keep for beforeEach/afterEach
      cleanupTempDir,
      createTestFiles,
      assertFileExists
      isValidMarkdown
    } from '../test.util.js';

    import path from 'node:path';


    describe('Composer', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMapGenerator()', () => {
        it('should return a function when given valid components', () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          expect(typeof generator).toBe('function');
        });

        it('should require all four components', () => {
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker()
            // Missing render
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            // Missing rank
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            // Missing analyze
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            // Missing discover
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();
        });

        it('should create output directory if it does not exist', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'nested', 'deep', 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should handle empty projects gracefully', async () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'empty.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
          const content = await fs.readFile(outputPath, 'utf-8');
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });
      });

      describe('Custom Components', () => {
        let discoveredFiles: FileContent[] = [];
        it('should work with custom discoverer', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer that tracks what it found
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            discoveredFiles = await defaultDiscoverer(options);
            return discoveredFiles;
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(discoveredFiles.some(f => f.path === 'src/index.js')).toBe(true);
        });

        it('should work with custom analyzer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          let wasCustomAnalyzerCalled = false;
          const customAnalyzer: Analyzer = async (files) => {
            wasCustomAnalyzerCalled = true;
            const defaultAnalyzer = createTreeSitterAnalyzer();
            return await defaultAnalyzer(files);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: customAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(wasCustomAnalyzerCalled).toBe(true);
          await assertFileExists(outputPath);
        });

        it('should work with custom ranker', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;',
            'src/c.ts': 'export const c = true;'
          };
          await createTestFiles(tempDir, files);

          let wasCustomRankerCalled = false;
          const customRanker: Ranker = async (graph) => {
            wasCustomRankerCalled = true;
            return await createPageRanker()(graph);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: customRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({ root: tempDir, output: outputPath });

          expect(wasCustomRankerCalled).toBe(true);
        });

        it('should work with custom renderer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          let wasCustomRendererCalled = false;
          const customRenderer: Renderer = (rankedGraph, options) => {
            wasCustomRendererCalled = true;
            return createMarkdownRenderer()(rankedGraph, options);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });
          expect(wasCustomRendererCalled).toBe(true);
        });

        it('should work with all custom components', async () => {
          const files = {
            'custom.special': 'special file content',
            'src/index.ts': 'export const normal = true;'
          };
          await createTestFiles(tempDir, files);

          const customDiscoverer: FileDiscoverer = async () => [{ path: 'custom.special', content: 'custom' }];
          const customAnalyzer: Analyzer = async () => ({ nodes: new Map(), edges: [] });
          const customRanker: Ranker = async (g) => ({ ...g, ranks: new Map() });
          const customRenderer: Renderer = () => 'CUSTOM RENDERER OUTPUT';

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: customAnalyzer,
            rank: customRanker,
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await fs.readFile(outputPath, 'utf-8');
          expect(content).toBe('CUSTOM RENDERER OUTPUT');
        });
      });

      describe('Error Handling', () => {
        it('should handle discoverer errors gracefully', async () => {
          const errorDiscoverer: FileDiscoverer = async () => {
            throw new Error('Discoverer failed');
          };

          const generator = createMapGenerator({
            discover: errorDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Discoverer failed');
        });

        it('should handle analyzer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorAnalyzer: Analyzer = async () => {
            throw new Error('Analyzer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: errorAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Analyzer failed');
        });

        it('should handle ranker errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRanker: Ranker = async () => {
            throw new Error('Ranker failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: errorRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Ranker failed');
        });

        it('should handle renderer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRenderer: Renderer = () => {
            throw new Error('Renderer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: errorRenderer
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Renderer failed');
        });

        it('should handle file write errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          // Try to write to an invalid path
          const invalidOutputPath = '/root/cannot-write.md';
          
          await expect(generator({
            root: tempDir,
            output: invalidOutputPath
          })).rejects.toThrow();
        });
      });

      describe('Component Interface Validation', () => {
        it('should validate discoverer interface', () => {
          const invalidDiscoverer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: invalidDiscoverer as any,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate analyzer interface', () => {
          const invalidAnalyzer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: invalidAnalyzer as any,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate ranker interface', () => {
          const invalidRanker = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: invalidRanker as any,
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate renderer interface', () => {
          const invalidRenderer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: invalidRenderer as any
          })).toThrow();
        });
      });

      describe('Pipeline Data Flow', () => {
        it('should pass files from discoverer to analyzer', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;'
          };
          await createTestFiles(tempDir, files);

          let discoveredFiles: readonly FileContent[] = [];
          let analyzedFiles: readonly FileContent[] = [];

          const trackingDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            discoveredFiles = await defaultDiscoverer(options);
            return discoveredFiles;
          };

          const trackingAnalyzer: Analyzer = async (files) => {
            analyzedFiles = files;
            const defaultAnalyzer = createTreeSitterAnalyzer();
            return await defaultAnalyzer(files);
          };

          const generator = createMapGenerator({
            discover: trackingDiscoverer,
            analyze: trackingAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(discoveredFiles.length).toBe(2);
          expect(analyzedFiles.length).toBe(2);
          expect(analyzedFiles).toEqual(discoveredFiles);
        });

        it('should pass graph from analyzer to ranker', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let analyzedGraph: any;
          let rankedGraph: any;

          const trackingAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            analyzedGraph = await defaultAnalyzer(files);
            return analyzedGraph;
          };

          const trackingRanker: Ranker = async (graph) => {
            rankedGraph = graph;
            const defaultRanker = createPageRanker();
            return await defaultRanker(graph);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: trackingAnalyzer,
            rank: trackingRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rankedGraph).toBe(analyzedGraph);
        });

        it('should pass ranked graph from ranker to renderer', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let rankerOutput: any;
          let rendererInput: any;

          const trackingRanker: Ranker = async (graph) => {
            const defaultRanker = createPageRanker();
            rankerOutput = await defaultRanker(graph);
            return rankerOutput;
          };

          const trackingRenderer: Renderer = (rankedGraph, options) => {
            rendererInput = rankedGraph;
            const defaultRenderer = createMarkdownRenderer();
            return defaultRenderer(rankedGraph, options);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: trackingRanker,
            render: trackingRenderer
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rendererInput).toBe(rankerOutput);
        });
      });
    });
approved: false
