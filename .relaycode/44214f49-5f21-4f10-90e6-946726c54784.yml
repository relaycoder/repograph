uuid: 44214f49-5f21-4f10-90e6-946726c54784
projectId: repograph
createdAt: '2025-06-29T14:12:06.441Z'
gitCommitMsg: 'fix: Resolve TypeScript errors and runtime exceptions'
promptSummary: >-
  Fix a series of TypeScript errors and a runtime error reported by the user's
  build and test logs.
reasoning:
  - >-
    I've analyzed the errors and it seems there are a few issues to address
    across your test and source files. These include a runtime error caused by
    an incorrect return value in a test's custom function, various TypeScript
    type errors related to strictness and incorrect import paths, and a large
    number of `possibly 'undefined'` errors in your tests.
  - 'Here are the patches to fix everything:'
  - >-
    First, I'll address the TypeScript errors in `src/pipeline/analyze.ts`. This
    involves removing an unused import, fixing incorrect type import paths,
    handling potentially null values, and cleaning up function signatures and
    implementations to align with the type definitions.
  - Next, I'll remove an unused import from `src/types.ts`.
  - >-
    The runtime error was caused by a custom ranker in
    `test/unit/composer.test.ts` returning an object with the wrong shape. I'll
    correct the return value to match the `Ranker` interface.
  - >-
    Finally, I'll fix all the "possibly undefined" errors in
    `test/unit/analyze.test.ts` by adding non-null assertions (`!`) where it's
    safe to do so, as the tests expect these nodes to exist.
  - >-
    These changes should resolve all the reported errors and make your
    TypeScript build and tests pass successfully.
operations:
  - type: write
    path: src/pipeline/analyze.ts
    content: >-
      <<<<<<< SEARCH

      import type { Analyzer, CodeNode, CodeNodeType, FileContent, CodeGraph,
      CodeEdge } from '../types.js';

      =======

      import type { Analyzer, CodeNode, CodeNodeType, FileContent, CodeEdge }
      from '../types.js';

      >>>>>>> REPLACE

      <<<<<<< SEARCH
          // Phase 3: Process definitions for all language groups
          for (const [languageName, languageFiles] of filesByLanguage) {
            const languageConfig = getLanguageConfigForFile(languageFiles[0].path);
            if (!languageConfig) continue;

            try {
              const parser = await createParserForLanguage(languageConfig);
              await processDefinitionsForLanguage({ nodes, edges }, languageFiles, parser, languageConfig);
            } catch (error) {
              console.warn(`Failed to process ${languageName} files:`, error);
            }
          }
      =======
          // Phase 3: Process definitions for all language groups
          for (const [languageName, languageFiles] of filesByLanguage) {
            const languageConfig = getLanguageConfigForFile(languageFiles[0]!.path);
            if (!languageConfig) continue;

            try {
              const parser = await createParserForLanguage(languageConfig);
              await processDefinitionsForLanguage({ nodes, edges }, languageFiles, parser, languageConfig);
            } catch (error) {
              console.warn(`Failed to process ${languageName} files:`, error);
            }
          }
      >>>>>>> REPLACE

      <<<<<<< SEARCH
          // Phase 4: Process relationships for all language groups
          const resolver = new SymbolResolver(nodes, edges);
          for (const [languageName, languageFiles] of filesByLanguage) {
              const languageConfig = getLanguageConfigForFile(languageFiles[0].path);
              if (!languageConfig) continue;

              try {
                const parser = await createParserForLanguage(languageConfig);
                await processRelationshipsForLanguage({ nodes, edges }, languageFiles, parser, languageConfig, resolver);
              } catch (error) {
                console.warn(`Failed to process relationships for ${languageName} files:`, error);
              }
          }
      =======
          // Phase 4: Process relationships for all language groups
          const resolver = new SymbolResolver(nodes, edges);
          for (const [languageName, languageFiles] of filesByLanguage) {
              const languageConfig = getLanguageConfigForFile(languageFiles[0]!.path);
              if (!languageConfig) continue;

              try {
                const parser = await createParserForLanguage(languageConfig);
                await processRelationshipsForLanguage({ nodes, edges }, languageFiles, parser, languageConfig, resolver);
              } catch (error) {
                console.warn(`Failed to process relationships for ${languageName} files:`, error);
              }
          }
      >>>>>>> REPLACE

      <<<<<<< SEARCH

      async function processDefinitionsForLanguage(
        graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
        files: FileContent[],
        parser: import('web-tree-sitter').Parser,
        languageConfig: import('../tree-sitter/language-config.js').LanguageConfig,
      ): Promise<void> {
        const query = new (await import('web-tree-sitter')).Query(parser.language, languageConfig.query);

        for (const file of files) {
      =======

      async function processDefinitionsForLanguage(
        graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
        files: FileContent[],
        parser: import('web-tree-sitter').Parser,
        languageConfig: import('../tree-sitter/language-config.js').LanguageConfig
      ): Promise<void> {
        if (!parser.language) {
          console.warn(`No language available for parser in ${languageConfig.name}. Skipping file processing.`);
          return;
        }
        const query = new (await import('web-tree-sitter')).Query(parser.language, languageConfig.query);
        
        for (const file of files) {
      >>>>>>> REPLACE

      <<<<<<< SEARCH
            if (subtype !== 'definition') continue;

            const type = parts.slice(0, -1).join('.');
            const symbolType = getSymbolTypeFromCapture(name, type, languageConfig);
            if (!symbolType) continue;

            await processSymbol(
              graph.nodes,
              file, 
              node, 
              name, 
              type, 
              symbolType, 
              processedSymbols, 
              processedClassNodes, 
              duplicateClassNames,
              languageConfig
            );
      =======
            if (subtype !== 'definition') continue;

            const type = parts.slice(0, -1).join('.');
            const symbolType = getSymbolTypeFromCapture(name, type);
            if (!symbolType) continue;

            await processSymbol(
              graph.nodes,
              file, 
              node, 
              symbolType, 
              processedSymbols, 
              processedClassNodes, 
              duplicateClassNames,
              languageConfig
            );
      >>>>>>> REPLACE

      <<<<<<< SEARCH

      async function processRelationshipsForLanguage(
        graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
        files: FileContent[],
        parser: import('web-tree-sitter').Parser,
        languageConfig: import('../tree-sitter/language-config.js').LanguageConfig,
        resolver: SymbolResolver,
      ): Promise<void> {
        const query = new (await import('web-tree-sitter')).Query(parser.language, languageConfig.query);

        for (const file of files) {
      =======

      async function processRelationshipsForLanguage(
        graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
        files: FileContent[],
        parser: import('web-tree-sitter').Parser,
        languageConfig: import('../tree-sitter/language-config.js').LanguageConfig,
        resolver: SymbolResolver
      ): Promise<void> {
        if (!parser.language) {
          console.warn(`No language available for parser in ${languageConfig.name}. Skipping relationship processing.`);
          return;
        }
        const query = new (await import('web-tree-sitter')).Query(parser.language, languageConfig.query);
        
        for (const file of files) {
      >>>>>>> REPLACE

      <<<<<<< SEARCH
            // Handle other relationships (inheritance, implementation, calls)
            if (['inheritance', 'implementation', 'call'].includes(subtype)) {
              const fromId = findEnclosingSymbolId(node, file, graph.nodes);
      =======
            // Handle other relationships (inheritance, implementation, calls)
            if (subtype && ['inheritance', 'implementation', 'call'].includes(subtype)) {
              const fromId = findEnclosingSymbolId(node, file, graph.nodes);
      >>>>>>> REPLACE

      <<<<<<< SEARCH

      function getSymbolTypeFromCapture(
        captureName: string, 
        type: string, 
        languageConfig: import('./language-config.js').LanguageConfig
      ): CodeNodeType | null {

      =======

      function getSymbolTypeFromCapture(
        captureName: string, 
        type: string
      ): CodeNodeType | null {

      >>>>>>> REPLACE

      <<<<<<< SEARCH
          template: 'template',
          call: 'call',
          inheritance: 'inheritance'
        };
      =======
          template: 'template',
        };
      >>>>>>> REPLACE

      <<<<<<< SEARCH

      async function processSymbol(
        nodes: Map<string, CodeNode>,
        file: FileContent,
        node: import('web-tree-sitter').Node,
        captureName: string,
        type: string,
        symbolType: CodeNodeType,
        processedSymbols: Set<string>,
        processedClassNodes: Set<number>,
        duplicateClassNames: Set<string>,
        languageConfig: import('./language-config.js').LanguageConfig
      ): Promise<void> {

      =======

      async function processSymbol(
        nodes: Map<string, CodeNode>,
        file: FileContent,
        node: import('web-tree-sitter').Node,
        symbolType: CodeNodeType,
        processedSymbols: Set<string>,
        processedClassNodes: Set<number>,
        duplicateClassNames: Set<string>,
        languageConfig: import('../tree-sitter/language-config.js').LanguageConfig
      ): Promise<void> {

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/types.ts
    content: |-
      --- src/types.ts
      +++ src/types.ts
      @@ -1,5 +1,3 @@
      -import type Graph from 'graphology';
      -
       // Core Data Structures
       
       /** Represents a single file read from disk. Immutable. */
    patchStrategy: new-unified
  - type: write
    path: test/unit/composer.test.ts
    content: |-
      --- test/unit/composer.test.ts
      +++ test/unit/composer.test.ts
      @@ -289,7 +289,7 @@
                   }
               }
               
      -        return { graph, ranks };
      +        return { ...graph, ranks };
             };
       
             const generator = createMapGenerator({
    patchStrategy: new-unified
  - type: write
    path: test/unit/analyze.test.ts
    content: |-
      <<<<<<< SEARCH
            const indexNode = graph.nodes.get('src/index.ts');
            expect(indexNode!.type).toBe('file');
            expect(indexNode.name).toBe('index.ts');
            expect(indexNode.filePath).toBe('src/index.ts');
      =======
            const indexNode = graph.nodes.get('src/index.ts');
            expect(indexNode!.type).toBe('file');
            expect(indexNode!.name).toBe('index.ts');
            expect(indexNode!.filePath).toBe('src/index.ts');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const addNode = graph.nodes.get('src/functions.ts#add');
            expect(addNode.type).toBe('function');
            expect(addNode.name).toBe('add');
            expect(addNode.filePath).toBe('src/functions.ts');
            expect(addNode.startLine).toBeGreaterThan(0);
      =======
            const addNode = graph.nodes.get('src/functions.ts#add');
            expect(addNode!.type).toBe('function');
            expect(addNode!.name).toBe('add');
            expect(addNode!.filePath).toBe('src/functions.ts');
            expect(addNode!.startLine).toBeGreaterThan(0);
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const greetNode = graph.nodes.get('src/arrows.ts#greet');
            expect(greetNode.type).toBe('arrow_function');
            expect(greetNode.name).toBe('greet');
      =======
            const greetNode = graph.nodes.get('src/arrows.ts#greet');
            expect(greetNode!.type).toBe('arrow_function');
            expect(greetNode!.name).toBe('greet');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const calculatorNode = graph.nodes.get('src/classes.ts#Calculator');
            expect(calculatorNode.type).toBe('class');
            expect(calculatorNode.name).toBe('Calculator');
            expect(calculatorNode.codeSnippet).toContain('export class Calculator');
      =======
            const calculatorNode = graph.nodes.get('src/classes.ts#Calculator');
            expect(calculatorNode!.type).toBe('class');
            expect(calculatorNode!.name).toBe('Calculator');
            expect(calculatorNode!.codeSnippet).toContain('export class Calculator');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const userNode = graph.nodes.get('src/interfaces.ts#User');
            expect(userNode.type).toBe('interface');
            expect(userNode.name).toBe('User');
      =======
            const userNode = graph.nodes.get('src/interfaces.ts#User');
            expect(userNode!.type).toBe('interface');
            expect(userNode!.name).toBe('User');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const statusNode = graph.nodes.get('src/types.ts#Status');
            expect(statusNode.type).toBe('type');
            expect(statusNode.name).toBe('Status');
      =======
            const statusNode = graph.nodes.get('src/types.ts#Status');
            expect(statusNode!.type).toBe('type');
            expect(statusNode!.name).toBe('Status');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const readmeNode = graph.nodes.get('README.md');
            expect(readmeNode.type).toBe('file');
      =======
            const readmeNode = graph.nodes.get('README.md');
            expect(readmeNode!.type).toBe('file');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const firstClass = graph.nodes.get('src/multiline.ts#FirstClass');
            const secondFunction = graph.nodes.get('src/multiline.ts#secondFunction');
            const thirdInterface = graph.nodes.get('src/multiline.ts#ThirdInterface');

            expect(firstClass.startLine).toBe(3);
            expect(secondFunction.startLine).toBe(9);
            expect(thirdInterface.startLine).toBe(14);

            expect(firstClass.endLine).toBeGreaterThan(firstClass.startLine);
            expect(secondFunction.endLine).toBeGreaterThan(secondFunction.startLine);
            expect(thirdInterface.endLine).toBeGreaterThan(thirdInterface.startLine);
      =======
            const firstClass = graph.nodes.get('src/multiline.ts#FirstClass');
            const secondFunction = graph.nodes.get('src/multiline.ts#secondFunction');
            const thirdInterface = graph.nodes.get('src/multiline.ts#ThirdInterface');

            expect(firstClass!.startLine).toBe(3);
            expect(secondFunction!.startLine).toBe(9);
            expect(thirdInterface!.startLine).toBe(14);

            expect(firstClass!.endLine).toBeGreaterThan(firstClass!.startLine);
            expect(secondFunction!.endLine).toBeGreaterThan(secondFunction!.startLine);
            expect(thirdInterface!.endLine).toBeGreaterThan(thirdInterface!.startLine);
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const calculatorNode = graph.nodes.get('src/snippets.ts#Calculator');
            const multiplyNode = graph.nodes.get('src/snippets.ts#multiply');

            expect(calculatorNode.codeSnippet).toContain('export class Calculator');
            expect(multiplyNode.codeSnippet).toContain('export function multiply(a: number, b: number): number');
      =======
            const calculatorNode = graph.nodes.get('src/snippets.ts#Calculator');
            const multiplyNode = graph.nodes.get('src/snippets.ts#multiply');

            expect(calculatorNode!.codeSnippet).toContain('export class Calculator');
            expect(multiplyNode!.codeSnippet).toContain('export function multiply(a: number, b: number): number');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const outerClass = graph.nodes.get('src/nested.ts#OuterClass');
            expect(outerClass.type).toBe('class');
            expect(outerClass.name).toBe('OuterClass');
      =======
            const outerClass = graph.nodes.get('src/nested.ts#OuterClass');
            expect(outerClass!.type).toBe('class');
            expect(outerClass!.name).toBe('OuterClass');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            const helloNode = graph.nodes.get('src/main.ts#hello');
            const greetNode = graph.nodes.get('src/main.ts#greet');

            expect(helloNode.type).toBe('function');
            expect(greetNode.type).toBe('arrow_function');
      =======
            const helloNode = graph.nodes.get('src/main.ts#hello');
            const greetNode = graph.nodes.get('src/main.ts#greet');

            expect(helloNode!.type).toBe('function');
            expect(greetNode!.type).toBe('arrow_function');
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  src/pipeline/analyze.ts: >-
    import path from 'node:path';

    import { createParserForLanguage } from '../tree-sitter/languages.js';

    import { getLanguageConfigForFile } from
    '../tree-sitter/language-config.js';

    import type { Analyzer, CodeNode, CodeNodeType, FileContent, CodeGraph,
    CodeEdge } from '../types.js';


    export const getNodeText = (node: import('web-tree-sitter').Node, content:
    string): string => {
      return content.slice(node.startIndex, node.endIndex);
    };


    const getLineFromIndex = (content: string, index: number): number => {
      return content.substring(0, index).split('\n').length;
    };



    /**
     * Creates the default Tree-sitter based analyzer. It parses files to find
     * symbols (nodes) and their relationships (edges), constructing a CodeGraph.
     * Supports multiple programming languages.
     * @returns An Analyzer function.
     */
    export const createTreeSitterAnalyzer = (): Analyzer => {
      return async (files: readonly FileContent[]) => {
        const nodes = new Map<string, CodeNode>();
        const edges: CodeEdge[] = [];

        // Phase 1: Add all files as nodes
        for (const file of files) {
          const fileId = file.path;
          if (!nodes.has(fileId)) {
            nodes.set(fileId, {
              id: fileId,
              type: 'file',
              name: path.basename(file.path),
              filePath: file.path,
              startLine: 1,
              endLine: file.content.split('\n').length,
            });
          }
        }

        // Phase 2: Group files by language and process each group
        const filesByLanguage = new Map<string, FileContent[]>();
        const unsupportedFiles: FileContent[] = [];

        for (const file of files) {
          const languageConfig = getLanguageConfigForFile(file.path);
          if (languageConfig) {
            if (!filesByLanguage.has(languageConfig.name)) {
              filesByLanguage.set(languageConfig.name, []);
            }
            filesByLanguage.get(languageConfig.name)!.push(file);
          } else {
            unsupportedFiles.push(file);
          }
        }

        // Log unsupported files for debugging
        if (unsupportedFiles.length > 0) {
          console.log(`Skipping ${unsupportedFiles.length} unsupported files:`, 
            unsupportedFiles.map(f => f.path).slice(0, 5).join(', ') + 
            (unsupportedFiles.length > 5 ? '...' : ''));
        }

        // Phase 3: Process definitions for all language groups
        for (const [languageName, languageFiles] of filesByLanguage) {
          const languageConfig = getLanguageConfigForFile(languageFiles[0].path);
          if (!languageConfig) continue;

          try {
            const parser = await createParserForLanguage(languageConfig);
            await processDefinitionsForLanguage({ nodes, edges }, languageFiles, parser, languageConfig);
          } catch (error) {
            console.warn(`Failed to process ${languageName} files:`, error);
          }
        }

        // Phase 4: Process relationships for all language groups
        const resolver = new SymbolResolver(nodes, edges);
        for (const [languageName, languageFiles] of filesByLanguage) {
            const languageConfig = getLanguageConfigForFile(languageFiles[0].path);
            if (!languageConfig) continue;

            try {
              const parser = await createParserForLanguage(languageConfig);
              await processRelationshipsForLanguage({ nodes, edges }, languageFiles, parser, languageConfig, resolver);
            } catch (error) {
              console.warn(`Failed to process relationships for ${languageName} files:`, error);
            }
        }

        return { nodes: Object.freeze(nodes), edges: Object.freeze(edges) };
      };
    };


    /**
     * PHASE 3: Process symbol definitions for a set of files of the same language.
     */
    async function processDefinitionsForLanguage(
      graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
      files: FileContent[],
      parser: import('web-tree-sitter').Parser,
      languageConfig: import('../tree-sitter/language-config.js').LanguageConfig,
    ): Promise<void> {
      const query = new (await import('web-tree-sitter')).Query(parser.language, languageConfig.query);

      for (const file of files) {
        const tree = parser.parse(file.content);
        if (!tree) continue;
        const captures = query.captures(tree.rootNode);

        const processedSymbols = new Set<string>();
        const processedClassNodes = new Set<number>();
        const duplicateClassNames = new Set<string>();

        // First pass: identify duplicate class names (mainly for TypeScript/Java/C#)
        if (languageConfig.name === 'typescript' || languageConfig.name === 'java' || languageConfig.name === 'csharp') {
          const seenClassNodes = new Set<number>();
          const classNames = new Map<string, number>();
          
          for (const { name, node } of captures) {
            const parts = name.split('.');
            const type = parts.slice(0, -1).join('.');
            const subtype = parts[parts.length - 1];
            
            if (subtype === 'definition' && type === 'class') {
              let classNode = node;
              if (classNode.type === 'export_statement') {
                classNode = classNode.namedChildren[0] ?? classNode;
              }
              if (classNode.type === 'class_declaration') {
                if (seenClassNodes.has(classNode.startIndex)) {
                  continue;
                }
                seenClassNodes.add(classNode.startIndex);
                
                const nameNode = classNode.childForFieldName('name');
                if (nameNode) {
                  const className = nameNode.text;
                  const symbolId = `${file.path}#${className}`;
                  const count = classNames.get(symbolId) || 0;
                  classNames.set(symbolId, count + 1);
                  if (count + 1 > 1) {
                    duplicateClassNames.add(className);
                  }
                }
              }
            }
          }
        }

        // Second pass: process symbol definitions
        for (const { name, node } of captures) {
          const parts = name.split('.');
          const subtype = parts[parts.length - 1];

          if (subtype !== 'definition') continue;

          const type = parts.slice(0, -1).join('.');
          const symbolType = getSymbolTypeFromCapture(name, type, languageConfig);
          if (!symbolType) continue;

          await processSymbol(
            graph.nodes,
            file, 
            node, 
            name, 
            type, 
            symbolType, 
            processedSymbols, 
            processedClassNodes, 
            duplicateClassNames,
            languageConfig
          );
        }
      }
    }


    /**
     * PHASE 4: Process relationships (imports, calls, inheritance) for a set of files.
     */
    async function processRelationshipsForLanguage(
      graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
      files: FileContent[],
      parser: import('web-tree-sitter').Parser,
      languageConfig: import('../tree-sitter/language-config.js').LanguageConfig,
      resolver: SymbolResolver,
    ): Promise<void> {
      const query = new (await import('web-tree-sitter')).Query(parser.language, languageConfig.query);

      for (const file of files) {
        const tree = parser.parse(file.content);
        if (!tree) {
          continue; // Skip files that couldn't be parsed
        }
        const captures = query.captures(tree.rootNode);

        for (const { name, node } of captures) {
          const parts = name.split('.');
          const type = parts.slice(0, -1).join('.');
          const subtype = parts[parts.length - 1];

          // Handle imports
          if (type === 'import' && subtype === 'source') {
            const allFilePaths = [...graph.nodes.keys()].filter(k => graph.nodes.get(k)?.type === 'file');
            const importedFilePath = resolveImportPath(
              file.path,
              getNodeText(node, file.content),
              languageConfig.name,
              allFilePaths
            );
            if (importedFilePath && graph.nodes.has(importedFilePath)) {
                const edge: CodeEdge = { fromId: file.path, toId: importedFilePath, type: 'imports' };
                if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId && e.type === edge.type)) {
                    graph.edges.push(edge);
                }
            }
            continue;
          }

          // Handle other relationships (inheritance, implementation, calls)
          if (['inheritance', 'implementation', 'call'].includes(subtype)) {
            const fromId = findEnclosingSymbolId(node, file, graph.nodes);
            if (!fromId) continue;

            const toName = getNodeText(node, file.content).replace(/<.*>$/, ''); // a.b.c<T> -> a.b.c
            const toNode = resolver.resolve(toName, file.path);
            if (!toNode) continue;

            const edgeType = subtype === 'inheritance' ? 'inherits' : subtype === 'implementation' ? 'implements' : 'calls';
            const edge: CodeEdge = { fromId, toId: toNode.id, type: edgeType };

            if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId && e.type === edge.type)) {
                graph.edges.push(edge);
            }
          }
        }
      }
    }


    function resolveImportPath(
      fromFile: string,
      importIdentifier: string,
      language: string,
      allFiles: string[]
    ): string | null {
      const sourcePath = importIdentifier.replace(/['"`]/g, '');

      const potentialEndings: Record<string, string[]> = {
        typescript: ['.ts', '.tsx', '/index.ts', '/index.tsx', '.js', '.jsx', '.mjs', '.cjs'],
        javascript: ['.js', '.jsx', '/index.js', '/index.jsx', '.mjs', '.cjs'],
        python: ['.py', '/__init__.py'],
        java: ['.java'],
        c: ['.h', '.c'],
        cpp: ['.hpp', '.h', '.cpp', '.cc', '.cxx'],
        csharp: ['.cs'],
        go: ['.go'],
        rust: ['.rs', '/mod.rs'],
      };
      const basedir = path.dirname(fromFile);
      const endings = potentialEndings[language] || [];

      // 1. Try resolving path as is (e.g. './foo.js' might exist)
      const resolvedPathAsIs = path.normalize(path.join(basedir, sourcePath));
      if (allFiles.includes(resolvedPathAsIs)) {
        return resolvedPathAsIs;
      }

      // 2. Try resolving by changing/adding extensions
      const parsedSourcePath = path.parse(sourcePath);
      const basePath = path.normalize(path.join(basedir, parsedSourcePath.dir, parsedSourcePath.name));

      for (const end of endings) {
        if (allFiles.includes(basePath + end)) return basePath + end;
      }

      // 3. Handle Java/C# package-style imports (e.g., com.package.Class)
      if ((language === 'java' || language === 'csharp') && sourcePath.includes('.')) {
        const packagePath = sourcePath.replace(/\./g, '/');
        for (const end of endings) {
          const fileFromRoot = packagePath + end;
          if (allFiles.includes(fileFromRoot)) return fileFromRoot;
        }
      }

      // Note: This is a simplified resolver. A full implementation would need to handle:
      // - tsconfig.json paths for TypeScript
      // - package.json dependencies / node_modules
      // - GOPATH / Go modules
      // - Maven/Gradle source sets for Java, etc.
      return null;
    }


    /**
     * Get symbol type from capture name and language
     */
    function getSymbolTypeFromCapture(
      captureName: string, 
      type: string, 
      languageConfig: import('./language-config.js').LanguageConfig
    ): CodeNodeType | null {
      // Base mapping that works for most languages
      const baseMap: Record<string, CodeNodeType> = {
        class: 'class',
        function: 'function',
        'function.arrow': 'arrow_function',
        interface: 'interface',
        type: 'type',
        method: 'method',
        field: 'field',
        struct: 'struct',
        enum: 'enum',
        namespace: 'namespace',
        trait: 'trait',
        impl: 'impl',
        constructor: 'constructor',
        property: 'property',
        variable: 'variable',
        constant: 'constant',
        static: 'static',
        union: 'union',
        template: 'template',
        call: 'call',
        inheritance: 'inheritance'
      };

      // Try the full capture name first, then the type part
      return baseMap[captureName] || baseMap[type] || null;
    }


    /**
     * Process a symbol definition
     */
    async function processSymbol(
      nodes: Map<string, CodeNode>,
      file: FileContent,
      node: import('web-tree-sitter').Node,
      captureName: string,
      type: string,
      symbolType: CodeNodeType,
      processedSymbols: Set<string>,
      processedClassNodes: Set<number>,
      duplicateClassNames: Set<string>,
      languageConfig: import('./language-config.js').LanguageConfig
    ): Promise<void> {
      // Skip field definitions that are actually arrow functions (TypeScript specific)
      if (languageConfig.name === 'typescript' && symbolType === 'field' && node.type === 'public_field_definition') {
        const valueNode = node.childForFieldName('value');
        if (valueNode && valueNode.type === 'arrow_function') {
          return;
        }
      }
      
      // Skip variable declarations that are actually arrow functions (TypeScript specific)
      if (languageConfig.name === 'typescript' && symbolType === 'variable' && node.type === 'variable_declarator') {
        const valueNode = node.childForFieldName('value');
        if (valueNode && valueNode.type === 'arrow_function') {
          return; // Skip this, it will be handled by the arrow function capture
        }
      }

      let declarationNode = node;
      let nameNode: import('web-tree-sitter').Node | null = null;
      
      // Handle different node structures based on symbol type and language
      if (languageConfig.name === 'typescript' && (symbolType === 'method' || symbolType === 'field')) {
        // TypeScript-specific method/field handling
        const result = processTypeScriptMethodOrField(
          nodes, file, node, symbolType, processedSymbols, processedClassNodes, duplicateClassNames
        );
        if (result) return; // Successfully processed or should skip
      } else if (languageConfig.name === 'typescript' && symbolType === 'arrow_function') {
        // TypeScript-specific arrow function handling
        nameNode = await getTypeScriptArrowFunctionName(declarationNode);
      } else {
        // Generic handling for most languages
        if (declarationNode.type === 'export_statement') {
          declarationNode = declarationNode.namedChildren[0] ?? declarationNode;
        }
        
        // Handle language-specific name extraction
        if (languageConfig.name === 'go') {
          nameNode = getGoSymbolName(declarationNode);
        } else if (languageConfig.name === 'c' || languageConfig.name === 'cpp') {
          nameNode = getCSymbolName(declarationNode);
        } else {
          nameNode = declarationNode.childForFieldName('name');
        }
      }

      if (nameNode) {
        const symbolName = nameNode.text;
        const symbolId = `${file.path}#${symbolName}`;
        
        if (symbolName && !processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
          processedSymbols.add(symbolId);
          
          // Track processed class nodes
          if (symbolType === 'class') {
            let classNode = declarationNode;
            if (classNode.type === 'export_statement') {
              classNode = classNode.namedChildren[0] ?? classNode;
            }
            if (classNode.type === 'class_declaration') {
              processedClassNodes.add(classNode.startIndex);
            }
          }
          
          nodes.set(symbolId, {
            id: symbolId, 
            type: symbolType, 
            name: symbolName, 
            filePath: file.path,
            startLine: getLineFromIndex(file.content, node.startIndex),
            endLine: getLineFromIndex(file.content, node.endIndex),
            codeSnippet: node.text?.split('{')[0]?.trim() || '',
          });
        }
      }
    }


    /**
     * TypeScript-specific method/field processing
     */
    function processTypeScriptMethodOrField(
      nodes: Map<string, CodeNode>,
      file: FileContent,
      node: import('web-tree-sitter').Node,
      symbolType: CodeNodeType,
      processedSymbols: Set<string>,
      processedClassNodes: Set<number>,
      duplicateClassNames: Set<string>
    ): boolean {
      let parent = node.parent;
      while (parent && parent.type !== 'class_body') {
        parent = parent.parent;
      }
      if (parent) {
        const classParent = parent.parent;
        if (classParent && classParent.type === 'class_declaration') {
          const classNameNode = classParent.childForFieldName('name');
          if (classNameNode) {
            const className = classNameNode.text;
            
            if (processedClassNodes.has(classParent.startIndex) && !duplicateClassNames.has(className)) {
              const nameNode = node.childForFieldName('name');
              if (nameNode) {
                const methodName = nameNode.text;
                const symbolName = `${className}.${methodName}`;
                const symbolId = `${file.path}#${symbolName}`;
                if (!processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
                  processedSymbols.add(symbolId);
                  nodes.set(symbolId, {
                    id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
                    startLine: getLineFromIndex(file.content, node.startIndex),
                    endLine: getLineFromIndex(file.content, node.endIndex),
                    codeSnippet: node.text?.split('{')[0]?.trim() || '',
                  });
                }
              }
            }
          }
        }
      }
      return true; // Processed or should skip
    }


    /**
     * TypeScript-specific arrow function name extraction
     */
    async function getTypeScriptArrowFunctionName(
      declarationNode: import('web-tree-sitter').Node
    ): Promise<import('web-tree-sitter').Node | null> {
      if (declarationNode.type === 'export_statement') {
        const lexicalDecl = declarationNode.namedChildren[0];
        if (lexicalDecl?.type === 'lexical_declaration') {
          const variableDeclarator = lexicalDecl.namedChildren[0];
          if (variableDeclarator?.type === 'variable_declarator') {
            return variableDeclarator.childForFieldName('name');
          }
        }
      } else if (declarationNode.type === 'variable_declarator') {
        return declarationNode.childForFieldName('name');
      } else if (declarationNode.type === 'public_field_definition') {
        return declarationNode.childForFieldName('name');
      }
      return null;
    }


    /**
     * Go-specific symbol name extraction
     */
    function getGoSymbolName(
      declarationNode: import('web-tree-sitter').Node
    ): import('web-tree-sitter').Node | null {
      // For Go type_declaration, the name is in type_spec child
      if (declarationNode.type === 'type_declaration') {
        const typeSpec = declarationNode.namedChild(0);
        if (typeSpec?.type === 'type_spec') {
          return typeSpec.childForFieldName('name');
        }
      }
      
      // For Go const_declaration, the name is in const_spec child
      if (declarationNode.type === 'const_declaration') {
        const constSpec = declarationNode.namedChild(0);
        if (constSpec?.type === 'const_spec') {
          return constSpec.childForFieldName('name');
        }
      }
      
      // For Go var_declaration, the name is in var_spec child
      if (declarationNode.type === 'var_declaration') {
        const varSpec = declarationNode.namedChild(0);
        if (varSpec?.type === 'var_spec') {
          return varSpec.childForFieldName('name');
        }
      }
      
      // For other Go nodes, try the standard approach
      return declarationNode.childForFieldName('name');
    }


    /**
     * C/C++-specific symbol name extraction
     */
    function getCSymbolName(
      declarationNode: import('web-tree-sitter').Node
    ): import('web-tree-sitter').Node | null {
      // For typedef (type_definition), the name is usually the last child
      if (declarationNode.type === 'type_definition') {
        const lastChild = declarationNode.namedChild(declarationNode.namedChildCount - 1);
        if (lastChild?.type === 'type_identifier') {
          return lastChild;
        }
      }
      
      // For function_definition, the name is in the declarator
      if (declarationNode.type === 'function_definition') {
        const declarator = declarationNode.childForFieldName('declarator');
        if (declarator?.type === 'function_declarator') {
          const nameNode = declarator.childForFieldName('declarator');
          if (nameNode?.type === 'identifier') {
            return nameNode;
          }
        }
      }
      
      // For struct/union/enum, try the standard approach
      return declarationNode.childForFieldName('name');
    }


    /**
     * A best-effort symbol resolver to find the ID of a referenced symbol.
     */
    class SymbolResolver {
      constructor(
        private nodes: ReadonlyMap<string, CodeNode>,
        private edges: readonly CodeEdge[],
      ) {}

      /**
       * Resolves a symbol name to a CodeNode.
       * @param symbolName The name of the symbol to resolve (e.g., "MyClass").
       * @param contextFile The path of the file where the reference occurs.
       * @returns The resolved CodeNode or null.
       */
      resolve(
        symbolName: string,
        contextFile: string,
      ): CodeNode | null {
        // 1. Check for definition in the same file.
        // This is a simplified check. It won't find nested symbols correctly without more context.
        const sameFileId = `${contextFile}#${symbolName}`;
        if (this.nodes.has(sameFileId)) {
          return this.nodes.get(sameFileId)!;
        }

        // 2. Check in imported files.
        const importedFiles = this.edges
          .filter(e => e.fromId === contextFile && e.type === 'imports')
          .map(e => e.toId);
        
        for (const file of importedFiles) {
          const importedId = `${file}#${symbolName}`;
          if (this.nodes.has(importedId)) {
            return this.nodes.get(importedId)!;
          }
        }

        // 3. Fallback: search all files (might be ambiguous).
        for (const node of this.nodes.values()) {
          if (node.name === symbolName) {
            // To reduce ambiguity, prefer non-method symbols.
            if (['class', 'function', 'interface', 'struct', 'type', 'enum'].includes(node.type)) {
              return node;
            }
          }
        }

        return null;
      }
    }


    /**
     * Traverses up the AST from a start node to find the enclosing symbol definition
     * and returns its unique ID.
     * @param startNode The node to start traversal from.
     * @param file The file content object.
     * @param nodes The map of all code nodes.
     * @returns The unique ID of the enclosing symbol, or the file path as a fallback.
     */
    function findEnclosingSymbolId(
        startNode: import('web-tree-sitter').Node,
        file: FileContent,
        nodes: ReadonlyMap<string, CodeNode>
    ): string | null {
        let current: import('web-tree-sitter').Node | null = startNode.parent;
        while(current) {
            // This is a simplified check. A full implementation would be more robust.
            const nameNode = current.childForFieldName('name');
            if (nameNode) {
                let symbolName = nameNode.text;
                if (current.type === 'method_definition' || (current.type === 'public_field_definition' && !current.text.includes('=>'))) {
                    const classNode = current.parent?.parent; // class_body -> class_declaration
                    if (classNode?.type === 'class_declaration') {
                        symbolName = `${classNode.childForFieldName('name')?.text}.${symbolName}`;
                    }
                }
                const symbolId = `${file.path}#${symbolName}`;
                if (nodes.has(symbolId)) return symbolId;
            }
            current = current.parent;
        }
        return file.path; // Fallback to file node
    }
  src/types.ts: >-
    import type Graph from 'graphology';


    // Core Data Structures


    /** Represents a single file read from disk. Immutable. */

    export type FileContent = {
      readonly path: string;
      readonly content: string;
    };


    /** The type of a symbol identified in the code. */

    export type CodeNodeType =
      | 'file'
      | 'class'
      | 'function'
      | 'interface'
      | 'variable'
      | 'type'
      | 'arrow_function'
      | 'method'
      | 'field'
      | 'struct'
      | 'enum'
      | 'namespace'
      | 'trait'
      | 'impl'
      | 'constructor'
      | 'property'
      | 'constant'
      | 'static'
      | 'union'
      | 'template';

    /** Represents a single, identifiable symbol (or a file) in the code.
    Immutable. */

    export type CodeNode = {
      readonly id: string; // Unique identifier (e.g., 'src/api.ts#MyClass')
      readonly type: CodeNodeType;
      readonly name: string; // e.g., 'MyClass'
      readonly filePath: string;
      readonly startLine: number;
      readonly endLine: number;
      readonly codeSnippet?: string; // e.g., function signature
    };


    /** Represents a directed relationship between two CodeNodes. Immutable. */

    export type CodeEdge = {
      readonly fromId: string; // ID of the source CodeNode
      readonly toId: string;   // ID of the target CodeNode
      readonly type: 'imports' | 'calls' | 'inherits' | 'implements';
    };


    /** The complete, raw model of the repository's structure. Immutable. */

    export type CodeGraph = {
      readonly nodes: ReadonlyMap<string, CodeNode>;
      readonly edges: readonly CodeEdge[];
    };


    /** A CodeGraph with an added 'rank' score for each node. Immutable. */

    export type RankedCodeGraph = CodeGraph & {
      readonly ranks: ReadonlyMap<string, number>; // Key is CodeNode ID
    };


    // High-Level API Options


    /** Configuration for the final Markdown output. */

    export type RendererOptions = {
      /** Include a Mermaid.js dependency graph. @default true */
      readonly includeMermaidGraph?: boolean;
      /** Include detailed breakdowns for each symbol. @default true */
      readonly includeSymbolDetails?: boolean;
      /** Custom text to appear at the top of the Markdown file. */
      readonly customHeader?: string;
    };


    /** Configuration options for the main `generateMap` function. */

    export type RepoGraphOptions = {
      /** Root directory to analyze. @default process.cwd() */
      readonly root?: string;
      /** Output path for the Markdown file. @default './repograph.md' */
      readonly output?: string;
      /** Glob patterns for files to include. */
      readonly include?: readonly string[];
      /** Glob patterns for files to exclude. */
      readonly ignore?: readonly string[];
      /** Disables the use of .gitignore. @default false */
      readonly noGitignore?: boolean;
      /** The ranking strategy to use. @default 'pagerank' */
      readonly rankingStrategy?: 'pagerank' | 'git-changes';
      /** Configuration for the final Markdown output. */
      readonly rendererOptions?: RendererOptions;
    };


    // Low-Level Functional Pipeline Contracts


    /** Discovers files and returns their content. */

    export type FileDiscoverer = (config: {
      readonly root: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
    }) => Promise<readonly FileContent[]>;


    /** Analyzes file content and builds the dependency graph. */

    export type Analyzer = (files: readonly FileContent[]) =>
    Promise<CodeGraph>;


    /** Ranks the nodes in a graph. */

    export type Ranker = (graph: CodeGraph) => Promise<RankedCodeGraph>;


    /** Renders a ranked graph into a string format. */

    export type Renderer = (rankedGraph: RankedCodeGraph, options?:
    RendererOptions) => string;
  test/unit/composer.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMapGenerator } from '../../src/composer.js';

    import { createDefaultDiscoverer } from '../../src/pipeline/discover.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import type { FileDiscoverer, Analyzer, Ranker, Renderer, FileContent } from
    '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      assertFileExists,
      readFile,
      isValidMarkdown
    } from '../test.util.js';

    import path from 'node:path';


    describe('Composer', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMapGenerator()', () => {
        it('should return a function when given valid components', () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          expect(typeof generator).toBe('function');
        });

        it('should require all four components', () => {
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker()
            // Missing render
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            // Missing rank
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            // Missing analyze
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            // Missing discover
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();
        });

        it('should execute the full pipeline with default components', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Example');
        });

        it('should pass options through the pipeline correctly', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;',
            'src/test.spec.ts': 'test code'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'filtered.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts'],
            ignore: ['**/*.spec.ts']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/index.js');
          expect(content).not.toContain('src/test.spec.ts');
        });

        it('should pass renderer options correctly', async () => {
          const files = {
            'src/index.ts': `export class Test {
      method(): void {}
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath,
            rendererOptions: {
              customHeader: '# Custom Project',
              includeMermaidGraph: false,
              includeSymbolDetails: false
            }
          });

          const content = await readFile(outputPath);
          expect(content).toStartWith('# Custom Project');
          expect(content).not.toContain('```mermaid');
          expect(content).not.toContain('## 📂 File & Symbol Breakdown');
        });

        it('should create output directory if it does not exist', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'nested', 'deep', 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should handle empty projects gracefully', async () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'empty.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });
      });

      describe('Custom Components', () => {
        it('should work with custom discoverer', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer that only finds .js files
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            const allFiles = await defaultDiscoverer(options);
            return allFiles.filter(file => file.path.endsWith('.js'));
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'js-only.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.js');
          expect(content).not.toContain('src/index.ts');
        });

        it('should work with custom analyzer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          // Custom analyzer that adds extra metadata
          const customAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            const graph = await defaultAnalyzer(files);
            // This test now only verifies that a custom analyzer can be plugged in.
            // We'll just pass the graph through. A more complex test is below.
            return graph;
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: customAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom-analyzed.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should work with custom ranker', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;',
            'src/c.ts': 'export const c = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom ranker that assigns alphabetical ranks
          const customRanker: Ranker = async (graph) => {
            const ranks = new Map<string, number>();
            const fileNodes = [...graph.nodes.values()]
              .filter(node => node.type === 'file')
              .map(node => node.id);
            
            fileNodes.sort().forEach((nodeId, index) => {
              ranks.set(nodeId, 1 - (index / fileNodes.length));
            });
            
            // Set rank 0 for non-file nodes
            for (const nodeId of graph.nodes.keys()) {
                if (!ranks.has(nodeId)) {
                    ranks.set(nodeId, 0);
                }
            }
            
            return { graph, ranks };
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: customRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom-ranked.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          // src/a.ts should be ranked highest (alphabetically first)
          const aIndex = content.indexOf('src/a.ts');
          const bIndex = content.indexOf('src/b.ts');
          expect(aIndex).toBeLessThan(bIndex);
        });

        it('should work with custom renderer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          // Custom renderer that adds extra sections
          const customRenderer: Renderer = (rankedGraph, options) => {
            const defaultRenderer = createMarkdownRenderer();
            const baseMarkdown = defaultRenderer(rankedGraph, options);
            const { nodes, edges } = rankedGraph;
            return `${baseMarkdown}\n\n## Custom Section\n\nThis was added by a custom renderer.\n\n### Statistics\n- Total nodes: ${nodes.size}\n- Total edges: ${edges.length}`;
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'custom-rendered.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('## Custom Section');
          expect(content).toContain('This was added by a custom renderer');
          expect(content).toContain('### Statistics');
          expect(content).toContain('Total nodes:');
          expect(content).toContain('Total edges:');
        });

        it('should work with all custom components', async () => {
          const files = {
            'custom.special': 'special file content',
            'src/index.ts': 'export const normal = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer for .special files
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            // The original logic had a bug that duplicated files. We just need to
            // ensure all files are discovered for the test.
            return defaultDiscoverer(options);
          };

          // Custom analyzer that handles .special files
          const customAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            const { nodes, edges } = await defaultAnalyzer(files.filter(f => !f.path.endsWith('.special')));
            
            // Add special file nodes
            const newNodes = new Map(nodes);
            files.filter(f => f.path.endsWith('.special')).forEach(file => {
              newNodes.set(file.path, {
                id: file.path,
                type: 'special' as any,
                name: path.basename(file.path),
                filePath: file.path,
                startLine: 1,
                endLine: 1
              });
            });
            
            return { nodes: newNodes, edges };
          };

          // Custom ranker that gives special files high rank
          const customRanker: Ranker = async (graph) => {
            const ranks = new Map<string, number>();
            
            for (const [nodeId, node] of graph.nodes.entries()) {
              const nodeType = node.type as string;
              if (nodeType === 'special') {
                ranks.set(nodeId, 1.0);
              } else {
                ranks.set(nodeId, 0.5);
              }
            }
            
            return { ...graph, ranks };
          };

          // Custom renderer that handles special files
          const customRenderer: Renderer = (rankedGraph, options) => {
            const specialNodes = [...rankedGraph.nodes.values()].filter(node =>
              (node.type as string) === 'special'
            ).map(n => n.id);
            
            let markdown = '# Custom Project with Special Files\n\n';
            
            if (specialNodes.length > 0) {
              markdown += '## Special Files\n\n';
              specialNodes.forEach(nodeId => {
                const node = rankedGraph.nodes.get(nodeId)!;
                markdown += `- **${node.name}** (rank: ${rankedGraph.ranks.get(nodeId)?.toFixed(2)})\n`;
              });
              markdown += '\n';
            }
            
            const defaultRenderer = createMarkdownRenderer();
            const baseMarkdown = defaultRenderer(rankedGraph, options);
            
            return markdown + baseMarkdown.split('\n').slice(2).join('\n'); // Remove default header
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: customAnalyzer,
            rank: customRanker,
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'all-custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('# Custom Project with Special Files');
          expect(content).toContain('## Special Files');
          expect(content).toContain('custom.special');
        });
      });

      describe('Error Handling', () => {
        it('should handle discoverer errors gracefully', async () => {
          const errorDiscoverer: FileDiscoverer = async () => {
            throw new Error('Discoverer failed');
          };

          const generator = createMapGenerator({
            discover: errorDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Discoverer failed');
        });

        it('should handle analyzer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorAnalyzer: Analyzer = async () => {
            throw new Error('Analyzer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: errorAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Analyzer failed');
        });

        it('should handle ranker errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRanker: Ranker = async () => {
            throw new Error('Ranker failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: errorRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Ranker failed');
        });

        it('should handle renderer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRenderer: Renderer = () => {
            throw new Error('Renderer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: errorRenderer
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Renderer failed');
        });

        it('should handle file write errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          // Try to write to an invalid path
          const invalidOutputPath = '/root/cannot-write.md';
          
          await expect(generator({
            root: tempDir,
            output: invalidOutputPath
          })).rejects.toThrow();
        });
      });

      describe('Component Interface Validation', () => {
        it('should validate discoverer interface', () => {
          const invalidDiscoverer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: invalidDiscoverer as any,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate analyzer interface', () => {
          const invalidAnalyzer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: invalidAnalyzer as any,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate ranker interface', () => {
          const invalidRanker = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: invalidRanker as any,
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate renderer interface', () => {
          const invalidRenderer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: invalidRenderer as any
          })).toThrow();
        });
      });

      describe('Pipeline Data Flow', () => {
        it('should pass files from discoverer to analyzer', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;'
          };
          await createTestFiles(tempDir, files);

          let discoveredFiles: readonly FileContent[] = [];
          let analyzedFiles: readonly FileContent[] = [];

          const trackingDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            discoveredFiles = await defaultDiscoverer(options);
            return discoveredFiles;
          };

          const trackingAnalyzer: Analyzer = async (files) => {
            analyzedFiles = files;
            const defaultAnalyzer = createTreeSitterAnalyzer();
            return await defaultAnalyzer(files);
          };

          const generator = createMapGenerator({
            discover: trackingDiscoverer,
            analyze: trackingAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(discoveredFiles.length).toBe(2);
          expect(analyzedFiles.length).toBe(2);
          expect(analyzedFiles).toEqual(discoveredFiles);
        });

        it('should pass graph from analyzer to ranker', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let analyzedGraph: any;
          let rankedGraph: any;

          const trackingAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            analyzedGraph = await defaultAnalyzer(files);
            return analyzedGraph;
          };

          const trackingRanker: Ranker = async (graph) => {
            rankedGraph = graph;
            const defaultRanker = createPageRanker();
            return await defaultRanker(graph);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: trackingAnalyzer,
            rank: trackingRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rankedGraph).toBe(analyzedGraph);
        });

        it('should pass ranked graph from ranker to renderer', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let rankerOutput: any;
          let rendererInput: any;

          const trackingRanker: Ranker = async (graph) => {
            const defaultRanker = createPageRanker();
            rankerOutput = await defaultRanker(graph);
            return rankerOutput;
          };

          const trackingRenderer: Renderer = (rankedGraph, options) => {
            rendererInput = rankedGraph;
            const defaultRenderer = createMarkdownRenderer();
            return defaultRenderer(rankedGraph, options);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: trackingRanker,
            render: trackingRenderer
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rendererInput).toBe(rankerOutput);
        });
      });
    });
  test/unit/analyze.test.ts: |-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
    import type { FileContent } from '../../src/types.js';
    import {
      createTempDir,
      cleanupTempDir,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';

    describe('Tree-sitter Analysis', () => {
      let tempDir: string;
      let analyzer: ReturnType<typeof createTreeSitterAnalyzer>;

      beforeEach(async () => {
        tempDir = await createTempDir();
        analyzer = createTreeSitterAnalyzer();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createTreeSitterAnalyzer()', () => {
        it('should return an Analyzer function', () => {
          expect(typeof analyzer).toBe('function');
        });

        it('should create a CodeGraph from file content', async () => {
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `export function hello(): string {
      return 'Hello, World!';
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph).toBeDefined();
          expect(graph.nodes.size).toBeGreaterThan(0); // Should have nodes
        });

        it('should add file nodes to the graph', async () => {
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: 'export const hello = "world";'
            },
            {
              path: 'src/utils.ts',
              content: 'export const util = () => {};'
            }
          ];

          const graph = await analyzer(files);

          expect(graph.nodes.has('src/index.ts')).toBe(true);
          expect(graph.nodes.has('src/utils.ts')).toBe(true);

          const indexNode = graph.nodes.get('src/index.ts');
          expect(indexNode!.type).toBe('file');
          expect(indexNode.name).toBe('index.ts');
          expect(indexNode.filePath).toBe('src/index.ts');
        });

        it('should identify function declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/functions.ts',
              content: `export function add(a: number, b: number): number {
      return a + b;
    }

    export function multiply(x: number, y: number): number {
      return x * y;
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.nodes.has('src/functions.ts#add')).toBe(true);
          expect(graph.nodes.has('src/functions.ts#multiply')).toBe(true);

          const addNode = graph.nodes.get('src/functions.ts#add');
          expect(addNode.type).toBe('function');
          expect(addNode.name).toBe('add');
          expect(addNode.filePath).toBe('src/functions.ts');
          expect(addNode.startLine).toBeGreaterThan(0);
        });

        it('should identify arrow function declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/arrows.ts',
              content: `export const greet = (name: string): string => {
      return \`Hello, \${name}!\`;
    };

    const calculate = (x: number, y: number): number => x + y;`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.nodes.has('src/arrows.ts#greet')).toBe(true);
          expect(graph.nodes.has('src/arrows.ts#calculate')).toBe(true);

          const greetNode = graph.nodes.get('src/arrows.ts#greet');
          expect(greetNode.type).toBe('arrow_function');
          expect(greetNode.name).toBe('greet');
        });

        it('should identify class declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/classes.ts',
              content: `export class Calculator {
      private value: number = 0;
      
      add(n: number): this {
        this.value += n;
        return this;
      }
    }

    class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.nodes.has('src/classes.ts#Calculator')).toBe(true);
          expect(graph.nodes.has('src/classes.ts#Logger')).toBe(true);

          const calculatorNode = graph.nodes.get('src/classes.ts#Calculator');
          expect(calculatorNode.type).toBe('class');
          expect(calculatorNode.name).toBe('Calculator');
          expect(calculatorNode.codeSnippet).toContain('export class Calculator');
        });

        it('should identify interface declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/interfaces.ts',
              content: `export interface User {
      id: number;
      name: string;
      email: string;
    }

    interface Config {
      debug: boolean;
      version: string;
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.nodes.has('src/interfaces.ts#User')).toBe(true);
          expect(graph.nodes.has('src/interfaces.ts#Config')).toBe(true);

          const userNode = graph.nodes.get('src/interfaces.ts#User');
          expect(userNode.type).toBe('interface');
          expect(userNode.name).toBe('User');
        });

        it('should identify type alias declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/types.ts',
              content: `export type Status = 'active' | 'inactive' | 'pending';

    type Handler = (event: Event) => void;

    export type UserRole = 'admin' | 'user' | 'guest';`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.nodes.has('src/types.ts#Status')).toBe(true);
          expect(graph.nodes.has('src/types.ts#Handler')).toBe(true);
          expect(graph.nodes.has('src/types.ts#UserRole')).toBe(true);

          const statusNode = graph.nodes.get('src/types.ts#Status');
          expect(statusNode.type).toBe('type');
          expect(statusNode.name).toBe('Status');
        });

        it('should identify import statements and create edges', async () => {
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';
    import { Logger } from './utils/logger.js';

    export { Calculator, Logger };`
            },
            {
              path: 'src/calculator.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
    }`
            },
            {
              path: 'src/utils/logger.ts',
              content: `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          // Check if import edges exist
          const hasCalculatorImport = graph.edges.some(e => e.fromId === 'src/index.ts' && e.toId === 'src/calculator.ts');
          const hasLoggerImport = graph.edges.some(e => e.fromId === 'src/index.ts' && e.toId === 'src/utils/logger.ts');
          
          expect(hasCalculatorImport).toBe(true);
          expect(hasLoggerImport).toBe(true);
        });

        it('should handle files with no symbols gracefully', async () => {
          const files: FileContent[] = [
            {
              path: 'README.md',
              content: '# Project\n\nThis is a readme file.'
            },
            {
              path: 'src/empty.ts',
              content: '// This file is empty\n'
            }
          ];

          const graph = await analyzer(files);

          // Should still create file nodes
          expect(graph.nodes.has('README.md')).toBe(true);
          expect(graph.nodes.has('src/empty.ts')).toBe(true);

          const readmeNode = graph.nodes.get('README.md');
          expect(readmeNode.type).toBe('file');
        });

        it('should handle malformed or unparseable files gracefully', async () => {
          const files: FileContent[] = [
            {
              path: 'src/valid.ts',
              content: 'export const valid = true;'
            },
            {
              path: 'src/invalid.ts',
              content: 'this is not valid typescript syntax {'
            }
          ];

          const graph = await analyzer(files);

          // Should still create file nodes for both
          expect(graph.nodes.has('src/valid.ts')).toBe(true);
          expect(graph.nodes.has('src/invalid.ts')).toBe(true);
        });

        it('should set correct line numbers for symbols', async () => {
          const files: FileContent[] = [
            {
              path: 'src/multiline.ts',
              content: `// Line 1
    // Line 2
    export class FirstClass {
      // Line 4
      method(): void {}
    }

    // Line 8
    export function secondFunction(): string {
      return 'hello';
    }

    // Line 13
    export interface ThirdInterface {
      prop: string;
    }`
            }
          ];

          const graph = await analyzer(files);

          const firstClass = graph.nodes.get('src/multiline.ts#FirstClass');
          const secondFunction = graph.nodes.get('src/multiline.ts#secondFunction');
          const thirdInterface = graph.nodes.get('src/multiline.ts#ThirdInterface');

          expect(firstClass.startLine).toBe(3);
          expect(secondFunction.startLine).toBe(9);
          expect(thirdInterface.startLine).toBe(14);

          expect(firstClass.endLine).toBeGreaterThan(firstClass.startLine);
          expect(secondFunction.endLine).toBeGreaterThan(secondFunction.startLine);
          expect(thirdInterface.endLine).toBeGreaterThan(thirdInterface.startLine);
        });

        it('should include code snippets for symbols', async () => {
          const files: FileContent[] = [
            {
              path: 'src/snippets.ts',
              content: `export class Calculator {
      private value: number = 0;
      
      add(n: number): this {
        this.value += n;
        return this;
      }
    }

    export function multiply(a: number, b: number): number {
      return a * b;
    }`
            }
          ];

          const graph = await analyzer(files);

          const calculatorNode = graph.nodes.get('src/snippets.ts#Calculator');
          const multiplyNode = graph.nodes.get('src/snippets.ts#multiply');

          expect(calculatorNode.codeSnippet).toContain('export class Calculator');
          expect(multiplyNode.codeSnippet).toContain('export function multiply(a: number, b: number): number');
        });

        it('should handle complex import patterns', async () => {
          const files: FileContent[] = [
            {
              path: 'src/imports.ts',
              content: `import { Calculator } from './math/calculator.js';
    import * as utils from './utils.js';
    import type { Config } from './config.js';
    import Logger, { LogLevel } from './logger.js';`
            },
            {
              path: 'src/math/calculator.ts',
              content: 'export class Calculator {}'
            },
            {
              path: 'src/utils.ts',
              content: 'export const helper = () => {};'
            },
            {
              path: 'src/config.ts',
              content: 'export interface Config {}'
            },
            {
              path: 'src/logger.ts',
              content: 'export default class Logger {}'
            }
          ];

          const graph = await analyzer(files);

          // Check import edges
          const hasCalcImport = graph.edges.some(e => e.fromId === 'src/imports.ts' && e.toId === 'src/math/calculator.ts');
          const hasUtilsImport = graph.edges.some(e => e.fromId === 'src/imports.ts' && e.toId === 'src/utils.ts');
          const hasConfigImport = graph.edges.some(e => e.fromId === 'src/imports.ts' && e.toId === 'src/config.ts');
          const hasLoggerImport = graph.edges.some(e => e.fromId === 'src/imports.ts' && e.toId === 'src/logger.ts');
          expect(hasCalcImport).toBe(true);
          expect(hasUtilsImport).toBe(true);
          expect(hasConfigImport).toBe(true);
          expect(hasLoggerImport).toBe(true);
        });

        it('should handle nested class and function definitions', async () => {
          const files: FileContent[] = [
            {
              path: 'src/nested.ts',
              content: `export class OuterClass {
      private inner = class InnerClass {
        method(): void {}
      };
      
      outerMethod(): void {
        function nestedFunction(): string {
          return 'nested';
        }
        nestedFunction();
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          // Should identify the outer class
          expect(graph.nodes.has('src/nested.ts#OuterClass')).toBe(true);
          
          const outerClass = graph.nodes.get('src/nested.ts#OuterClass');
          expect(outerClass.type).toBe('class');
          expect(outerClass.name).toBe('OuterClass');
        });

        it('should handle circular imports gracefully', async () => {
          const files: FileContent[] = [
            {
              path: 'src/a.ts',
              content: `import { B } from './b.js';
    export class A {
      b: B;
    }`
            },
            {
              path: 'src/b.ts',
              content: `import { A } from './a.js';
    export class B {
      a: A;
    }`
            }
          ];

          const graph = await analyzer(files);

          const aToB = graph.edges.some(e => e.fromId === 'src/a.ts' && e.toId === 'src/b.ts');
          const bToA = graph.edges.some(e => e.fromId === 'src/b.ts' && e.toId === 'src/a.ts');
          
          expect(aToB).toBe(true);
          expect(bToA).toBe(true);
          expect(graph.nodes.has('src/a.ts#A')).toBe(true);
          expect(graph.nodes.has('src/b.ts#B')).toBe(true);
        });
        it('should not create duplicate nodes for the same symbol', async () => {
          const files: FileContent[] = [
            {
              path: 'src/duplicate.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
    }

    // This should not create a duplicate
    export class Calculator {
      multiply(a: number, b: number): number {
        return a * b;
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          // Should only have one Calculator node (first one wins)
          const calculatorNodes = [...graph.nodes.keys()].filter((nodeId) =>
            nodeId.includes('#Calculator')
          );
          expect(calculatorNodes.length).toBe(1);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should analyze sample-project fixture correctly', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);

          expect(graph.nodes.size).toBe(fixture.expected_nodes!);
          
          // Check for specific symbols from the fixture
          expect(graph.nodes.has('src/calculator.ts#Calculator')).toBe(true);
          expect(graph.nodes.has('src/utils/logger.ts#Logger')).toBe(true);
          expect(graph.nodes.has('src/types.ts#Config')).toBe(true);
        });

        it('should analyze complex-project fixture correctly', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts') && !file.path.includes('test')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);

          // Check for key classes and interfaces
          expect(graph.nodes.has('src/database/index.ts#Database')).toBe(true);
          expect(graph.nodes.has('src/api/server.ts#ApiServer')).toBe(true);
          expect(graph.nodes.has('src/services/user.ts#UserService')).toBe(true);
          
          // Check for import relationships
          const serverToDb = graph.edges.some(e => e.fromId === 'src/api/server.ts' && e.toId === 'src/database/index.ts');
          const serverToUser = graph.edges.some(e => e.fromId === 'src/api/server.ts' && e.toId === 'src/services/user.ts');
          expect(serverToDb).toBe(true);
          expect(serverToUser).toBe(true);
        });

        it('should handle minimal-project fixture', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const files: FileContent[] = [
            {
              path: 'src/main.ts',
              content: fixture.files[0]!.content
            }
          ];

          const graph = await analyzer(files);

          expect(graph.nodes.has('src/main.ts')).toBe(true);
          expect(graph.nodes.has('src/main.ts#hello')).toBe(true);
          expect(graph.nodes.has('src/main.ts#greet')).toBe(true);

          const helloNode = graph.nodes.get('src/main.ts#hello');
          const greetNode = graph.nodes.get('src/main.ts#greet');

          expect(helloNode.type).toBe('function');
          expect(greetNode.type).toBe('arrow_function');
        });
      });
    });
approved: true
