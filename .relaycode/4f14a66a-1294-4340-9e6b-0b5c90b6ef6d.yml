uuid: 4f14a66a-1294-4340-9e6b-0b5c90b6ef6d
projectId: repograph
createdAt: '2025-06-30T05:40:48.067Z'
gitCommitMsg: 'fix(types): resolve typescript errors and remove unused imports'
promptSummary: >-
  The user provided a list of TypeScript compilation errors. I've addressed each
  one by removing unused imports and correcting type mismatches in the test
  files.
reasoning:
  - >-
    Of course. It seems my last set of changes introduced some TypeScript type
    errors and left behind some unused imports. I'll clean those up now.
  - >-
    I'll start by removing the unused `RepoGraphError` import from
    `src/pipeline/rank.ts`.
  - >-
    Next, I'll fix the type error in `test/integration/multi-language.test.ts`.
    By adding an explicit interface for the `testCases` array, I can ensure
    TypeScript correctly infers the type of the `files` object within the
    parameterized test.
  - >-
    In `test/unit/composer.test.ts`, there's a readonly type mismatch. The
    `createDefaultDiscoverer` returns a `readonly` array, so I'll update the
    type of `discoveredFiles` to match it.
  - Now, I'll remove the unused `execSync` import from `test/unit/rank.test.ts`.
  - >-
    Finally, I'll remove a couple of unused imports from
    `test/unit/render.test.ts` to clear the last of the errors.
  - >-
    These changes should resolve all the TypeScript errors and get your build
    passing again.
operations:
  - type: write
    path: src/pipeline/rank.ts
    content: |-
      --- src/pipeline/rank.ts
      +++ src/pipeline/rank.ts
      @@ -1,6 +1,5 @@
       import pagerank from 'graphology-pagerank';
       import type { CodeGraph, Ranker, RankedCodeGraph } from '../types.js';
      -import { RepoGraphError } from '../utils/error.util.js';
       import Graph from 'graphology';
       import { execSync } from 'node:child_process';
       import { logger } from '../utils/logger.util.js';
    patchStrategy: new-unified
  - type: write
    path: test/integration/multi-language.test.ts
    content: |-
      --- test/integration/multi-language.test.ts
      +++ test/integration/multi-language.test.ts
      @@ -1,8 +1,15 @@
       import { describe, it, expect } from 'bun:test';
       import { runRepoGraphForTests } from '../test.util.js';
       
      +interface TestCase {
      +  language: string;
      +  extension: string;
      +  files: Record<string, string>;
      +  expectedSymbols: string[];
      +}
      +
       describe('Multi-Language Support', () => {
      -  const testCases = [
      +  const testCases: TestCase[] = [
           {
             language: 'TypeScript',
             extension: 'ts',
    patchStrategy: new-unified
  - type: write
    path: test/unit/composer.test.ts
    content: |-
      --- test/unit/composer.test.ts
      +++ test/unit/composer.test.ts
      @@ -101,7 +101,7 @@
         });
       
         describe('Custom Components', () => {
      -    let discoveredFiles: FileContent[] = [];
      +    let discoveredFiles: readonly FileContent[] = [];
           it('should work with custom discoverer', async () => {
             const files = {
               'src/index.ts': 'export const ts = true;',
    patchStrategy: new-unified
  - type: write
    path: test/unit/rank.test.ts
    content: |-
      --- test/unit/rank.test.ts
      +++ test/unit/rank.test.ts
      @@ -12,7 +12,6 @@
       } from '../test.util.js';
       import fs from 'node:fs/promises';
       import path from 'node:path';
      -import { execSync } from 'node:child_process';
       
       describe('Graph Ranking', () => {
         let tempDir: string;
    patchStrategy: new-unified
  - type: write
    path: test/unit/render.test.ts
    content: |-
      --- test/unit/render.test.ts
      +++ test/unit/render.test.ts
      @@ -6,11 +6,8 @@
         createTempDir,
         cleanupTempDir,
         isValidMarkdown,
         containsValidMermaid,
      -  extractFilePathsFromMarkdown,
         createTestNode,
      -  createTestGraph
       } from '../test.util.js';
       
       describe('Markdown Rendering', () => {
    patchStrategy: new-unified
snapshot:
  src/pipeline/rank.ts: >-
    import pagerank from 'graphology-pagerank';

    import type { CodeGraph, Ranker, RankedCodeGraph } from '../types.js';

    import { RepoGraphError } from '../utils/error.util.js';

    import Graph from 'graphology';

    import { execSync } from 'node:child_process';

    import { logger } from '../utils/logger.util.js';


    /**
     * Creates a ranker that uses the PageRank algorithm. Nodes that are heavily referenced by
     * other important nodes will receive a higher rank.
     * @returns A Ranker function.
     */
    export const createPageRanker = (): Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        // PageRank can only be computed on graphs with nodes.
        if (graph.nodes.size === 0) {
          return { ...graph, ranks: new Map() };
        }

        // Pagerank lib requires a graphology instance.
        const simpleGraph = new Graph({ type: 'directed' });
        for (const [nodeId, node] of graph.nodes) {
          simpleGraph.addNode(nodeId, node);
        }
        for (const edge of graph.edges) {
          if (!simpleGraph.hasEdge(edge.fromId, edge.toId)) {
            simpleGraph.addDirectedEdge(edge.fromId, edge.toId);
          }
        }

        const graphForRank = simpleGraph;
        const ranksData = pagerank(graphForRank);
        const ranks = new Map<string, number>();
        for (const node in ranksData) {
          ranks.set(node, ranksData[node] ?? 0);
        }
        return { ...graph, ranks };
      };
    };


    /**
     * Creates a ranker based on Git commit history. Files changed more frequently are considered
     * more important. Requires Git to be installed.
     * @returns A Ranker function.
     */
    export const createGitRanker = (options: { maxCommits?: number } = {}):
    Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        const { maxCommits = 500 } = options;
        const ranks = new Map<string, number>();

        if (graph.nodes.size === 0) {
          return { ...graph, ranks };
        }

        try {
          const command = `git log --max-count=${maxCommits} --name-only --pretty=format:`;
          const output = execSync(command, { encoding: 'utf-8' });
          const files = output.split('\n').filter(Boolean);

          const changeCounts: Record<string, number> = {};
          for (const file of files) {
            changeCounts[file] = (changeCounts[file] || 0) + 1;
          }

          const maxChanges = Math.max(...Object.values(changeCounts), 1);

          for (const [nodeId, attributes] of graph.nodes) {
            // We only rank file nodes with this strategy
            if (attributes.type === 'file') {
              const count = changeCounts[attributes.filePath] ?? 0;
              ranks.set(nodeId, count / maxChanges); // Normalize score
            } else {
              ranks.set(nodeId, 0);
            }
          }
        } catch (e) {
          // This is not a fatal error for the whole process, but this ranker cannot proceed.
          logger.warn('Failed to use \'git\' for ranking. Is git installed and is this a git repository? Returning 0 for all ranks.');
          for (const [nodeId] of graph.nodes) {
            ranks.set(nodeId, 0);
          }
        }

        return { ...graph, ranks };
      };
    };
  test/integration/multi-language.test.ts: |-
    import { describe, it, expect } from 'bun:test';
    import { runRepoGraphForTests } from '../test.util.js';

    describe('Multi-Language Support', () => {
      const testCases = [
        {
          language: 'TypeScript',
          extension: 'ts',
          files: {
            'src/calculator.ts': `export class Calculator {
      add(a: number, b: number): number { return a + b; }
      multiply = (a: number, b: number): number => { return a * b; }
    }
    export interface CalculatorOptions { precision: number; }
    export type Operation = 'add' | 'multiply';`
          },
          expectedSymbols: ['Calculator', 'add', 'multiply', 'CalculatorOptions', 'Operation']
        },
        {
          language: 'Python',
          extension: 'py',
          files: {
            'src/math_utils.py': `import math
    from typing import List
    class MathUtils:
        def calculate_area(self, radius: float) -> float:
            return math.pi * radius ** 2
    def factorial(n: int) -> int:
        if n <= 1: return 1
        return n * factorial(n - 1)`
          },
          expectedSymbols: ['MathUtils', 'calculate_area', 'factorial']
        },
        {
          language: 'Java',
          extension: 'java',
          files: {
            'src/StringHelper.java': `package com.example;
    public class StringHelper {
        public String concatenate(String a, String b) { return a + b; }
    }
    interface Formatter { String format(String s); }
    enum TextCase { UPPER, LOWER }`
          },
          expectedSymbols: ['StringHelper', 'concatenate', 'Formatter', 'TextCase']
        },
        {
          language: 'Go',
          extension: 'go',
          files: {
            'src/utils.go': `package main
    type Point struct { X, Y float64 }
    func (p Point) Distance() float64 { return 0.0 }
    func Add(a, b int) int { return a + b }`
          },
          expectedSymbols: ['Point', 'Distance', 'Add']
        },
        {
          language: 'Rust',
          extension: 'rs',
          files: {
            'src/lib.rs': `pub struct Point { x: f64, y: f64 }
    impl Point { pub fn new(x: f64, y: f64) -> Self { Point { x, y } } }
    pub fn calculate_perimeter() -> f64 { 0.0 }`
          },
          expectedSymbols: ['Point', 'new', 'calculate_perimeter']
        },
        {
          language: 'C',
          extension: 'c',
          files: {
            'src/math.c': `#include <stdio.h>
    typedef struct { double x; double y; } Point;
    enum Color { RED, GREEN, BLUE };
    double calculate_distance(Point p1, Point p2) { return 0.0; }`
          },
          expectedSymbols: ['Point', 'Color', 'calculate_distance']
        }
      ];

      it.each(testCases)('should analyze $language files', async ({ files, expectedSymbols, extension }) => {
        const content = await runRepoGraphForTests(files, {
          include: [`**/*.${extension}`]
        });

        for (const symbol of expectedSymbols) {
          expect(content).toContain(symbol);
        }
      });

      it('should analyze multi-language projects', async () => {
        const files = {
          'src/frontend/app.ts': `export class App {}`,
          'src/backend/server.py': `class Server: pass`,
          'src/api/Controller.java': `public class Controller {}`,
          'src/services/auth.go': `package services\nfunc Authenticate(token string) bool { return true }`,
          'src/core/engine.rs': `pub struct Engine {}`
        };

        const content = await runRepoGraphForTests(files);

        expect(content).toContain('App');
        expect(content).toContain('Server');
        expect(content).toContain('Controller');
        expect(content).toContain('Authenticate');
        expect(content).toContain('Engine');
      });

      it('should handle unsupported file types gracefully', async () => {
        const files = {
          'src/code.ts': `export const hello = 'world';`,
          'README.md': '# This is markdown',
          'config.json': '{"key": "value"}'
        };

        const content = await runRepoGraphForTests(files);

        expect(content).toContain('code.ts');
        expect(content).toContain('hello');
        expect(content).toContain('README.md');
        expect(content).toContain('config.json');
        expect(content).not.toContain('key');
      });
    });
  test/unit/composer.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMapGenerator } from '../../src/composer.js';

    import { createDefaultDiscoverer } from '../../src/pipeline/discover.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import type { FileDiscoverer, Analyzer, Ranker, Renderer, FileContent } from
    '../../src/types.js';

    import {
      createTempDir, // Keep for beforeEach/afterEach
      cleanupTempDir,
      createTestFiles,
      assertFileExists,
      isValidMarkdown,
    } from '../test.util.js';

    import path from 'node:path';

    import fs from 'node:fs/promises';


    describe('Composer', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMapGenerator()', () => {
        it('should return a function when given valid components', () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          expect(typeof generator).toBe('function');
        });

        it('should require all four components', () => {
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker()
            // Missing render
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            // Missing rank
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            // Missing analyze
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            // Missing discover
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();
        });

        it('should create output directory if it does not exist', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'nested', 'deep', 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should handle empty projects gracefully', async () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'empty.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
          const content = await fs.readFile(outputPath, 'utf-8');
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });
      });

      describe('Custom Components', () => {
        let discoveredFiles: FileContent[] = [];
        it('should work with custom discoverer', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer that tracks what it found
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            discoveredFiles = await defaultDiscoverer(options);
            return discoveredFiles;
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(discoveredFiles.some(f => f.path === 'src/index.js')).toBe(true);
        });

        it('should work with custom analyzer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          let wasCustomAnalyzerCalled = false;
          const customAnalyzer: Analyzer = async (files) => {
            wasCustomAnalyzerCalled = true;
            const defaultAnalyzer = createTreeSitterAnalyzer();
            return await defaultAnalyzer(files);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: customAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(wasCustomAnalyzerCalled).toBe(true);
          await assertFileExists(outputPath);
        });

        it('should work with custom ranker', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;',
            'src/c.ts': 'export const c = true;'
          };
          await createTestFiles(tempDir, files);

          let wasCustomRankerCalled = false;
          const customRanker: Ranker = async (graph) => {
            wasCustomRankerCalled = true;
            return await createPageRanker()(graph);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: customRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({ root: tempDir, output: outputPath });

          expect(wasCustomRankerCalled).toBe(true);
        });

        it('should work with custom renderer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          let wasCustomRendererCalled = false;
          const customRenderer: Renderer = (rankedGraph, options) => {
            wasCustomRendererCalled = true;
            return createMarkdownRenderer()(rankedGraph, options);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });
          expect(wasCustomRendererCalled).toBe(true);
        });

        it('should work with all custom components', async () => {
          const files = {
            'custom.special': 'special file content',
            'src/index.ts': 'export const normal = true;'
          };
          await createTestFiles(tempDir, files);

          const customDiscoverer: FileDiscoverer = async () => [{ path: 'custom.special', content: 'custom' }];
          const customAnalyzer: Analyzer = async () => ({ nodes: new Map(), edges: [] });
          const customRanker: Ranker = async (g) => ({ ...g, ranks: new Map() });
          const customRenderer: Renderer = () => 'CUSTOM RENDERER OUTPUT';

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: customAnalyzer,
            rank: customRanker,
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await fs.readFile(outputPath, 'utf-8');
          expect(content).toBe('CUSTOM RENDERER OUTPUT');
        });
      });

      describe('Error Handling', () => {
        it('should handle discoverer errors gracefully', async () => {
          const errorDiscoverer: FileDiscoverer = async () => {
            throw new Error('Discoverer failed');
          };

          const generator = createMapGenerator({
            discover: errorDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Discoverer failed');
        });

        it('should handle analyzer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorAnalyzer: Analyzer = async () => {
            throw new Error('Analyzer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: errorAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Analyzer failed');
        });

        it('should handle ranker errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRanker: Ranker = async () => {
            throw new Error('Ranker failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: errorRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Ranker failed');
        });

        it('should handle renderer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRenderer: Renderer = () => {
            throw new Error('Renderer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: errorRenderer
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Renderer failed');
        });

        it('should handle file write errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          // Try to write to an invalid path
          const invalidOutputPath = '/root/cannot-write.md';
          
          await expect(generator({
            root: tempDir,
            output: invalidOutputPath
          })).rejects.toThrow();
        });
      });

      describe('Component Interface Validation', () => {
        it('should validate discoverer interface', () => {
          const invalidDiscoverer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: invalidDiscoverer as any,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate analyzer interface', () => {
          const invalidAnalyzer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: invalidAnalyzer as any,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate ranker interface', () => {
          const invalidRanker = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: invalidRanker as any,
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate renderer interface', () => {
          const invalidRenderer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: invalidRenderer as any
          })).toThrow();
        });
      });

      describe('Pipeline Data Flow', () => {
        it('should pass files from discoverer to analyzer', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;'
          };
          await createTestFiles(tempDir, files);

          let discoveredFiles: readonly FileContent[] = [];
          let analyzedFiles: readonly FileContent[] = [];

          const trackingDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            discoveredFiles = await defaultDiscoverer(options);
            return discoveredFiles;
          };

          const trackingAnalyzer: Analyzer = async (files) => {
            analyzedFiles = files;
            const defaultAnalyzer = createTreeSitterAnalyzer();
            return await defaultAnalyzer(files);
          };

          const generator = createMapGenerator({
            discover: trackingDiscoverer,
            analyze: trackingAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(discoveredFiles.length).toBe(2);
          expect(analyzedFiles.length).toBe(2);
          expect(analyzedFiles).toEqual(discoveredFiles);
        });

        it('should pass graph from analyzer to ranker', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let analyzedGraph: any;
          let rankedGraph: any;

          const trackingAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            analyzedGraph = await defaultAnalyzer(files);
            return analyzedGraph;
          };

          const trackingRanker: Ranker = async (graph) => {
            rankedGraph = graph;
            const defaultRanker = createPageRanker();
            return await defaultRanker(graph);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: trackingAnalyzer,
            rank: trackingRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rankedGraph).toBe(analyzedGraph);
        });

        it('should pass ranked graph from ranker to renderer', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let rankerOutput: any;
          let rendererInput: any;

          const trackingRanker: Ranker = async (graph) => {
            const defaultRanker = createPageRanker();
            rankerOutput = await defaultRanker(graph);
            return rankerOutput;
          };

          const trackingRenderer: Renderer = (rankedGraph, options) => {
            rendererInput = rankedGraph;
            const defaultRenderer = createMarkdownRenderer();
            return defaultRenderer(rankedGraph, options);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: trackingRanker,
            render: trackingRenderer
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rendererInput).toBe(rankerOutput);
        });
      });
    });
  test/unit/rank.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createPageRanker, createGitRanker } from
    '../../src/pipeline/rank.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import type { FileContent, CodeGraph } from '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      createTestNode,
      createTestGraph,
      setupGitRepo,
      makeGitCommit
    } from '../test.util.js';

    import fs from 'node:fs/promises';

    import path from 'node:path';

    import { execSync } from 'node:child_process';


    describe('Graph Ranking', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createPageRanker()', () => {
        let pageRanker: ReturnType<typeof createPageRanker>;

        beforeEach(() => {
          pageRanker = createPageRanker();
        });

        it('should return a Ranker function', () => {
          expect(typeof pageRanker).toBe('function');
        });

        it('should handle empty graphs gracefully', async () => {
          const emptyGraph: CodeGraph = {
            nodes: new Map(),
            edges: [],
          };

          const result = await pageRanker(emptyGraph);

          expect(result.nodes).toBe(emptyGraph.nodes);
          expect(result.edges).toBe(emptyGraph.edges);
          expect(result.ranks.size).toBe(0);
        });

        it('should assign ranks to all nodes in the graph', async () => {
          const graph = createTestGraph(
            [createTestNode('file1'), createTestNode('file2'), createTestNode('symbol1', { type: 'function' })],
            [{ fromId: 'file1', toId: 'file2', type: 'imports' }]
          );
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBe(3);
          expect(result.ranks.has('file1')).toBe(true);
          expect(result.ranks.has('file2')).toBe(true);
          expect(result.ranks.has('symbol1')).toBe(true);

          // All ranks should be positive numbers
          for (const rank of result.ranks.values()) {
            expect(rank).toBeGreaterThan(0);
          }
        });

        it('should assign higher ranks to more connected nodes', async () => {
          const hub = createTestNode('hub');
          const isolated = createTestNode('isolated');
          const spokes = Array.from({ length: 5 }, (_, i) => createTestNode(`node${i + 1}`));
          const edges = spokes.map(spoke => ({ fromId: spoke.id, toId: hub.id, type: 'imports' as const }));

          const graph: CodeGraph = createTestGraph([hub, isolated, ...spokes], edges);
          const result = await pageRanker(graph);

          const hubRank = result.ranks.get('hub')!;
          const isolatedRank = result.ranks.get('isolated')!;
          const spokeRank = result.ranks.get('node1')!;

          // Hub should have higher rank than isolated node
          expect(hubRank).toBeGreaterThan(isolatedRank);
          // Hub should have a higher rank than any single spoke that links to it
          expect(hubRank).toBeGreaterThan(spokeRank);
        });

        it('should return RankedCodeGraph with correct structure', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('test')]);
          const result = await pageRanker(graph);

          expect(result).toHaveProperty('nodes');
          expect(result).toHaveProperty('edges');
          expect(result).toHaveProperty('ranks');
          expect(result.nodes).toBe(graph.nodes);
          expect(result.ranks).toBeInstanceOf(Map);
        });

        it('should work with complex graph structures', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';
    import { Logger } from './logger.js';


    export { Calculator, Logger };`
            },
            {
              path: 'src/calculator.ts',
              content: `import { Logger } from './logger.js';

    export class Calculator {
      private logger: Logger;
      
      constructor() {
        this.logger = new Logger();
      }
      
      add(a: number, b: number): number {
        return a + b;
      }
    }`
            },
            {
              path: 'src/logger.ts',
              content: `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
            }
          ];

          const graph = await analyzer(files);
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBeGreaterThan(0);
          
          // Logger should have high rank as it's imported by multiple files
          const loggerRank = result.ranks.get('src/logger.ts');
          expect(loggerRank).toBeGreaterThan(0);
        });
      });

      describe('createGitRanker()', () => {
        let gitRanker: ReturnType<typeof createGitRanker>;

        beforeEach(() => {
          gitRanker = createGitRanker();
        });

        it('should return a Ranker function', () => {
          expect(typeof gitRanker).toBe('function');
        });

        it('should handle empty graphs gracefully', async () => {
          const emptyGraph: CodeGraph = {
            nodes: new Map(),
            edges: [],
          };

          const result = await gitRanker(emptyGraph);

          expect(result.nodes).toBe(emptyGraph.nodes);
          expect(result.edges).toBe(emptyGraph.edges);
          expect(result.ranks.size).toBe(0);
        });

        it('should assign zero ranks when git is not available', async () => {
          const graph: CodeGraph = createTestGraph([
            createTestNode('file1.ts'),
            createTestNode('file1.ts#symbol1', { type: 'function' }),
          ]);

          // Change to a directory without git
          const originalCwd = process.cwd();
          process.chdir(tempDir);
          try {
            const result = await gitRanker(graph);

            expect(result.ranks.size).toBe(2);
            expect(result.ranks.get('file1.ts')).toBe(0);
            expect(result.ranks.get('file1.ts#symbol1')).toBe(0);
          } finally {
            process.chdir(originalCwd);
          }
        });

        it('should only rank file nodes with git strategy', async () => {
          await setupGitRepo(tempDir);
          await fs.writeFile(path.join(tempDir, 'file1.ts'), 'content');
          await makeGitCommit(tempDir, 'Initial commit', ['file1.ts']);

          const graph: CodeGraph = createTestGraph([
            createTestNode('file1.ts'),
            createTestNode('file1.ts#symbol1', { type: 'function' }),
          ]);

          const originalCwd = process.cwd();
          process.chdir(tempDir);
          try {
            const result = await gitRanker(graph);
            // file node should have a rank
            expect(result.ranks.get('file1.ts')).toBe(1);
            // Symbol nodes should get rank 0 with git strategy
            expect(result.ranks.get('file1.ts#symbol1')).toBe(0);
          } finally {
            process.chdir(originalCwd);
          }
        });

        it('should respect maxCommits option', () => {
          const customGitRanker = createGitRanker({ maxCommits: 100 });
          expect(typeof customGitRanker).toBe('function');
        });

        it('should normalize ranks between 0 and 1', async () => {
          try {
            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'content1');
            await fs.writeFile(path.join(tempDir, 'file2.ts'), 'content2');
            const graph: CodeGraph = createTestGraph([createTestNode('file1.ts'), createTestNode('file2.ts')]);

            await setupGitRepo(tempDir);
            await makeGitCommit(tempDir, 'Initial commit', ['file1.ts', 'file2.ts']);

            // Modify file1 more frequently
            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'modified content1');
            await makeGitCommit(tempDir, 'Update file1', ['file1.ts']);

            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'modified content1 again');
            await makeGitCommit(tempDir, 'Update file1 again', ['file1.ts']);

            const originalCwd = process.cwd();
            process.chdir(tempDir);
            try {
              const result = await gitRanker(graph);

              // All ranks should be between 0 and 1
              result.ranks.forEach(rank => {
                expect(rank).toBeGreaterThanOrEqual(0);
                expect(rank).toBeLessThanOrEqual(1);
              });

              // file1.ts should have higher rank than file2.ts
              const file1Rank = result.ranks.get('file1.ts')!;
              const file2Rank = result.ranks.get('file2.ts')!;
              expect(file1Rank).toBeGreaterThan(file2Rank);
            } finally {
              process.chdir(originalCwd);
            }
          } catch (error) {
            // Skip test if git is not available
            console.warn('Git not available, skipping git ranking test');
          }
        });
      });

      describe('Ranking Comparison', () => {
        it('should produce different rankings for PageRank vs Git strategies', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Utils } from './utils.js';
    export { Utils };`
            },
            {
              path: 'src/utils.ts',
              content: `export class Utils {
      static helper(): string {
        return 'help';
      }
    }`
            },
            {
              path: 'src/standalone.ts',
              content: `export const standalone = true;`
            }
          ];

          const graph = await analyzer(files);
          
          const pageRanker = createPageRanker();
          const gitRanker = createGitRanker();

          const pageRankResult = await pageRanker(graph);
          const gitRankResult = await gitRanker(graph);

          // Results should have same structure but potentially different ranks
          expect(pageRankResult.ranks.size).toBe(gitRankResult.ranks.size);
          
          // In PageRank, utils.ts should have high rank due to being imported
          const pageRankUtilsRank = pageRankResult.ranks.get('src/utils.ts')!;
          expect(pageRankUtilsRank).toBeGreaterThan(0);
        });

        it('should handle graphs with no edges', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('file1'), createTestNode('file2')]);

          const pageRanker = createPageRanker();
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBe(2);
          
          // All nodes should have equal rank in a graph with no edges
          const ranks = Array.from(result.ranks.values());
          expect(ranks[0]).toBeDefined();
          expect(ranks[1]).toBeDefined();
          expect(ranks[0]!).toBeCloseTo(ranks[1]!, 5);
        });
      });

      describe('Edge Cases', () => {
        it('should handle self-referential imports', async () => {
          const graph: CodeGraph = createTestGraph([createTestNode('file1')]);

          // Note: self-loops are disabled in our graph configuration
          // This tests that the ranker handles this gracefully

          const pageRanker = createPageRanker();
          const result = await pageRanker(graph);

          expect(result.ranks.size).toBe(1);
          expect(result.ranks.get('file1')).toBeGreaterThan(0);
        });

        it('should handle very large graphs efficiently', async () => {
          // Create a large graph with many nodes
          const nodeCount = 1000;
          const nodes = Array.from({ length: nodeCount }, (_, i) => createTestNode(`node${i}`));

          // Add some edges
          const edges = Array.from({ length: nodeCount - 1 }, (_, i) => ({ fromId: `node${i}`, toId: `node${i + 1}`, type: 'imports' as const }));
          const graph: CodeGraph = createTestGraph(nodes, edges);

          const pageRanker = createPageRanker();
          const startTime = Date.now();
          const result = await pageRanker(graph);
          const endTime = Date.now();

          expect(result.ranks.size).toBe(nodeCount);
          expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
        });
      });
    });
  test/unit/render.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import type { CodeNode, CodeEdge, FileContent, RankedCodeGraph,
    RendererOptions } from '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      isValidMarkdown,
      containsValidMermaid,
      extractFilePathsFromMarkdown,
      createTestNode,
      createTestGraph
    } from '../test.util.js';


    describe('Markdown Rendering', () => {
      let tempDir: string;
      let renderer: ReturnType<typeof createMarkdownRenderer>;

      beforeEach(async () => {
        tempDir = await createTempDir();
        renderer = createMarkdownRenderer();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMarkdownRenderer()', () => {
        it('should return a Renderer function', () => {
          expect(typeof renderer).toBe('function');
        });

        it('should generate valid markdown from empty graph', () => {
          const rankedGraph: RankedCodeGraph = {
            nodes: new Map(),
            edges: [],
            ranks: new Map()
          };

          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('# RepoGraph');
          expect(markdown).toContain('This repository contains 0 nodes (0 files)');
        });

        it('should include project overview section', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/index.ts', createTestNode('src/index.ts'));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## 🚀 Project Overview');
          expect(markdown).toContain('This repository contains 1 nodes (1 files)');
          expect(markdown).toContain('_Generated by RepoGraph on');
        });

        it('should include Mermaid graph by default', () => {
          const nodes = new Map<string, CodeNode>();
          const edges: CodeEdge[] = [];

          nodes.set('src/a.ts', createTestNode('src/a.ts', { name: 'a.ts' }));
          nodes.set('src/b.ts', createTestNode('src/b.ts', { name: 'b.ts' }));
          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges,
            ranks: new Map([
              ['src/a.ts', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### Module Dependency Graph');
          expect(containsValidMermaid(markdown)).toBe(true);
          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
        });

        it('should exclude Mermaid graph when option is false', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/index.ts', createTestNode('src/index.ts'));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeMermaidGraph: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('### Module Dependency Graph');
          expect(markdown).not.toContain('```mermaid');
        });

        it('should include top 10 most important files', () => {
          const nodes = new Map<string, CodeNode>();
          const ranks = new Map<string, number>();

          // Create 15 files with different ranks
          for (let i = 1; i <= 15; i++) {
            const nodeId = `src/file${i}.ts`;
            nodes.set(nodeId, createTestNode(nodeId, { name: `file${i}.ts` }));
            ranks.set(nodeId, i / 15); // Higher numbers get higher ranks
          }

          const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
          const markdown = renderer(rankedGraph);

          const topFilesSection = markdown.split('## 📂 File & Symbol Breakdown')[0]!;

          expect(topFilesSection).toContain('### Top 10 Most Important Files');
          expect(topFilesSection).toContain('| Rank | File | Description |');
          
          // Should contain the top 10 files (file15 to file6)
          expect(topFilesSection).toContain('`src/file15.ts`');
          expect(topFilesSection).toContain('`src/file6.ts`');
          
          // Should not contain the lower ranked files
          expect(topFilesSection).not.toContain('`src/file1.ts`');
          expect(topFilesSection).not.toContain('`src/file5.ts`');
        });

        it('should include symbol details by default', () => {
          const nodes = new Map<string, CodeNode>();

          nodes.set('src/test.ts', createTestNode('src/test.ts', { endLine: 20 }));
          nodes.set('src/test.ts#TestClass', createTestNode('src/test.ts#TestClass', { type: 'class', name: 'TestClass', startLine: 5, endLine: 15, codeSnippet: 'export class TestClass {' }));
          nodes.set('src/test.ts#testFunction', createTestNode('src/test.ts#testFunction', { type: 'function', name: 'testFunction', startLine: 17, endLine: 19, codeSnippet: 'export function testFunction(): void' }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#TestClass', 0.5],
              ['src/test.ts#testFunction', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## 📂 File & Symbol Breakdown');
          expect(markdown).toContain('### [`src/test.ts`](./src/test.ts)');
          expect(markdown).toContain('**`class TestClass`** - _L5_');
          expect(markdown).toContain('**`function testFunction`** - _L17_');
          expect(markdown).toContain('export class TestClass {');
          expect(markdown).toContain('export function testFunction(): void');
        });

        it('should exclude symbol details when option is false', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', createTestNode('src/test.ts'));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/test.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeSymbolDetails: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('## 📂 File & Symbol Breakdown');
        });

        describe('Renderer Customization Options', () => {
          let rankedGraph: RankedCodeGraph;

          beforeEach(() => {
            const nodes = new Map<string, CodeNode>();
            const edges: CodeEdge[] = [];

            nodes.set('src/main.ts', createTestNode('src/main.ts', { name: 'main.ts', language: 'typescript' }));
            nodes.set('src/utils.ts', createTestNode('src/utils.ts', { name: 'utils.ts', language: 'typescript' }));
            nodes.set('src/main.ts#main', createTestNode('src/main.ts#main', { type: 'function', name: 'main', startLine: 2, endLine: 5, codeSnippet: 'function main() {}' }));
            nodes.set('src/utils.ts#helper', createTestNode('src/utils.ts#helper', { type: 'function', name: 'helper', startLine: 2, endLine: 5, codeSnippet: 'function helper() {}' }));
            nodes.set('src/utils.ts#another', createTestNode('src/utils.ts#another', { type: 'function', name: 'another', startLine: 6, endLine: 8 }));
            nodes.set('src/utils.ts#onemore', createTestNode('src/utils.ts#onemore', { type: 'function', name: 'onemore', startLine: 9, endLine: 10 }));

            edges.push({ fromId: 'src/main.ts', toId: 'src/utils.ts', type: 'imports' });
            edges.push({ fromId: 'src/main.ts#main', toId: 'src/utils.ts#helper', type: 'calls' });
            edges.push({ fromId: 'src/main.ts#main', toId: 'src/utils.ts#another', type: 'calls' });
            edges.push({ fromId: 'src/main.ts#main', toId: 'src/utils.ts#onemore', type: 'calls' });

            const ranks = new Map([
              ['src/main.ts', 0.8],
              ['src/utils.ts', 0.6],
              ['src/main.ts#main', 0.5],
              ['src/utils.ts#helper', 0.4],
              ['src/utils.ts#another', 0.3],
              ['src/utils.ts#onemore', 0.2]
            ]);
            
            rankedGraph = { nodes, edges, ranks };
          });
          
          it('should exclude header when option is false', () => {
            const markdown = renderer(rankedGraph, { includeHeader: false });
            expect(markdown).not.toContain('# RepoGraph');
            expect(markdown).not.toContain('_Generated by RepoGraph on');
          });

          it('should exclude project overview when option is false', () => {
            const markdown = renderer(rankedGraph, { includeOverview: false });
            expect(markdown).not.toContain('## 🚀 Project Overview');
          });

          it('should exclude file list when option is false', () => {
            const markdown = renderer(rankedGraph, { includeFileList: false });
            expect(markdown).not.toContain('### Top 10 Most Important Files');
          });

          it('should respect topFileCount option', () => {
            const markdown = renderer(rankedGraph, { topFileCount: 1 });
            const topFilesSection = markdown.split('## 📂 File & Symbol Breakdown')[0]!;

            expect(topFilesSection).toContain('### Top 1 Most Important Files');
            expect(topFilesSection).toContain('`src/main.ts`');
            expect(topFilesSection).not.toContain('`src/utils.ts`');
          });

          it('should use custom file section separator', () => {
            const markdown = renderer(rankedGraph, { fileSectionSeparator: '***' });
            expect(markdown).toContain('\n***\n\n');
            expect(markdown).not.toContain('\n---\n\n');
          });
          
          it('should not include relations when symbolDetailOptions.includeRelations is false', () => {
            const markdown = renderer(rankedGraph, { symbolDetailOptions: { includeRelations: false } });
            expect(markdown).not.toContain('(calls');
            expect(markdown).toContain('**`function main`** - _L2_');
          });
          
          it('should not include line numbers when symbolDetailOptions.includeLineNumber is false', () => {
            const markdown = renderer(rankedGraph, { symbolDetailOptions: { includeLineNumber: false } });
            expect(markdown).not.toContain('- _L2_');
            expect(markdown).toContain('**`function main`** (calls `helper`, `another`, `onemore`)');
          });
          
          it('should not include code snippets when symbolDetailOptions.includeCodeSnippet is false', () => {
            const markdown = renderer(rankedGraph, {
              symbolDetailOptions: { includeCodeSnippet: false },
              includeMermaidGraph: false,
            });
            expect(markdown).not.toContain('```');
            expect(markdown).not.toContain('function main() {}');
            expect(markdown).toContain('**`function main`**');
          });
          
          it('should respect maxRelationsToShow option', () => {
            const markdown = renderer(rankedGraph, { symbolDetailOptions: { maxRelationsToShow: 1 } });
            expect(markdown).toContain('(calls `helper`...)');
            expect(markdown).not.toContain('`another`');
            expect(markdown).not.toContain('`onemore`');
          });

          it('should render an empty string if all sections are disabled', () => {
            const markdown = renderer(rankedGraph, {
              includeHeader: false,
              includeOverview: false,
              includeMermaidGraph: false,
              includeFileList: false,
              includeSymbolDetails: false,
            });
            expect(markdown).toBe('');
          });
        });

        it('should include custom header when provided', () => {
          const rankedGraph: RankedCodeGraph = {
            nodes: new Map(),
            edges: [],
            ranks: new Map()
          };

          const customHeader = '# My Custom Project\n\nThis is a custom description.';
          const options: RendererOptions = {
            customHeader
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).toStartWith(customHeader);
          expect(markdown).not.toContain('# RepoGraph');
        });

        it('should handle files with no symbols', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('README.md', createTestNode('README.md', { name: 'README.md', endLine: 5 }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['README.md', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`README.md`](./README.md)');
          expect(markdown).toContain('_No symbols identified in this file._');
        });

        it('should sort symbols by line number', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', createTestNode('src/test.ts', { endLine: 30 }));

          // Add symbols in non-sequential order
          nodes.set('src/test.ts#lastFunction', createTestNode('src/test.ts#lastFunction', { type: 'function', name: 'lastFunction', startLine: 25, endLine: 28 }));
          nodes.set('src/test.ts#firstFunction', createTestNode('src/test.ts#firstFunction', { type: 'function', name: 'firstFunction', startLine: 5, endLine: 10 }));
          nodes.set('src/test.ts#middleClass', createTestNode('src/test.ts#middleClass', { type: 'class', name: 'middleClass', startLine: 15, endLine: 20 }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#lastFunction', 0.3],
              ['src/test.ts#firstFunction', 0.5],
              ['src/test.ts#middleClass', 0.4]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Check that symbols appear in line number order
          const firstFunctionIndex = markdown.indexOf('firstFunction');
          const middleClassIndex = markdown.indexOf('middleClass');
          const lastFunctionIndex = markdown.indexOf('lastFunction');

          expect(firstFunctionIndex).toBeLessThan(middleClassIndex);
          expect(middleClassIndex).toBeLessThan(lastFunctionIndex);
        });

        it('should sort files by rank (highest first)', () => {
          const nodes = new Map<string, CodeNode>();
          const files = [
            { id: 'src/low.ts', rank: 0.2 },
            { id: 'src/high.ts', rank: 0.8 },
            { id: 'src/medium.ts', rank: 0.5 }
          ];

          const ranks = new Map<string, number>();

          for (const file of files) {
            nodes.set(file.id, createTestNode(file.id, { name: file.id.split('/').pop()! }));
            ranks.set(file.id, file.rank);
          }

          const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
          const markdown = renderer(rankedGraph);

          // Check order in the file breakdown section
          const highIndex = markdown.indexOf('[`src/high.ts`]');
          const mediumIndex = markdown.indexOf('[`src/medium.ts`]');
          const lowIndex = markdown.indexOf('[`src/low.ts`]');

          expect(highIndex).toBeLessThan(mediumIndex);
          expect(mediumIndex).toBeLessThan(lowIndex);
        });

        it('should handle symbols without code snippets', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', createTestNode('src/test.ts'));

          nodes.set('src/test.ts#noSnippet', createTestNode('src/test.ts#noSnippet', { type: 'function', name: 'noSnippet', startLine: 5, endLine: 8 }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#noSnippet', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function noSnippet`** - _L5_');
          // Should not include empty code block
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });

        it('should generate proper markdown links for files', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/nested/deep/file.ts', {
            id: 'src/nested/deep/file.ts', type: 'file', name: 'file.ts', filePath: 'src/nested/deep/file.ts', startLine: 1, endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/nested/deep/file.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`src/nested/deep/file.ts`](./src/nested/deep/file.ts)');
        });
      });

      describe('Mermaid Graph Generation', () => {
        it('should only include file nodes in Mermaid graph', () => {
          const nodes = new Map<string, CodeNode>();
          const edges: CodeEdge[] = [];

          nodes.set('src/a.ts', createTestNode('src/a.ts', { name: 'a.ts' }));
          nodes.set('src/a.ts#Class', createTestNode('src/a.ts#Class', { type: 'class', name: 'Class', startLine: 2, endLine: 8 }));
          nodes.set('src/b.ts', createTestNode('src/b.ts', { name: 'b.ts' }));
          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/a.ts#Class', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
          expect(markdown).not.toContain('src/a.ts#Class');
        });

        it('should handle graphs with no file-to-file edges', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/isolated.ts', createTestNode('src/isolated.ts', { name: 'isolated.ts' }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/isolated.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('```mermaid');
          expect(markdown).toContain('graph TD');
          expect(markdown).toContain('```');
        });

        it('should deduplicate edges in Mermaid graph', () => {
          const nodes = new Map<string, CodeNode>();
          const edges: CodeEdge[] = [];
          nodes.set('src/a.ts', createTestNode('src/a.ts', { name: 'a.ts' }));

          nodes.set('src/b.ts', createTestNode('src/b.ts', { name: 'b.ts' }));

          // Add multiple edges between the same files (multi-graph)
          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });
          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Should only appear once in the Mermaid graph
          const edgePattern = /src\/a\.ts\["a\.ts"\] --> src\/b\.ts\["b\.ts"\]/g;
          const matches = markdown.match(edgePattern);
          expect(matches).toHaveLength(1);
        });
      });

      describe('Integration with Real Analysis', () => {
        it('should render analyzed TypeScript code correctly', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';

    export { Calculator };


    export function main(): void {
      const calc = new Calculator();
      console.log(calc.add(1, 2));
    }`
            },
            {
              path: 'src/calculator.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
      
      subtract = (a: number, b: number): number => {
        return a - b;
      };
    }`
            }
          ];

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Calculator');
          expect(markdown).toContain('**`class Calculator`**');
          expect(markdown).toContain('**`function main`**');
          expect(markdown).toContain('**`arrow_function subtract`**');
          expect(containsValidMermaid(markdown)).toBe(true);
        });
      });

      describe('Edge Cases', () => {
        it('should handle very long file paths', () => {
          const nodes = new Map<string, CodeNode>();
          const longPath = 'src/very/deeply/nested/directory/structure/with/many/levels/file.ts';
          nodes.set(longPath, createTestNode(longPath, { name: 'file.ts' }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([[longPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`[\`${longPath}\`](./${longPath})`);
        });

        it('should handle special characters in file names', () => {
          const nodes = new Map<string, CodeNode>();
          const specialPath = 'src/file-with-dashes_and_underscores.spec.ts';
          nodes.set(specialPath, createTestNode(specialPath, { name: 'file-with-dashes_and_underscores.spec.ts' }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([[specialPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`\`${specialPath}\``);
        });

        it('should handle empty code snippets gracefully', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', createTestNode('src/test.ts'));

          nodes.set('src/test.ts#empty', createTestNode('src/test.ts#empty', { type: 'function', name: 'empty', startLine: 5, endLine: 6, codeSnippet: '' }));

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#empty', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function empty`** - _L5_');
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });
      });
    });
approved: true
