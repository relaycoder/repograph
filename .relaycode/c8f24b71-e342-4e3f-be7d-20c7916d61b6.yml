uuid: c8f24b71-e342-4e3f-be7d-20c7916d61b6
projectId: repograph
createdAt: '2025-06-29T07:17:00.261Z'
reasoning:
  - Reverting transaction abf6920f-0c4a-4e2a-bb39-95e207d57f71.
  - >-
    Reasoning from original transaction: Of course. Based on my analysis, I have
    identified several areas where the documentation is out of sync with the
    implementation. I will now perform the necessary changes to bring the
    codebase and its documentation into compliance. My strategy is to update the
    documentation to reflect the code's current, actual state. This ensures that
    `api-spec.md` and `readme.md` are accurate for developers and users. I will
    also perform minor refactors to clean up related code and remove
    inconsistencies. ### 1. Aligning Core Type Definitions First, I'll update
    `src/types.ts` to be more accurate and to simplify the `Ranker` API by
    removing an unused parameter. -   The `CodeEdge` type is missing the
    `'contains'` relationship type, which is used when linking files to the
    symbols they contain. I'll add it. -   The `RepoGraphOptions` type includes
    an `'alphabetical'` ranking strategy that is not implemented. I will remove
    it to prevent confusion. -   The `Ranker` function type includes a `files`
    parameter that is not used by any of the current ranking implementations.
    Removing it simplifies the interface. ### 2. Updating Pipeline Composer Now
    I'll update the `createMapGenerator` in `src/composer.ts` to reflect the
    simplified `Ranker` signature by removing the `files` argument from the
    `pipeline.rank` call. ### 3. Refactoring High-Level API and CLI Next, I'll
    update the high-level API and CLI entrypoint to align with the type changes.
    This involves removing the unimplemented `'alphabetical'` ranking strategy
    and improving the logic for handling invalid strategies. ### 4. Correcting
    the API Specification The `api-spec.md` is significantly out of date. I will
    update it to accurately describe the `graphology`-based data structures,
    correct function signatures, and align the available options with the
    implementation. typescript export type RepoGraphOptions = { =======
    **`RendererOptions`** ```typescript /** Configuration for the final Markdown
    output. */ export type RendererOptions = { /** Include a Mermaid.js
    dependency graph. @default true */ readonly includeMermaidGraph?: boolean;
    /** Include detailed breakdowns for each symbol. @default true */ readonly
    includeSymbolDetails?: boolean; /** Custom text to appear at the top of the
    Markdown file. */ readonly customHeader?: string; }; ```
    **`RepoGraphOptions`** ```typescript export type RepoGraphOptions = {
    >>>>>>> REPLACE <<<<<<< SEARCH /** The ranking strategy to use. @default
    'pagerank' */ rankingStrategy?: 'pagerank' | 'git-changes' | 'alphabetical';
    /** Configuration for the final Markdown output. */ rendererOptions?: {
    includeMermaidGraph?: boolean; includeSymbolDetails?: boolean;
    customHeader?: string; }; ======= /** The ranking strategy to use. @default
    'pagerank' */ rankingStrategy?: 'pagerank' | 'git-changes'; /**
    Configuration for the final Markdown output. */ rendererOptions?:
    RendererOptions; >>>>>>> REPLACE <<<<<<< SEARCH // Analyzes file content and
    builds the dependency graph. export type Analyzer = (files: readonly
    FileContent[]) => Promise<CodeGraph>; // Ranks the nodes in a graph. export
    type Ranker = (graph: CodeGraph) => RankedCodeGraph; // Renders a ranked
    graph into a string format. export type Renderer = (graph: RankedCodeGraph,
    options?: any) => string; ======= // Analyzes file content and builds the
    dependency graph. export type Analyzer = (files: readonly FileContent[]) =>
    Promise<CodeGraph>; // Ranks the nodes in a graph. export type Ranker =
    (graph: CodeGraph) => Promise<RankedCodeGraph>; // Renders a ranked graph
    into a string format. export type Renderer = (graph: RankedCodeGraph,
    options?: RendererOptions) => string; >>>>>>> REPLACE ``` ### 5. Tempering
    Claims in README Finally, I will update `readme.md` to be more transparent
    about the current state of multi-language feature support. This manages user
    expectations by clarifying which features are fully implemented versus which
    are still under development. These changes bring the core documentation and
    the code into alignment, providing a more accurate and stable foundation for
    future development. ---
operations:
  - type: write
    path: docs/readme.md
    content: >-
      # RepoGraph Multi-Language Support


      RepoGraph now supports multiple programming languages, allowing you to
      analyze diverse codebases with a single tool.


      ## Supported Languages


      RepoGraph currently supports the following programming languages:


      ### Fully Supported Languages


      - **TypeScript/JavaScript** (.ts, .tsx, .js, .jsx, .mjs, .cjs)
        - Classes, functions, interfaces, types, methods, fields
        - Arrow functions, import/export statements
        - Full TypeScript syntax support

      - **Python** (.py, .pyw)
        - Classes, functions, methods
        - Import statements (import, from...import)
        - Decorated functions and classes

      - **Java** (.java)
        - Classes, interfaces, enums
        - Methods, constructors, fields
        - Import declarations

      - **C** (.c, .h)
        - Functions, structs, unions, enums
        - Type definitions, preprocessor includes

      - **C++** (.cpp, .cc, .cxx, .hpp, .hh, .hxx)
        - Classes, structs, unions, enums
        - Functions, methods, namespaces
        - Templates, preprocessor includes

      - **Go** (.go)
        - Functions, methods, types
        - Variables, constants
        - Import declarations

      - **Rust** (.rs)
        - Functions, structs, enums, traits
        - Implementations (impl blocks)
        - Constants, static items, type definitions
        - Use declarations

      - **C#** (.cs)
        - Classes, interfaces, structs, enums
        - Methods, constructors, properties, fields
        - Namespaces, using directives

      ## How It Works


      RepoGraph automatically detects the programming language of each file
      based on its file extension and applies the appropriate Tree-sitter parser
      and query patterns. This means you can analyze polyglot repositories
      without any additional configuration.


      ### Language Detection


      When you run RepoGraph on a project, it:


      1. **Scans all files** in the specified directories

      2. **Groups files by language** based on file extensions

      3. **Loads the appropriate parser** for each language

      4. **Applies language-specific queries** to extract symbols and
      relationships

      5. **Combines results** into a unified code graph


      ### Symbol Types by Language


      Different languages support different symbol types:


      | Symbol Type | TypeScript | Python | Java | C/C++ | Go | Rust | C# |

      |-------------|------------|--------|------|-------|----|----- |----|

      | Class       | ✓          | ✓      | ✓    | ✓     |    |      | ✓  |

      | Function    | ✓          | ✓      |      | ✓     | ✓  | ✓    |    |

      | Method      | ✓          | ✓      | ✓    | ✓     | ✓  |      | ✓  |

      | Interface   | ✓          |        | ✓    |       |    | ✓    | ✓  |

      | Struct      |            |        |      | ✓     |    | ✓    | ✓  |

      | Enum        |            |        | ✓    | ✓     |    | ✓    | ✓  |

      | Namespace   |            |        |      | ✓     |    |      | ✓  |

      | Trait       |            |        |      |       |    | ✓    |    |


      ## Usage Examples


      ### Analyzing a Multi-Language Project


      ```bash

      # Analyze a polyglot repository

      repograph --root ./my-polyglot-project --output ./docs/codemap.md


      # Include specific file patterns

      repograph --include "src/**/*.{ts,py,java,rs}" --output ./docs/api.md


      # Exclude certain languages

      repograph --ignore "**/*.{c,cpp}" --output ./docs/high-level.md

      ```


      ### Programmatic Usage


      ```typescript

      import { generateMap } from 'repograph';


      await generateMap({
        root: './my-project',
        output: './docs/codemap.md',
        include: [
          'src/**/*.ts',    // TypeScript files
          'lib/**/*.py',    // Python files
          'core/**/*.rs',   // Rust files
          'api/**/*.java'   // Java files
        ]
      });

      ```


      ## Language-Specific Features


      ### Import/Export Analysis


      RepoGraph tracks dependencies between files through import statements:


      - **TypeScript/JavaScript**: `import`, `export`, `require()`

      - **Python**: `import`, `from...import`

      - **Java**: `import` declarations

      - **C/C++**: `#include` directives

      - **Go**: `import` declarations

      - **Rust**: `use` declarations

      - **C#**: `using` directives


      ### Symbol Relationships


      The tool understands language-specific relationships:


      - **Inheritance**: Classes extending other classes

      - **Implementation**: Classes implementing interfaces

      - **Composition**: Classes containing other types

      - **Module dependencies**: File-to-file relationships


      ## Adding New Languages


      RepoGraph is designed to be extensible. To add support for a new language:


      1. **Install the Tree-sitter parser** for the language

      2. **Add language configuration** in `src/tree-sitter/language-config.ts`

      3. **Define Tree-sitter queries** to extract symbols

      4. **Update type definitions** if needed


      See the existing language configurations for examples.


      ## Limitations


      - **Binary files** are automatically excluded

      - **Generated code** should be excluded via `.gitignore` or ignore
      patterns

      - **Language-specific features** may vary in completeness

      - **Cross-language relationships** are limited to file-level imports


      ## Future Enhancements


      Planned improvements include:


      - **More languages**: PHP, Ruby, Swift, Kotlin, etc.

      - **Better cross-language analysis**: Understanding FFI and interop

      - **Language-specific metrics**: Complexity analysis per language

      - **Custom symbol extraction**: User-defined queries for domain-specific
      languages
    patchStrategy: replace
  - type: write
    path: docs/api-spec.md
    content: >
      # RepoGraph: Technical API Specification


      ## 1. Vision & Core Philosophy


      **RepoGraph** is a functional, immutable, and composable TypeScript
      library for generating rich, semantic codemaps in Markdown. Designed for
      the Bun.sh ecosystem, it provides a powerful, declarative API for
      analyzing and visualizing code repositories.


      Our philosophy is rooted in functional programming:


      *   **Immutability:** All data structures are immutable. Functions never
      modify their inputs; they return new, transformed data, eliminating side
      effects.

      *   **Composition:** The entire process, from file discovery to rendering,
      is a pipeline of pure functions. Users can assemble their own pipelines by
      providing custom functions for any stage.

      *   **Declarative API:** Users describe *what* they want the codemap to
      look like through configuration and function composition, rather than
      detailing *how* to build it step-by-step.


      The result is a highly predictable and extensible library perfect for
      documentation generation, codebase exploration, and providing context to
      AI assistants.


      ## 2. Core Data Structures (Immutable Types)


      These are the plain data types that flow through the functional pipeline.


      ```typescript

      // Represents a single file read from disk.

      export type FileContent = {
        readonly path: string;
        readonly content: string;
      };


      // Represents a single, identifiable symbol in the code.

      export type CodeNode = {
        readonly id: string; // Unique identifier (e.g., 'src/api.ts#MyClass')
        readonly type: 'file' | 'class' | 'function' | 'interface' | 'import' | 'variable';
        readonly name: string; // e.g., 'MyClass'
        readonly filePath: string;
        readonly startLine: number;
        readonly endLine: number;
        readonly codeSnippet?: string; // e.g., function signature
      };


      // Represents a directed relationship between two CodeNodes.

      export type CodeEdge = {
        readonly fromId: string; // ID of the source CodeNode
        readonly toId: string;   // ID of the target CodeNode
        readonly type: 'imports' | 'calls' | 'inherits' | 'implements';
      };


      // The complete, raw model of the repository's structure.

      export type CodeGraph = {
        readonly nodes: ReadonlyMap<string, CodeNode>;
        readonly edges: readonly CodeEdge[];
      };


      // A CodeGraph with an added 'rank' score for each node.

      export type RankedCodeGraph = CodeGraph & {
        readonly ranks: ReadonlyMap<string, number>; // Key is CodeNode ID
      };

      ```


      ## 3. The Functional Pipeline


      RepoGraph operates as a data transformation pipeline. Each step is a pure
      function that takes data and returns a new, transformed version.


      **`FileContent[]` → `CodeGraph` → `RankedCodeGraph` → `string
      (Markdown)`**


      1.  **Discover:** A `FileDiscoverer` function scans the file system and
      produces an array of `FileContent` objects.

      2.  **Analyze:** An `Analyzer` function takes the `FileContent[]` and
      produces a `CodeGraph` by parsing the code and identifying nodes and
      edges.

      3.  **Rank:** A `Ranker` function takes the `CodeGraph` and produces a
      `RankedCodeGraph` by applying a scoring algorithm (e.g., PageRank).

      4.  **Render:** A `Renderer` function takes the `RankedCodeGraph` and
      produces the final Markdown string.


      ## 4. API Reference


      ### 4.1. Main Function (`generateMap`)


      The primary, easy-to-use entry point. It orchestrates the default pipeline
      based on a configuration object.


      ```typescript

      async function generateMap(options: RepoGraphOptions): Promise<void>;

      ```


      **`RepoGraphOptions`**


      ```typescript

      export type RepoGraphOptions = {
        /** Root directory to analyze. @default process.cwd() */
        root: string;

        /** Output path for the Markdown file. @default './repograph.md' */
        output: string;

        /** Glob patterns for files to include. */
        include?: readonly string[];

        /** Glob patterns for files to exclude. */
        ignore?: readonly string[];

        /** Disables the use of .gitignore. @default false */
        noGitignore?: boolean;

        /** The ranking strategy to use. @default 'pagerank' */
        rankingStrategy?: 'pagerank' | 'git-changes' | 'alphabetical';

        /** Configuration for the final Markdown output. */
        rendererOptions?: {
          includeMermaidGraph?: boolean;
          includeSymbolDetails?: boolean;
          customHeader?: string;
        };
      };

      ```


      ### 4.2. Core Function Types (The Contracts for Composition)


      These types define the signatures for the functions that make up the
      pipeline.


      ```typescript

      // Discovers files and returns their content.

      export type FileDiscoverer = (config: {
        root: string;
        include?: readonly string[];
        ignore?: readonly string[];
        noGitignore?: boolean;
      }) => Promise<readonly FileContent[]>;


      // Analyzes file content and builds the dependency graph.

      export type Analyzer = (files: readonly FileContent[]) =>
      Promise<CodeGraph>;


      // Ranks the nodes in a graph.

      export type Ranker = (graph: CodeGraph) => RankedCodeGraph;


      // Renders a ranked graph into a string format.

      export type Renderer = (graph: RankedCodeGraph, options?: any) => string;

      ```


      ### 4.3. Default Implementations (Function Factories)


      RepoGraph provides default, configurable functions for each stage of the
      pipeline.


      ```typescript

      // Creates the default file discoverer.

      function createDefaultDiscoverer(): FileDiscoverer;


      // Creates the default Tree-sitter-based analyzer.

      function createTreeSitterAnalyzer(): Analyzer;


      // Creates a ranker using the PageRank algorithm.

      function createPageRanker(): Ranker;


      // Creates a ranker based on Git commit history. Requires Git.

      function createGitRanker(options: { maxCommits?: number }): Ranker;


      // Creates the default Markdown renderer.

      function createMarkdownRenderer(options: {
        includeMermaidGraph?: boolean;
        includeSymbolDetails?: boolean;
        customHeader?: string;
      }): Renderer;

      ```


      ### 4.4. The Composer (Higher-Order Function)


      For ultimate control, `createMapGenerator` is a Higher-Order Function that
      takes pipeline functions as arguments and returns a fully configured
      `generate` function.


      ```typescript

      function createMapGenerator(pipeline: {
        discover: FileDiscoverer;
        analyze: Analyzer;
        rank: Ranker;
        render: Renderer;
      }): (config: { root: string; output: string; /* discoverer options */ })
      => Promise<void>;

      ```


      ## 5. Example Usage


      ### Simple Case (Using `generateMap`)


      ```typescript

      import { generateMap } from 'repograph';


      await generateMap({
        root: './my-project',
        output: './my-project/README.repograph.md',
        rankingStrategy: 'pagerank',
        rendererOptions: {
          customHeader: '# My Project Architecture',
        },
      });

      ```


      ### Advanced Case (Using Composition and HOFs)


      Here, we build a custom pipeline that uses a hypothetical "cyclomatic
      complexity" ranker instead of the default.


      ```typescript

      import {
        createMapGenerator,
        createDefaultDiscoverer,
        createTreeSitterAnalyzer,
        createMarkdownRenderer,
      } from 'repograph';

      import type { CodeGraph, RankedCodeGraph, Ranker } from 'repograph';


      // 1. Define our custom ranking function

      const myComplexityRanker: Ranker = (graph: CodeGraph): RankedCodeGraph =>
      {
        console.log('Using custom complexity ranker!');
        const ranks = new Map<string, number>();
        // ... custom logic to calculate complexity and assign rank ...
        for (const [id] of graph.nodes) {
          ranks.set(id, Math.random() * 100); // Placeholder
        }
        return { ...graph, ranks };
      };


      // 2. Create a map generator by composing our pipeline

      const generateCustomMap = createMapGenerator({
        discover: createDefaultDiscoverer(),
        analyze: createTreeSitterAnalyzer(),
        rank: myComplexityRanker, // <-- Inject our custom function
        render: createMarkdownRenderer({ includeMermaidGraph: false }),
      });


      // 3. Run the composed generator

      await generateCustomMap({
        root: './my-project',
        output: './docs/complexity-map.md',
        include: ['src/core/**/*'],
      });

      ```


      ## 6. Example Markdown Output


      The generated Markdown output remains rich and navigable, as specified
      previously, with dependency graphs, summary tables, and detailed symbol
      breakdowns.


      ````markdown

      # RepoGraph for `my-project`


      _Generated by RepoGraph on 2023-10-27_


      ## 🚀 Project Overview


      This repository contains 42 source files. The analysis highlights the most
      central and interconnected modules that form the backbone of the
      application.


      ### Module Dependency Graph


      ```mermaid

      graph TD
          A[src/index.ts] --> B(src/server.ts)
          B --> C{src/core/router.ts}
          B --> D[src/core/database.ts]
          C --> E[src/handlers/user.ts]
          E --> D
      ```


      ### Top 10 Most Important Files (Ranked by PageRank)


      | Rank | File | Key Symbols | Description |

      | :--- | :--- | :--- | :--- |

      | 1 | `src/core/database.ts` | `connectDB`, `query` | Central database
      connection and query module. Used by most handlers. |

      | 2 | `src/server.ts` | `createServer`, `app` | Main Express server setup
      and middleware configuration. |

      | ... | ... | ... | ... |


      ---


      ## 📂 File & Symbol Breakdown


      ### [`src/core/database.ts`](./src/core/database.ts)


      Central database connection and query module. Used by most handlers.


      -   **`function connectDB()`** - _L12_
          Establishes the main connection to the PostgreSQL database.
          ```typescript
          export async function connectDB(): Promise<void>
          ```

      ---
    patchStrategy: replace
  - type: write
    path: src/index.ts
    content: >-
      #!/usr/bin/env bun


      // High-Level API for simple use cases

      import { generateMap as executeGenerateMap } from './high-level.js';

      import type { RepoGraphOptions as IRepoGraphOptions } from './types.js';


      export { generateMap } from './high-level.js';


      // Low-Level API for composition and advanced use cases

      export { createMapGenerator } from './composer.js';


      // Default pipeline component factories

      export { createDefaultDiscoverer } from './pipeline/discover.js';

      export { createTreeSitterAnalyzer } from './pipeline/analyze.js';

      export { createPageRanker, createGitRanker } from './pipeline/rank.js';

      export { createMarkdownRenderer } from './pipeline/render.js';


      // Core types for building custom components

      export type {
        FileContent,
        CodeNode,
        CodeNodeType,
        CodeEdge,
        CodeGraph,
        RankedCodeGraph,
        RepoGraphOptions,
        RendererOptions,
        FileDiscoverer,
        Analyzer,
        Ranker,
        Renderer,
      } from './types.js';


      // This section runs only when the script is executed directly from the
      CLI

      import { fileURLToPath } from 'node:url';

      import path from 'node:path';


      const isRunningDirectly = () => {
        if (typeof process.argv[1] === 'undefined') return false;
        const runningFile = path.resolve(process.argv[1]);
        const currentFile = fileURLToPath(import.meta.url);
        return runningFile === currentFile;
      };


      if (isRunningDirectly()) {
        const args = process.argv.slice(2);

        if (args.includes('--help') || args.includes('-h')) {
          console.log(`
      Usage: repograph [root] [options]


      Arguments:
        root                     The root directory of the repository to analyze. Defaults to the current working directory.

      Options:
        -h, --help               Display this help message.
        -v, --version            Display the version number.
        --output <path>          Path to the output Markdown file. (default: "repograph.md")
        --include <pattern>      Glob pattern for files to include. Can be specified multiple times.
        --ignore <pattern>       Glob pattern for files to ignore. Can be specified multiple times.
        --no-gitignore           Do not respect .gitignore files.
        --ranking-strategy <name> The ranking strategy to use. (default: "pagerank", options: "pagerank", "git-changes")
          `);
          process.exit(0);
        }

        if (args.includes('--version') || args.includes('-v')) {
          // In a real app, you'd get this from package.json
          console.log('0.1.0');
          process.exit(0);
        }

        // We need a mutable version of the options to build it from arguments.
        const options: {
          root?: string;
          output?: string;
          include?: readonly string[];
          ignore?: readonly string[];
          noGitignore?: boolean;
          rankingStrategy?: 'pagerank' | 'git-changes' | 'alphabetical';
          rendererOptions?: IRepoGraphOptions['rendererOptions'];
        } = {};
        const includePatterns: string[] = [];
        const ignorePatterns: string[] = [];

        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (!arg) {
            continue;
          }
          switch (arg) {
            case '--output':
              options.output = args[++i];
              break;
            case '--include':
              includePatterns.push(args[++i] as string);
              break;
            case '--ignore':
              ignorePatterns.push(args[++i] as string);
              break;
            case '--no-gitignore':
              options.noGitignore = true;
              break;
            case '--ranking-strategy':
              options.rankingStrategy = args[++i] as IRepoGraphOptions['rankingStrategy'];
              break;
            default:
              if (!arg.startsWith('-')) {
                options.root = arg;
              }
              break;
          }
        }

        if (includePatterns.length > 0) {
          options.include = includePatterns;
        }
        if (ignorePatterns.length > 0) {
          options.ignore = ignorePatterns;
        }

        executeGenerateMap(options)
          .then(() => {
            console.log(`✅ RepoGraph map generated successfully at ${path.resolve(options.root || process.cwd(), options.output || 'repograph.md')}`);
          })
          .catch((error: unknown) => {
            if (error instanceof Error) {
              console.error(`❌ Error generating RepoGraph map: ${error.message}`);
            } else {
              console.error('❌ An unknown error occurred while generating the RepoGraph map.');
            }
            process.exit(1);
          });
      }
    patchStrategy: replace
  - type: write
    path: src/high-level.ts
    content: >-
      import { createMapGenerator } from './composer.js';

      import { createDefaultDiscoverer } from './pipeline/discover.js';

      import { createTreeSitterAnalyzer } from './pipeline/analyze.js';

      import { createPageRanker, createGitRanker } from './pipeline/rank.js';

      import { createMarkdownRenderer } from './pipeline/render.js';

      import type { RepoGraphOptions, Ranker } from './types.js';

      import path from 'node:path';


      /**
       * The primary, easy-to-use entry point for RepoGraph. It orchestrates the
       * default pipeline based on a configuration object to generate a codemap.
       *
       * @param options The configuration object for generating the map.
       */
      export const generateMap = async (options: RepoGraphOptions = {}):
      Promise<void> => {
        const {
          root = process.cwd(),
          output = './repograph.md',
          rankingStrategy = 'pagerank',
        } = options;

        let ranker: Ranker;
        switch (rankingStrategy) {
          case 'git-changes':
            ranker = createGitRanker();
            break;
          case 'alphabetical':
            // This is a valid option in types, but not implemented.
            throw new Error("The 'alphabetical' ranking strategy is not yet implemented.");
          case 'pagerank':
          default:
            if (rankingStrategy !== 'pagerank') {
              throw new Error(`Invalid ranking strategy: '${rankingStrategy}'. Available options are 'pagerank', 'git-changes'.`);
            }
            ranker = createPageRanker();
            break;
        }

        const generator = createMapGenerator({
          discover: createDefaultDiscoverer(),
          analyze: createTreeSitterAnalyzer(),
          rank: ranker,
          render: createMarkdownRenderer(),
        });

        await generator({
          root: path.resolve(root),
          output: output,
          include: options.include,
          ignore: options.ignore,
          noGitignore: options.noGitignore,
          rendererOptions: options.rendererOptions,
        });
      };
    patchStrategy: replace
  - type: write
    path: src/composer.ts
    content: >-
      import fs from 'node:fs/promises';

      import path from 'node:path';

      import type { Analyzer, FileDiscoverer, Ranker, Renderer } from
      './types.js';


      type MapGenerator = (config: {
        readonly root: string;
        readonly output: string;
        readonly include?: readonly string[];
        readonly ignore?: readonly string[];
        readonly noGitignore?: boolean;
        readonly rendererOptions?: any;
      }) => Promise<void>;


      /**
       * A Higher-Order Function that takes pipeline functions as arguments and
       * returns a fully configured `generate` function for creating a codemap.
       * This is the core of RepoGraph's composability.
       *
       * @param pipeline An object containing implementations for each pipeline stage.
       * @returns An asynchronous function to generate and write the codemap.
       */
      export const createMapGenerator = (pipeline: {
        readonly discover: FileDiscoverer;
        readonly analyze: Analyzer;
        readonly rank: Ranker;
        readonly render: Renderer;
      }): MapGenerator => {
        if (
          !pipeline ||
          typeof pipeline.discover !== 'function' ||
          typeof pipeline.analyze !== 'function' ||
          typeof pipeline.rank !== 'function' ||
          typeof pipeline.render !== 'function'
        ) {
          throw new Error('createMapGenerator: A valid pipeline object with discover, analyze, rank, and render functions must be provided.');
        }

        return async (config) => {
          const { root, output, include, ignore, noGitignore, rendererOptions } = config;

          // 1. Discover
          const files = await pipeline.discover({ root, include, ignore, noGitignore });

          // 2. Analyze
          const graph = await pipeline.analyze(files);

          // 3. Rank
          const rankedGraph = await pipeline.rank(graph, files);

          // 4. Render
          const markdown = pipeline.render(rankedGraph, rendererOptions);

          // 5. Write to disk
          const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);
          await fs.mkdir(path.dirname(outputPath), { recursive: true });
          await fs.writeFile(outputPath, markdown);
        };
      };
    patchStrategy: replace
  - type: write
    path: src/types.ts
    content: >-
      import type Graph from 'graphology';


      // Core Data Structures


      /** Represents a single file read from disk. Immutable. */

      export type FileContent = {
        readonly path: string;
        readonly content: string;
      };


      /** The type of a symbol identified in the code. */

      export type CodeNodeType =
        | 'file'
        | 'class'
        | 'function'
        | 'interface'
        | 'import'
        | 'variable'
        | 'type'
        | 'arrow_function'
        | 'method'
        | 'field'
        | 'struct'
        | 'enum'
        | 'namespace'
        | 'trait'
        | 'impl'
        | 'constructor'
        | 'property'
        | 'constant'
        | 'static'
        | 'union'
        | 'template';

      /** Represents a single, identifiable symbol (or a file) in the code.
      Immutable. */

      export type CodeNode = {
        readonly id: string; // Unique identifier (e.g., 'src/api.ts#MyClass')
        readonly type: CodeNodeType;
        readonly name: string; // e.g., 'MyClass'
        readonly filePath: string;
        readonly startLine: number;
        readonly endLine: number;
        readonly codeSnippet?: string; // e.g., function signature
      };


      /** Represents a directed relationship between two CodeNodes. Immutable.
      */

      export type CodeEdge = {
        readonly fromId: string; // ID of the source CodeNode
        readonly toId: string;   // ID of the target CodeNode
        readonly type: 'imports' | 'calls' | 'inherits' | 'implements';
      };


      /** The complete, raw model of the repository's structure using
      graphology. Immutable. */

      export type CodeGraph = Readonly<Graph<CodeNode>>;


      /** A CodeGraph with an added 'rank' score for each node. Immutable. */

      export type RankedCodeGraph = {
        readonly graph: CodeGraph;
        readonly ranks: ReadonlyMap<string, number>; // Key is CodeNode ID
      };


      // High-Level API Options


      /** Configuration for the final Markdown output. */

      export type RendererOptions = {
        /** Include a Mermaid.js dependency graph. @default true */
        readonly includeMermaidGraph?: boolean;
        /** Include detailed breakdowns for each symbol. @default true */
        readonly includeSymbolDetails?: boolean;
        /** Custom text to appear at the top of the Markdown file. */
        readonly customHeader?: string;
      };


      /** Configuration options for the main `generateMap` function. */

      export type RepoGraphOptions = {
        /** Root directory to analyze. @default process.cwd() */
        readonly root?: string;
        /** Output path for the Markdown file. @default './repograph.md' */
        readonly output?: string;
        /** Glob patterns for files to include. */
        readonly include?: readonly string[];
        /** Glob patterns for files to exclude. */
        readonly ignore?: readonly string[];
        /** Disables the use of .gitignore. @default false */
        readonly noGitignore?: boolean;
        /** The ranking strategy to use. @default 'pagerank' */
        readonly rankingStrategy?: 'pagerank' | 'git-changes' | 'alphabetical';
        /** Configuration for the final Markdown output. */
        readonly rendererOptions?: RendererOptions;
      };


      // Low-Level Functional Pipeline Contracts


      /** Discovers files and returns their content. */

      export type FileDiscoverer = (config: {
        readonly root: string;
        readonly include?: readonly string[];
        readonly ignore?: readonly string[];
        readonly noGitignore?: boolean;
      }) => Promise<readonly FileContent[]>;


      /** Analyzes file content and builds the dependency graph. */

      export type Analyzer = (files: readonly FileContent[]) =>
      Promise<CodeGraph>;


      /** Ranks the nodes in a graph. */

      export type Ranker = (graph: CodeGraph, files: readonly FileContent[]) =>
      Promise<RankedCodeGraph>;


      /** Renders a ranked graph into a string format. */

      export type Renderer = (rankedGraph: RankedCodeGraph, options?:
      RendererOptions) => string;
    patchStrategy: replace
snapshot:
  docs/readme.md: >-
    # RepoGraph Multi-Language Support


    RepoGraph now supports multiple programming languages, allowing you to
    analyze diverse codebases with a single tool.


    ## Supported Languages


    RepoGraph currently supports the following programming languages:


    ### Fully Supported Languages


    - **TypeScript/JavaScript** (.ts, .tsx, .js, .jsx, .mjs, .cjs)
      - Classes, functions, interfaces, types, methods, fields
      - Arrow functions, import/export statements
      - Full TypeScript syntax support

    - **Python** (.py, .pyw)
      - Classes, functions, methods
      - Import statements (import, from...import)
      - Decorated functions and classes

    - **Java** (.java)
      - Classes, interfaces, enums
      - Methods, constructors, fields
      - Import declarations

    - **C** (.c, .h)
      - Functions, structs, unions, enums
      - Type definitions, preprocessor includes

    - **C++** (.cpp, .cc, .cxx, .hpp, .hh, .hxx)
      - Classes, structs, unions, enums
      - Functions, methods, namespaces
      - Templates, preprocessor includes

    - **Go** (.go)
      - Functions, methods, types
      - Variables, constants
      - Import declarations

    - **Rust** (.rs)
      - Functions, structs, enums, traits
      - Implementations (impl blocks)
      - Constants, static items, type definitions
      - Use declarations

    - **C#** (.cs)
      - Classes, interfaces, structs, enums
      - Methods, constructors, properties, fields
      - Namespaces, using directives

    ## How It Works


    RepoGraph automatically detects the programming language of each file based
    on its file extension and applies the appropriate Tree-sitter parser and
    query patterns. This means you can analyze polyglot repositories without any
    additional configuration.


    ### Language Detection


    When you run RepoGraph on a project, it:


    1. **Scans all files** in the specified directories

    2. **Groups files by language** based on file extensions

    3. **Loads the appropriate parser** for each language

    4. **Applies language-specific queries** to extract symbols and
    relationships

    5. **Combines results** into a unified code graph


    ### Symbol Types by Language


    Different languages support different symbol types:


    | Symbol Type | TypeScript | Python | Java | C/C++ | Go | Rust | C# |

    |-------------|------------|--------|------|-------|----|----- |----|

    | Class       | ✓          | ✓      | ✓    | ✓     |    |      | ✓  |

    | Function    | ✓          | ✓      |      | ✓     | ✓  | ✓    |    |

    | Method      | ✓          | ✓      | ✓    | ✓     | ✓  |      | ✓  |

    | Interface   | ✓          |        | ✓    |       |    | ✓    | ✓  |

    | Struct      |            |        |      | ✓     |    | ✓    | ✓  |

    | Enum        |            |        | ✓    | ✓     |    | ✓    | ✓  |

    | Namespace   |            |        |      | ✓     |    |      | ✓  |

    | Trait       |            |        |      |       |    | ✓    |    |


    ## Usage Examples


    ### Analyzing a Multi-Language Project


    ```bash

    # Analyze a polyglot repository

    repograph --root ./my-polyglot-project --output ./docs/codemap.md


    # Include specific file patterns

    repograph --include "src/**/*.{ts,py,java,rs}" --output ./docs/api.md


    # Exclude certain languages

    repograph --ignore "**/*.{c,cpp}" --output ./docs/high-level.md

    ```


    ### Programmatic Usage


    ```typescript

    import { generateMap } from 'repograph';


    await generateMap({
      root: './my-project',
      output: './docs/codemap.md',
      include: [
        'src/**/*.ts',    // TypeScript files
        'lib/**/*.py',    // Python files
        'core/**/*.rs',   // Rust files
        'api/**/*.java'   // Java files
      ]
    });

    ```


    ## Language-Specific Features


    ### Import/Export Analysis


    RepoGraph analyzes dependencies between files. This analysis is most
    complete for TypeScript/JavaScript, which supports full `import`/`export`
    statement resolution. For other languages, import analysis is currently
    under development.


    The goal is to track dependencies for:

    - **Python**: `import`, `from...import`

    - **Java**: `import` declarations

    - **C/C++**: `#include` directives

    - **Go**: `import` declarations

    - **Rust**: `use` declarations

    - **C#**: `using` directives


    ### Symbol Relationships


    The tool currently models two main types of relationships:

    - **Module dependencies** (`imports`): A file-to-file relationship
    indicating that one file imports or includes another.

    - **Symbol containment** (`contains`): A file-to-symbol relationship
    indicating that a file defines a specific symbol (like a class or function).


    Future versions aim to understand deeper language-specific relationships,
    such as:

    - **Inheritance**: Classes extending other classes

    - **Implementation**: Classes implementing interfaces

    - **Composition**: Classes containing other types


    ## Adding New Languages


    RepoGraph is designed to be extensible. To add support for a new language:


    1. **Install the Tree-sitter parser** for the language

    2. **Add language configuration** in `src/tree-sitter/language-config.ts`

    3. **Define Tree-sitter queries** to extract symbols

    4. **Update type definitions** if needed


    See the existing language configurations for examples.


    ## Limitations


    - **Binary files** are automatically excluded

    - **Generated code** should be excluded via `.gitignore` or ignore patterns

    - **Language-specific features** may vary in completeness

    - **Cross-language relationships** are limited to file-level imports


    ## Future Enhancements


    Planned improvements include:


    - **More languages**: PHP, Ruby, Swift, Kotlin, etc.

    - **Better cross-language analysis**: Understanding FFI and interop

    - **Language-specific metrics**: Complexity analysis per language

    - **Custom symbol extraction**: User-defined queries for domain-specific
    languages
  docs/api-spec.md: >
    # RepoGraph: Technical API Specification


    ## 1. Vision & Core Philosophy


    **RepoGraph** is a functional, immutable, and composable TypeScript library
    for generating rich, semantic codemaps in Markdown. Designed for the Bun.sh
    ecosystem, it provides a powerful, declarative API for analyzing and
    visualizing code repositories.


    Our philosophy is rooted in functional programming:


    *   **Immutability:** All data structures are immutable. Functions never
    modify their inputs; they return new, transformed data, eliminating side
    effects.

    *   **Composition:** The entire process, from file discovery to rendering,
    is a pipeline of pure functions. Users can assemble their own pipelines by
    providing custom functions for any stage.

    *   **Declarative API:** Users describe *what* they want the codemap to look
    like through configuration and function composition, rather than detailing
    *how* to build it step-by-step.


    The result is a highly predictable and extensible library perfect for
    documentation generation, codebase exploration, and providing context to AI
    assistants.


    ## 2. Core Data Structures (Immutable Types)


    These are the plain data types that flow through the functional pipeline.


    ```typescript

    // Represents a single file read from disk.

    export type FileContent = {
      readonly path: string;
      readonly content: string;
    };


    // Represents a single, identifiable symbol in the code.

    export type CodeNode = {
      readonly id: string; // Unique identifier (e.g., 'src/api.ts#MyClass')
      readonly name: string; // e.g., 'MyClass'
      readonly filePath: string;
      readonly startLine: number;
      readonly endLine: number;
      readonly codeSnippet?: string; // e.g., function signature
      readonly type: CodeNodeType;
    };


    // The type of a symbol identified in the code.

    export type CodeNodeType =
      | 'file' | 'class' | 'function' | 'interface' | 'import' | 'variable'
      | 'type' | 'arrow_function' | 'method' | 'field' | 'struct' | 'enum'
      | 'namespace' | 'trait' | 'impl' | 'constructor' | 'property'
      | 'constant' | 'static' | 'union' | 'template';

    // Represents a directed relationship between two CodeNodes.

    // Note: In the graphology instance, this is part of the edge's attributes.

    export type CodeEdge = {
      readonly fromId: string; // ID of the source CodeNode
      readonly toId: string;   // ID of the target CodeNode
      readonly type: 'imports' | 'contains' | 'calls' | 'inherits' | 'implements';
    };


    // The complete, raw model of the repository's structure.

    // It is an immutable instance of a graphology Graph object.

    export type CodeGraph = Readonly<import('graphology').default<CodeNode>>;


    // A CodeGraph with an added 'rank' score for each node.

    export type RankedCodeGraph = {
      readonly graph: CodeGraph;
      readonly ranks: ReadonlyMap<string, number>; // Key is CodeNode ID
    };

    ```


    ## 3. The Functional Pipeline


    RepoGraph operates as a data transformation pipeline. Each step is a pure
    function that takes data and returns a new, transformed version.


    **`FileContent[]` → `CodeGraph` → `RankedCodeGraph` → `string (Markdown)`**


    1.  **Discover:** A `FileDiscoverer` function scans the file system and
    produces an array of `FileContent` objects.

    2.  **Analyze:** An `Analyzer` function takes the `FileContent[]` and
    produces a `CodeGraph` by parsing the code and identifying nodes and edges.

    3.  **Rank:** A `Ranker` function takes the `CodeGraph` and produces a
    `RankedCodeGraph` by applying a scoring algorithm (e.g., PageRank).

    4.  **Render:** A `Renderer` function takes the `RankedCodeGraph` and
    produces the final Markdown string.


    ## 4. API Reference


    ### 4.1. Main Function (`generateMap`)


    The primary, easy-to-use entry point. It orchestrates the default pipeline
    based on a configuration object.


    ```typescript

    async function generateMap(options: RepoGraphOptions): Promise<void>;

    ```


    **`RepoGraphOptions`**


    ```typescript

    export type RepoGraphOptions = {
      /** Root directory to analyze. @default process.cwd() */
      root: string;

      /** Output path for the Markdown file. @default './repograph.md' */
      output: string;

      /** Glob patterns for files to include. */
      include?: readonly string[];

      /** Glob patterns for files to exclude. */
      ignore?: readonly string[];

      /** Disables the use of .gitignore. @default false */
      noGitignore?: boolean;

      /** The ranking strategy to use. @default 'pagerank' */
      rankingStrategy?: 'pagerank' | 'git-changes' | 'alphabetical';

      /** Configuration for the final Markdown output. */
      rendererOptions?: {
        includeMermaidGraph?: boolean;
        includeSymbolDetails?: boolean;
        customHeader?: string;
      };
    };

    ```


    ### 4.2. Core Function Types (The Contracts for Composition)


    These types define the signatures for the functions that make up the
    pipeline.


    ```typescript

    // Discovers files and returns their content.

    export type FileDiscoverer = (config: {
      root: string;
      include?: readonly string[];
      ignore?: readonly string[];
      noGitignore?: boolean;
    }) => Promise<readonly FileContent[]>;


    // Analyzes file content and builds the dependency graph.

    export type Analyzer = (files: readonly FileContent[]) =>
    Promise<CodeGraph>;


    // Ranks the nodes in a graph.

    export type Ranker = (graph: CodeGraph) => RankedCodeGraph;


    // Renders a ranked graph into a string format.

    export type Renderer = (graph: RankedCodeGraph, options?: any) => string;

    ```


    ### 4.3. Default Implementations (Function Factories)


    RepoGraph provides default, configurable functions for each stage of the
    pipeline.


    ```typescript

    // Creates the default file discoverer.

    function createDefaultDiscoverer(): FileDiscoverer;


    // Creates the default Tree-sitter-based analyzer.

    function createTreeSitterAnalyzer(): Analyzer;


    // Creates a ranker using the PageRank algorithm.

    function createPageRanker(): Ranker;


    // Creates a ranker based on Git commit history. Requires Git.

    function createGitRanker(options: { maxCommits?: number }): Ranker;


    // Creates the default Markdown renderer.

    function createMarkdownRenderer(options: {
      includeMermaidGraph?: boolean;
      includeSymbolDetails?: boolean;
      customHeader?: string;
    }): Renderer;

    ```


    ### 4.4. The Composer (Higher-Order Function)


    For ultimate control, `createMapGenerator` is a Higher-Order Function that
    takes pipeline functions as arguments and returns a fully configured
    `generate` function.


    ```typescript

    function createMapGenerator(pipeline: {
      discover: FileDiscoverer;
      analyze: Analyzer;
      rank: Ranker;
      render: Renderer;
    }): (config: { root: string; output: string; /* discoverer options */ }) =>
    Promise<void>;

    ```


    ## 5. Example Usage


    ### Simple Case (Using `generateMap`)


    ```typescript

    import { generateMap } from 'repograph';


    await generateMap({
      root: './my-project',
      output: './my-project/README.repograph.md',
      rankingStrategy: 'pagerank',
      rendererOptions: {
        customHeader: '# My Project Architecture',
      },
    });

    ```


    ### Advanced Case (Using Composition and HOFs)


    Here, we build a custom pipeline that uses a hypothetical "cyclomatic
    complexity" ranker instead of the default.


    ```typescript

    import {
      createMapGenerator,
      createDefaultDiscoverer,
      createTreeSitterAnalyzer,
      createMarkdownRenderer,
    } from 'repograph';

    import type { CodeGraph, RankedCodeGraph, Ranker } from 'repograph';


    // 1. Define our custom ranking function

    const myComplexityRanker: Ranker = (graph: CodeGraph): RankedCodeGraph => {
      console.log('Using custom complexity ranker!');
      const ranks = new Map<string, number>();
      // ... custom logic to calculate complexity and assign rank ...
      for (const [id] of graph.nodes) {
        ranks.set(id, Math.random() * 100); // Placeholder
      }
      return { ...graph, ranks };
    };


    // 2. Create a map generator by composing our pipeline

    const generateCustomMap = createMapGenerator({
      discover: createDefaultDiscoverer(),
      analyze: createTreeSitterAnalyzer(),
      rank: myComplexityRanker, // <-- Inject our custom function
      render: createMarkdownRenderer({ includeMermaidGraph: false }),
    });


    // 3. Run the composed generator

    await generateCustomMap({
      root: './my-project',
      output: './docs/complexity-map.md',
      include: ['src/core/**/*'],
    });

    ```


    ## 6. Example Markdown Output


    The generated Markdown output remains rich and navigable, as specified
    previously, with dependency graphs, summary tables, and detailed symbol
    breakdowns.


    ````markdown

    # RepoGraph for `my-project`


    _Generated by RepoGraph on 2023-10-27_


    ## 🚀 Project Overview


    This repository contains 42 source files. The analysis highlights the most
    central and interconnected modules that form the backbone of the
    application.


    ### Module Dependency Graph


    ```mermaid

    graph TD
        A[src/index.ts] --> B(src/server.ts)
        B --> C{src/core/router.ts}
        B --> D[src/core/database.ts]
        C --> E[src/handlers/user.ts]
        E --> D
    ```


    ### Top 10 Most Important Files (Ranked by PageRank)


    | Rank | File | Key Symbols | Description |

    | :--- | :--- | :--- | :--- |

    | 1 | `src/core/database.ts` | `connectDB`, `query` | Central database
    connection and query module. Used by most handlers. |

    | 2 | `src/server.ts` | `createServer`, `app` | Main Express server setup
    and middleware configuration. |

    | ... | ... | ... | ... |


    ---


    ## 📂 File & Symbol Breakdown


    ### [`src/core/database.ts`](./src/core/database.ts)


    Central database connection and query module. Used by most handlers.


    -   **`function connectDB()`** - _L12_
        Establishes the main connection to the PostgreSQL database.
        ```typescript
        export async function connectDB(): Promise<void>
        ```

    ---
  src/index.ts: |-
    #!/usr/bin/env bun

    // High-Level API for simple use cases
    import { generateMap as executeGenerateMap } from './high-level.js';
    import type { RepoGraphOptions as IRepoGraphOptions } from './types.js';

    export { generateMap } from './high-level.js';

    // Low-Level API for composition and advanced use cases
    export { createMapGenerator } from './composer.js';

    // Default pipeline component factories
    export { createDefaultDiscoverer } from './pipeline/discover.js';
    export { createTreeSitterAnalyzer } from './pipeline/analyze.js';
    export { createPageRanker, createGitRanker } from './pipeline/rank.js';
    export { createMarkdownRenderer } from './pipeline/render.js';

    // Core types for building custom components
    export type {
      FileContent,
      CodeNode,
      CodeNodeType,
      CodeEdge,
      CodeGraph,
      RankedCodeGraph,
      RepoGraphOptions,
      RendererOptions,
      FileDiscoverer,
      Analyzer,
      Ranker,
      Renderer,
    } from './types.js';

    // This section runs only when the script is executed directly from the CLI
    import { fileURLToPath } from 'node:url';
    import path from 'node:path';

    const isRunningDirectly = () => {
      if (typeof process.argv[1] === 'undefined') return false;
      const runningFile = path.resolve(process.argv[1]);
      const currentFile = fileURLToPath(import.meta.url);
      return runningFile === currentFile;
    };

    if (isRunningDirectly()) {
      const args = process.argv.slice(2);

      if (args.includes('--help') || args.includes('-h')) {
        console.log(`
    Usage: repograph [root] [options]
     
    Arguments:
      root                     The root directory of the repository to analyze. Defaults to the current working directory.

    Options:
      -h, --help               Display this help message.
      -v, --version            Display the version number.
      --output <path>          Path to the output Markdown file. (default: "repograph.md")
      --include <pattern>      Glob pattern for files to include. Can be specified multiple times.
      --ignore <pattern>       Glob pattern for files to ignore. Can be specified multiple times.
      --no-gitignore           Do not respect .gitignore files.
      --ranking-strategy <name> The ranking strategy to use. (default: "pagerank", options: "pagerank", "git-changes")
        `);
        process.exit(0);
      }

      if (args.includes('--version') || args.includes('-v')) {
        // In a real app, you'd get this from package.json
        console.log('0.1.0');
        process.exit(0);
      }

      // We need a mutable version of the options to build it from arguments.
      const options: {
        root?: string;
        output?: string;
        include?: readonly string[];
        ignore?: readonly string[];
        noGitignore?: boolean;
        rankingStrategy?: 'pagerank' | 'git-changes';
        rendererOptions?: IRepoGraphOptions['rendererOptions'];
      } = {};
      const includePatterns: string[] = [];
      const ignorePatterns: string[] = [];

      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (!arg) {
          continue;
        }
        switch (arg) {
          case '--output':
            options.output = args[++i];
            break;
          case '--include':
            includePatterns.push(args[++i] as string);
            break;
          case '--ignore':
            ignorePatterns.push(args[++i] as string);
            break;
          case '--no-gitignore':
            options.noGitignore = true;
            break;
          case '--ranking-strategy':
            options.rankingStrategy = args[++i] as IRepoGraphOptions['rankingStrategy'];
            break;
          default:
            if (!arg.startsWith('-')) {
              options.root = arg;
            }
            break;
        }
      }

      if (includePatterns.length > 0) {
        options.include = includePatterns;
      }
      if (ignorePatterns.length > 0) {
        options.ignore = ignorePatterns;
      }

      executeGenerateMap(options)
        .then(() => {
          console.log(`✅ RepoGraph map generated successfully at ${path.resolve(options.root || process.cwd(), options.output || 'repograph.md')}`);
        })
        .catch((error: unknown) => {
          if (error instanceof Error) {
            console.error(`❌ Error generating RepoGraph map: ${error.message}`);
          } else {
            console.error('❌ An unknown error occurred while generating the RepoGraph map.');
          }
          process.exit(1);
        });
    }
  src/high-level.ts: >-
    import { createMapGenerator } from './composer.js';

    import { createDefaultDiscoverer } from './pipeline/discover.js';

    import { createTreeSitterAnalyzer } from './pipeline/analyze.js';

    import { createPageRanker, createGitRanker } from './pipeline/rank.js';

    import { createMarkdownRenderer } from './pipeline/render.js';

    import type { RepoGraphOptions, Ranker } from './types.js';

    import path from 'node:path';


    /**
     * The primary, easy-to-use entry point for RepoGraph. It orchestrates the
     * default pipeline based on a configuration object to generate a codemap.
     *
     * @param options The configuration object for generating the map.
     */
    export const generateMap = async (options: RepoGraphOptions = {}):
    Promise<void> => {
      const {
        root = process.cwd(),
        output = './repograph.md',
        rankingStrategy = 'pagerank',
      } = options;

      let ranker: Ranker;
      switch (rankingStrategy) {
        case 'git-changes':
          ranker = createGitRanker();
          break;
        case 'pagerank':
          ranker = createPageRanker();
          break;
        default:
          // This will now correctly handle any invalid strategy that bypasses the type system.
          throw new Error(`Invalid ranking strategy: '${rankingStrategy}'. Available options are 'pagerank', 'git-changes'.`);
      }

      const generator = createMapGenerator({
        discover: createDefaultDiscoverer(),
        analyze: createTreeSitterAnalyzer(),
        rank: ranker,
        render: createMarkdownRenderer(),
      });

      await generator({
        root: path.resolve(root),
        output: output,
        include: options.include,
        ignore: options.ignore,
        noGitignore: options.noGitignore,
        rendererOptions: options.rendererOptions,
      });
    };
  src/composer.ts: >-
    import fs from 'node:fs/promises';

    import path from 'node:path';

    import type { Analyzer, FileDiscoverer, Ranker, Renderer } from
    './types.js';


    type MapGenerator = (config: {
      readonly root: string;
      readonly output: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
      readonly rendererOptions?: any;
    }) => Promise<void>;


    /**
     * A Higher-Order Function that takes pipeline functions as arguments and
     * returns a fully configured `generate` function for creating a codemap.
     * This is the core of RepoGraph's composability.
     *
     * @param pipeline An object containing implementations for each pipeline stage.
     * @returns An asynchronous function to generate and write the codemap.
     */
    export const createMapGenerator = (pipeline: {
      readonly discover: FileDiscoverer;
      readonly analyze: Analyzer;
      readonly rank: Ranker;
      readonly render: Renderer;
    }): MapGenerator => {
      if (
        !pipeline ||
        typeof pipeline.discover !== 'function' ||
        typeof pipeline.analyze !== 'function' ||
        typeof pipeline.rank !== 'function' ||
        typeof pipeline.render !== 'function'
      ) {
        throw new Error('createMapGenerator: A valid pipeline object with discover, analyze, rank, and render functions must be provided.');
      }

      return async (config) => {
        const { root, output, include, ignore, noGitignore, rendererOptions } = config;

        // 1. Discover
        const files = await pipeline.discover({ root, include, ignore, noGitignore });

        // 2. Analyze
        const graph = await pipeline.analyze(files);

        // 3. Rank
        const rankedGraph = await pipeline.rank(graph);

        // 4. Render
        const markdown = pipeline.render(rankedGraph, rendererOptions);

        // 5. Write to disk
        const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, markdown);
      };
    };
  src/types.ts: >-
    import type Graph from 'graphology';


    // Core Data Structures


    /** Represents a single file read from disk. Immutable. */

    export type FileContent = {
      readonly path: string;
      readonly content: string;
    };


    /** The type of a symbol identified in the code. */

    export type CodeNodeType = 
      | 'file' 
      | 'class' 
      | 'function' 
      | 'interface' 
      | 'import' 
      | 'variable' 
      | 'type' 
      | 'arrow_function' 
      | 'method' 
      | 'field'
      | 'struct'
      | 'enum'
      | 'namespace'
      | 'trait'
      | 'impl'
      | 'constructor'
      | 'property'
      | 'constant'
      | 'static'
      | 'union'
      | 'template';

    /** Represents a single, identifiable symbol (or a file) in the code.
    Immutable. */

    export type CodeNode = {
      readonly id: string; // Unique identifier (e.g., 'src/api.ts#MyClass')
      readonly type: CodeNodeType;
      readonly name: string; // e.g., 'MyClass'
      readonly filePath: string;
      readonly startLine: number;
      readonly endLine: number;
      readonly codeSnippet?: string; // e.g., function signature
    };


    /** Represents a directed relationship between two CodeNodes. Immutable. */

    export type CodeEdge = {
      readonly fromId: string; // ID of the source CodeNode
      readonly toId: string;   // ID of the target CodeNode
      readonly type: 'imports' | 'calls' | 'inherits' | 'implements' | 'contains';
    };


    /** The complete, raw model of the repository's structure using graphology.
    Immutable. */

    export type CodeGraph = Readonly<Graph<CodeNode>>;


    /** A CodeGraph with an added 'rank' score for each node. Immutable. */

    export type RankedCodeGraph = {
      readonly graph: CodeGraph;
      readonly ranks: ReadonlyMap<string, number>; // Key is CodeNode ID
    };


    // High-Level API Options


    /** Configuration for the final Markdown output. */

    export type RendererOptions = {
      /** Include a Mermaid.js dependency graph. @default true */
      readonly includeMermaidGraph?: boolean;
      /** Include detailed breakdowns for each symbol. @default true */
      readonly includeSymbolDetails?: boolean;
      /** Custom text to appear at the top of the Markdown file. */
      readonly customHeader?: string;
    };


    /** Configuration options for the main `generateMap` function. */

    export type RepoGraphOptions = {
      /** Root directory to analyze. @default process.cwd() */
      readonly root?: string;
      /** Output path for the Markdown file. @default './repograph.md' */
      readonly output?: string;
      /** Glob patterns for files to include. */
      readonly include?: readonly string[];
      /** Glob patterns for files to exclude. */
      readonly ignore?: readonly string[];
      /** Disables the use of .gitignore. @default false */
      readonly noGitignore?: boolean;
      /** The ranking strategy to use. @default 'pagerank' */
      readonly rankingStrategy?: 'pagerank' | 'git-changes';
      /** Configuration for the final Markdown output. */
      readonly rendererOptions?: RendererOptions;
    };


    // Low-Level Functional Pipeline Contracts


    /** Discovers files and returns their content. */

    export type FileDiscoverer = (config: {
      readonly root: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
    }) => Promise<readonly FileContent[]>;


    /** Analyzes file content and builds the dependency graph. */

    export type Analyzer = (files: readonly FileContent[]) =>
    Promise<CodeGraph>;


    /** Ranks the nodes in a graph. */

    export type Ranker = (graph: CodeGraph) => Promise<RankedCodeGraph>;


    /** Renders a ranked graph into a string format. */

    export type Renderer = (rankedGraph: RankedCodeGraph, options?:
    RendererOptions) => string;
approved: true
