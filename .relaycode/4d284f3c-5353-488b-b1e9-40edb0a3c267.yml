uuid: 4d284f3c-5353-488b-b1e9-40edb0a3c267
projectId: repograph
createdAt: '2025-06-29T01:12:10.862Z'
gitCommitMsg: 'fix(tests): resolve all TypeScript errors in test suite'
promptSummary: >-
  Fix a large number of TypeScript errors reported by `bun tsc --noEmit` across
  multiple test files. Errors include unused variables, type mismatches
  (especially with graphology and fixtures), and potential null/undefined
  access.
reasoning:
  - >-
    Here are the fixes for the TypeScript errors in your test files. I've
    addressed unused imports, type mismatches, potential null/undefined errors,
    and made tests more robust.
  - I'll start by removing unused imports from `test/e2e/cli.test.ts`.
  - >-
    Next, I'll fix a potential `undefined` access in
    `test/test-utilities.test.ts` by ensuring the array has elements before
    accessing an index.
  - >-
    In `test/test.util.ts`, I'll add a check to ensure a regex match group
    exists before adding it to an array, preventing errors with `undefined`.
  - >-
    For `test/unit/analyze.test.ts`, I'll remove unused type imports and use
    non-null assertions for fixture properties that are guaranteed to exist in
    the test context.
  - >-
    Now, for `test/unit/composer.test.ts`, I'll fix several issues including
    unused variables, incorrect types, and overly strict type checks in custom
    component tests.
  - >-
    In `test/unit/discover.test.ts`, I'll remove an unused import and make
    assertions safer by checking array lengths and using non-null assertions
    where appropriate.
  - >-
    I'll now fix `test/unit/rank.test.ts` by removing an unused import and
    handling potential undefined values in assertions.
  - >-
    Finally, for `test/unit/render.test.ts`, I'll fix numerous type errors by
    ensuring `Graph` instances are correctly typed with `CodeNode` and by
    handling potential `undefined` values from fixtures.
  - >-
    The rest of the failing test files (`test/unit/high-level.test.ts`,
    `test/integration/high-level.test.ts`, `test/integration/pipeline.test.ts`,
    `test/test-utilities.test.ts`, `test/fixtures/complex-project.yaml`,
    `test/fixtures/minimal-project.yaml`, `test/fixtures/sample-project.yaml`)
    did not have any TypeScript errors reported in the prompt, so no changes are
    needed for them.
  - All reported TypeScript errors should now be resolved.
operations:
  - type: write
    path: test/e2e/cli.test.ts
    content: |-
      <<<<<<< SEARCH
      import { spawn } from 'node:child_process';
      import { promisify } from 'node:util';
      import {
        createTempDir,
        cleanupTempDir,
        createTestFiles,
        createGitignore,
        assertFileExists,
        readFile,
        isValidMarkdown,
        containsValidMermaid,
        loadFixture,
        createProjectFromFixture
      } from '../test.util.js';
      import path from 'node:path';
      import fs from 'node:fs/promises';

      const execAsync = promisify(require('node:child_process').exec);
      =======
      import { spawn } from 'node:child_process';
      import {
        createTempDir,
        cleanupTempDir,
        createTestFiles,
        createGitignore,
        assertFileExists,
        readFile,
        isValidMarkdown,
        containsValidMermaid,
        loadFixture,
        createProjectFromFixture
      } from '../test.util.js';
      import path from 'node:path';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/test-utilities.test.ts
    content: |-
      --- test/test-utilities.test.ts
      +++ test/test-utilities.test.ts
      @@ -153,8 +153,9 @@
             await createTestFiles(tempDir, files);
             const allFiles = await readAllFiles(tempDir);
       
      -      // Should normalize to forward slashes
      -      expect(allFiles[0].path).toBe('src/windows/style/path.ts');
      +      expect(allFiles).toHaveLength(1);
      +      // Should normalize to forward slashes
      +      expect(allFiles[0]!.path).toBe('src/windows/style/path.ts');
           });
         });
       });
    patchStrategy: new-unified
  - type: write
    path: test/test.util.ts
    content: |-
      --- test/test.util.ts
      +++ test/test.util.ts
      @@ -231,7 +231,9 @@
         let match;
         
         while ((match = pathRegex.exec(content)) !== null) {
      -    paths.push(match[1]);
      +    if (match[1]) {
      +      paths.push(match[1]);
      +    }
         }
         
         return paths;
    patchStrategy: new-unified
  - type: write
    path: test/unit/analyze.test.ts
    content: >-
      --- test/unit/analyze.test.ts

      +++ test/unit/analyze.test.ts

      @@ -1,5 +1,5 @@
       import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
       import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
      -import type { FileContent, CodeNode, CodeGraph } from
      '../../src/types.js';

      +import type { FileContent } from '../../src/types.js';
       import {
         createTempDir,
         cleanupTempDir,
      @@ -511,7 +511,7 @@
       
             const graph = await analyzer(files);
       
      -      expect(graph.order).toBe(fixture.expected_nodes);

      +      expect(graph.order).toBe(fixture.expected_nodes!);
             
             // Check for specific symbols from the fixture
             expect(graph.hasNode('src/calculator.ts#Calculator')).toBe(true);
      @@ -546,7 +546,7 @@
             const files: FileContent[] = [
               {
                 path: 'src/main.ts',
      -          content: fixture.files[0].content

      +          content: fixture.files[0]!.content
               }
             ];
    patchStrategy: new-unified
  - type: write
    path: test/unit/composer.test.ts
    content: >-
      --- test/unit/composer.test.ts

      +++ test/unit/composer.test.ts

      @@ -4,7 +4,7 @@
       import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
       import { createPageRanker } from '../../src/pipeline/rank.js';
       import { createMarkdownRenderer } from '../../src/pipeline/render.js';
      -import type { FileDiscoverer, Analyzer, Ranker, Renderer,
      MapGeneratorOptions } from '../../src/types.js';

      +import type { FileDiscoverer, Analyzer, Ranker, Renderer, FileContent }
      from '../../src/types.js';
       import {
         createTempDir,
         cleanupTempDir,
      @@ -248,9 +248,8 @@
               const graph = await defaultAnalyzer(files);
               
               // Add custom metadata to all nodes
      -        graph.forEachNode((nodeId) => {

      -          const attrs = graph.getNodeAttributes(nodeId);

      -          graph.setNodeAttribute(nodeId, 'customMetadata', 'processed by
      custom analyzer');

      +        graph.forEachNode(nodeId => {

      +          (graph as any).setNodeAttribute(nodeId, 'customMetadata',
      'processed by custom analyzer');
               });
               
               return graph;
      @@ -280,7 +279,7 @@
             await createTestFiles(tempDir, files);
       
             // Custom ranker that assigns alphabetical ranks
      -      const customRanker: Ranker = async (graph, files) => {

      +      const customRanker: Ranker = async (graph, _files) => {
               const ranks = new Map<string, number>();
               const fileNodes = graph.filterNodes(nodeId => 
                 graph.getNodeAttribute(nodeId, 'type') === 'file'
      @@ -350,7 +349,7 @@
               files.filter(f => f.path.endsWith('.special')).forEach(file => {
                 graph.addNode(file.path, {
                   id: file.path,
      -            type: 'special',

      +            type: 'special' as any,
                   name: path.basename(file.path),
                   filePath: file.path,
                   startLine: 1,
      @@ -362,11 +361,11 @@
             };
       
             // Custom ranker that gives special files high rank
      -      const customRanker: Ranker = async (graph, files) => {

      +      const customRanker: Ranker = async (graph, _files) => {
               const ranks = new Map<string, number>();
               
               graph.forEachNode(nodeId => {
      -          const nodeType = graph.getNodeAttribute(nodeId, 'type');

      +          const nodeType = graph.getNodeAttribute(nodeId, 'type') as
      string;
                 if (nodeType === 'special') {
                   ranks.set(nodeId, 1.0);
                 } else {
      @@ -380,7 +379,7 @@
             // Custom renderer that handles special files
             const customRenderer: Renderer = (rankedGraph, options) => {
               const specialNodes = rankedGraph.graph.filterNodes(nodeId =>
      -          rankedGraph.graph.getNodeAttribute(nodeId, 'type') ===
      'special'

      +          (rankedGraph.graph.getNodeAttribute(nodeId, 'type') as string)
      === 'special'
               );
               
               let markdown = '# Custom Project with Special Files\n\n';
      @@ -628,16 +627,16 @@
             };
             await createTestFiles(tempDir, files);
       
      -      let discoveredFiles: any[] = [];

      -      let analyzedFiles: any[] = [];

      +      let discoveredFiles: readonly FileContent[] = [];

      +      let analyzedFiles: readonly FileContent[] = [];
       
             const trackingDiscoverer: FileDiscoverer = async (options) => {
               const defaultDiscoverer = createDefaultDiscoverer();
      -        discoveredFiles = await defaultDiscoverer(options);

      +        discoveredFiles = await defaultDiscoverer(options);
               return discoveredFiles;
             };
       
             const trackingAnalyzer: Analyzer = async (files) => {
      -        analyzedFiles = files;

      +        analyzedFiles = files;
               const defaultAnalyzer = createTreeSitterAnalyzer();
               return await defaultAnalyzer(files);
             };
    patchStrategy: new-unified
  - type: write
    path: test/unit/discover.test.ts
    content: >-
      --- test/unit/discover.test.ts

      +++ test/unit/discover.test.ts

      @@ -7,8 +7,7 @@
         createGitignore,
         loadFixture,
         createProjectFromFixture,
      -  createSymlink,

      -  directoryExists

      +  createSymlink
       } from '../test.util.js';
       import path from 'node:path';
       import fs from 'node:fs/promises';
      @@ -65,8 +64,8 @@
               include: ['**/*.ts']
             });
       
      -      expect(result.length).toBe(1);

      -      expect(result[0].path).toBe('src/index.ts');

      +      expect(result).toHaveLength(1);

      +      expect(result[0]!.path).toBe('src/index.ts');
           });
       
           it('should exclude files matching ignore patterns', async () => {
      @@ -82,8 +81,8 @@
               ignore: ['**/*.spec.ts']
             });
       
      -      expect(result.length).toBe(2);

      -      expect(result.map(f => f.path).sort()).toEqual([

      +      expect(result).toHaveLength(2);

      +      expect(result.map(f => f.path).sort()).toEqual(
               'src/index.ts',
               'src/utils.ts'
      -      ]);

      +      );
           });
       
           it('should respect .gitignore by default', async () => {
      @@ -99,8 +98,8 @@
               root: tempDir
             });
       
      -      expect(result.length).toBe(1);

      -      expect(result[0].path).toBe('src/index.ts');

      +      expect(result).toHaveLength(1);

      +      expect(result[0]!.path).toBe('src/index.ts');
           });
       
           it('should ignore .gitignore when noGitignore is true', async () => {
      @@ -116,12 +115,12 @@
               noGitignore: true
             });
       
      -      expect(result.length).toBe(3);

      -      expect(result.map(f => f.path).sort()).toEqual([

      +      expect(result).toHaveLength(3);

      +      expect(result.map(f => f.path).sort()).toEqual(
               '.env',
               'dist/index.js',
               'src/index.ts'
      -      ]);

      +      );
           });
       
           it('should always exclude node_modules directory', async () => {
      @@ -135,8 +134,8 @@
               noGitignore: true
             });
       
      -      expect(result.length).toBe(1);

      -      expect(result[0].path).toBe('src/index.ts');

      +      expect(result).toHaveLength(1);

      +      expect(result[0]!.path).toBe('src/index.ts');
           });
       
           it('should handle non-existent root directory gracefully', async () => {
      @@ -160,12 +159,12 @@
             });
       
             // Should only include text files
      -      expect(result.length).toBe(2);

      -      expect(result.map(f => f.path).sort()).toEqual([

      +      expect(result).toHaveLength(2);

      +      expect(result.map(f => f.path).sort()).toEqual(
               'README.md',
               'src/index.ts'
      -      ]);

      +      );
           });
       
           it('should return FileContent objects with correct path and content properties', async () => {
      @@ -178,11 +177,12 @@
               root: tempDir
             });
       
      -      expect(result.length).toBe(1);

      -      expect(result[0]).toHaveProperty('path');

      -      expect(result[0]).toHaveProperty('content');

      -      expect(result[0].path).toBe('src/index.ts');

      -      expect(result[0].content).toBe('export const hello = "world";');

      +      expect(result).toHaveLength(1);

      +      expect(result[0]).toBeDefined();

      +      expect(result[0]!).toHaveProperty('path');

      +      expect(result[0]!).toHaveProperty('content');

      +      expect(result[0]!.path).toBe('src/index.ts');

      +      expect(result[0]!.content).toBe('export const hello = "world";');
           });
       
           it('should handle empty directories', async () => {
      @@ -219,9 +219,9 @@
               root: tempDir
             });
       
      -      expect(result.length).toBe(1);

      +      expect(result).toHaveLength(1);
             // Path should use forward slashes regardless of platform
      -      expect(result[0].path).toBe('src/nested/deep/index.ts');

      +      expect(result[0]!.path).toBe('src/nested/deep/index.ts');
           });
         });
       
      @@ -238,8 +238,8 @@
               root: tempDir
             });
       
      -      expect(result.length).toBe(1);

      -      expect(result[0].path).toBe('src/index.ts');

      +      expect(result).toHaveLength(1);

      +      expect(result[0]!.path).toBe('src/index.ts');
           });
       
           it('should handle missing .gitignore file gracefully', async () => {
      @@ -251,8 +251,8 @@
               root: tempDir
             });
       
      -      expect(result.length).toBe(1);

      -      expect(result[0].path).toBe('src/index.ts');

      +      expect(result).toHaveLength(1);

      +      expect(result[0]!.path).toBe('src/index.ts');
           });
       
           it('should combine .gitignore patterns with ignore option', async () => {
      @@ -271,8 +271,8 @@
               ignore: ['test/', 'docs/']
             });
       
      -      expect(result.length).toBe(1);

      -      expect(result[0].path).toBe('src/index.ts');

      +      expect(result).toHaveLength(1);

      +      expect(result[0]!.path).toBe('src/index.ts');
           });
       
           it('should handle complex .gitignore patterns', async () => {
      @@ -294,9 +294,9 @@
               root: tempDir
             });
       
      -      expect(result.length).toBe(2);

      +      expect(result).toHaveLength(2);
             const paths = result.map(f => f.path).sort();
      -      expect(paths).toEqual(['logs/current.log', 'src/index.ts']);

      +      expect(paths).toEqual(['logs/current.log', 'src/index.ts']);
           });
         });
       
      @@ -315,9 +315,9 @@
               include: ['src/**/*.ts', 'tests/**/*.ts']
             });
       
      -      expect(result.length).toBe(2);

      +      expect(result).toHaveLength(2);
             const paths = result.map(f => f.path).sort();
      -      expect(paths).toEqual(['src/index.ts', 'tests/spec.ts']);

      +      expect(paths).toEqual(['src/index.ts', 'tests/spec.ts']);
           });
       
           it('should support glob patterns in ignore option', async () => {
      @@ -334,9 +334,9 @@
               ignore: ['**/*.spec.ts', '**/*.test.ts']
             });
       
      -      expect(result.length).toBe(2);

      +      expect(result).toHaveLength(2);
             const paths = result.map(f => f.path).sort();
      -      expect(paths).toEqual(['src/helper.ts', 'src/index.ts']);

      +      expect(paths).toEqual(['src/helper.ts', 'src/index.ts']);
           });
       
           it('should handle dot files correctly', async () => {
      @@ -352,9 +352,9 @@
               root: tempDir
             });
       
      -      expect(result.length).toBe(4);

      +      expect(result).toHaveLength(4);
             const paths = result.map(f => f.path).sort();
      -      expect(paths).toEqual(['.env', '.gitignore', '.hidden/file.ts',
      'src/index.ts']);

      +      expect(paths).toEqual(['.env', '.gitignore', '.hidden/file.ts',
      'src/index.ts']);
           });
         });
       
      @@ -368,11 +368,11 @@
               include: ['**/*.ts']
             });
       
      -      expect(result.length).toBe(fixture.expected_files);

      +      expect(result.length).toBe(fixture.expected_files!);
             
             // Verify all TypeScript files are discovered
             const tsFiles = result.filter(f => f.path.endsWith('.ts'));
      -      expect(tsFiles.length).toBe(fixture.expected_files);

      +      expect(tsFiles.length).toBe(fixture.expected_files!);
           });
       
           it('should work with minimal-project fixture', async () => {
      @@ -384,9 +384,10 @@
               include: ['**/*.ts']
             });
       
      -      expect(result.length).toBe(fixture.expected_files);

      -      expect(result[0].path).toBe('src/main.ts');

      -      expect(result[0].content).toContain('export function hello()');

      +      expect(result.length).toBe(fixture.expected_files!);

      +      expect(result[0]).toBeDefined();

      +      expect(result[0]!.path).toBe('src/main.ts');

      +      expect(result[0]!.content).toContain('export function hello()');
           });
       
           it('should respect gitignore from complex-project fixture', async () => {
      @@ -398,7 +399,7 @@
             });
       
             // Should exclude test files due to gitignore
      -      expect(result.length).toBe(fixture.expected_files);

      +      expect(result.length).toBe(fixture.expected_files!);
             const paths = result.map(f => f.path);
             expect(paths).not.toContain('tests/user.test.ts');
           });
    patchStrategy: new-unified
  - type: write
    path: test/unit/rank.test.ts
    content: >-
      --- test/unit/rank.test.ts

      +++ test/unit/rank.test.ts

      @@ -1,5 +1,5 @@
       import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
       import { createPageRanker, createGitRanker } from '../../src/pipeline/rank.js';
       import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
      -import type { FileContent, CodeGraph, RankedCodeGraph } from
      '../../src/types.js';

      +import type { FileContent, CodeGraph } from '../../src/types.js';
       import Graph from 'graphology';
       import {
         createTempDir,
      @@ -467,7 +467,9 @@
             
             // All nodes should have equal rank in a graph with no edges
             const ranks = Array.from(result.ranks.values());
      -      expect(ranks[0]).toBeCloseTo(ranks[1], 5);

      +      expect(ranks[0]).toBeDefined();

      +      expect(ranks[1]).toBeDefined();

      +      expect(ranks[0]!).toBeCloseTo(ranks[1]!, 5);
           });
         });
       
      @@ -538,13 +540,13 @@
             const files: FileContent[] = [
               {
                 path: 'src/main.ts',
      -          content: fixture.files[0].content

      +          content: fixture.files[0]!.content
               }
             ];
       
             const graph = await analyzer(files);
             const pageRanker = createPageRanker();
             const result = await pageRanker(graph, files);
       
      -      expect(result.ranks.size).toBe(fixture.expected_nodes);

      +      expect(result.ranks.size).toBe(fixture.expected_nodes!);
             
             // All nodes should have positive ranks
             for (const rank of result.ranks.values()) {
    patchStrategy: new-unified
  - type: write
    path: test/unit/render.test.ts
    content: >-
      --- test/unit/render.test.ts

      +++ test/unit/render.test.ts

      @@ -3,7 +3,7 @@
       import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
       import { createPageRanker } from '../../src/pipeline/rank.js';
      -import type { FileContent, RankedCodeGraph, RendererOptions } from
      '../../src/types.js';

      +import type { CodeNode, FileContent, RankedCodeGraph, RendererOptions }
      from '../../src/types.js';
       import Graph from 'graphology';
       import {
         createTempDir,
      @@ -28,13 +28,13 @@
           });
       
           it('should generate valid markdown from empty graph', () => {
      -      const emptyGraph = new Graph({

      +      const emptyGraph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
             });
       
             const rankedGraph: RankedCodeGraph = {
      -        graph: emptyGraph,

      +        graph: emptyGraph,
               ranks: new Map()
             };
       
      @@ -45,7 +45,7 @@
           });
       
           it('should include project overview section', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -79,7 +79,7 @@
           });
       
           it('should include Mermaid graph by default', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -122,7 +122,7 @@
           });
       
           it('should exclude Mermaid graph when option is false', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -152,7 +152,7 @@
           });
       
           it('should include top 10 most important files', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -173,7 +173,7 @@
               ranks.set(nodeId, i / 15); // Higher numbers get higher ranks
             }
       
      -      const rankedGraph: RankedCodeGraph = { graph, ranks };

      +      const rankedGraph: RankedCodeGraph = { graph: graph, ranks };
             const markdown = renderer(rankedGraph);
       
             expect(markdown).toContain('### Top 10 Most Important Files');
      @@ -187,7 +187,7 @@
           });
       
           it('should include symbol details by default', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -241,7 +241,7 @@
           });
       
           it('should exclude symbol details when option is false', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -271,7 +271,7 @@
           });
       
           it('should include custom header when provided', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -293,7 +293,7 @@
           });
       
           it('should handle files with no symbols', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -318,7 +318,7 @@
           });
       
           it('should sort symbols by line number', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -382,7 +382,7 @@
           });
       
           it('should sort files by rank (highest first)', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -407,7 +407,7 @@
               ranks.set(file.id, file.rank);
             }
       
      -      const rankedGraph: RankedCodeGraph = { graph, ranks };

      +      const rankedGraph: RankedCodeGraph = { graph: graph, ranks };
             const markdown = renderer(rankedGraph);
       
             // Check order in the file breakdown section
      @@ -420,7 +420,7 @@
           });
       
           it('should handle symbols without code snippets', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -459,7 +459,7 @@
           });
       
           it('should generate proper markdown links for files', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -485,7 +485,7 @@
       
         describe('Mermaid Graph Generation', () => {
           it('should only include file nodes in Mermaid graph', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -533,7 +533,7 @@
           });
       
           it('should handle graphs with no file-to-file edges', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -560,7 +560,7 @@
           });
       
           it('should deduplicate edges in Mermaid graph', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -647,7 +647,7 @@
             const files: FileContent[] = [
               {
                 path: 'src/main.ts',
      -          content: fixture.files[0].content

      +          content: fixture.files[0]!.content
               }
             ];
       
      @@ -700,7 +700,7 @@
       
         describe('Edge Cases', () => {
           it('should handle very long file paths', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -725,7 +725,7 @@
           });
       
           it('should handle special characters in file names', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
      @@ -750,7 +750,7 @@
           });
       
           it('should handle empty code snippets gracefully', () => {
      -      const graph = new Graph({

      +      const graph: Graph<CodeNode> = new Graph({
               multi: true,
               allowSelfLoops: false,
               type: 'directed',
    patchStrategy: new-unified
snapshot:
  test/e2e/cli.test.ts: |-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
    import { spawn } from 'node:child_process';
    import { promisify } from 'node:util';
    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      createGitignore,
      assertFileExists,
      readFile,
      isValidMarkdown,
      containsValidMermaid,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';
    import path from 'node:path';
    import fs from 'node:fs/promises';

    const execAsync = promisify(require('node:child_process').exec);

    describe('CLI End-to-End Tests', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      const runCLI = async (args: string[], cwd?: string): Promise<{ stdout: string; stderr: string; exitCode: number }> => {
        return new Promise((resolve, reject) => {
          const child = spawn('bun', ['run', 'src/index.ts', ...args], {
            cwd: cwd || process.cwd(),
            stdio: 'pipe'
          });

          let stdout = '';
          let stderr = '';

          child.stdout?.on('data', (data) => {
            stdout += data.toString();
          });

          child.stderr?.on('data', (data) => {
            stderr += data.toString();
          });

          child.on('close', (code) => {
            resolve({
              stdout,
              stderr,
              exitCode: code || 0
            });
          });

          child.on('error', reject);
        });
      };

      describe('Basic CLI Usage', () => {
        it('should generate map with default options', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([tempDir], tempDir);

          expect(result.exitCode).toBe(0);
          await assertFileExists(path.join(tempDir, 'repograph.md'));
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Example');
        });

        it('should accept custom output path', async () => {
          const files = {
            'src/test.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'custom-output.md');
          const result = await runCLI([tempDir, '--output', outputPath], tempDir);

          expect(result.exitCode).toBe(0);
          await assertFileExists(outputPath);
        });

        it('should accept include patterns', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/index.js');
        });

        it('should accept ignore patterns', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/test.spec.ts': 'test code'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ignore', '**/*.spec.ts'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/test.spec.ts');
        });

        it('should accept ranking strategy option', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ranking-strategy', 'git-changes'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          await assertFileExists(path.join(tempDir, 'repograph.md'));
        });

        it('should accept no-gitignore flag', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'dist/index.js': 'compiled code'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['dist/']);

          const result = await runCLI([
            tempDir,
            '--no-gitignore'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('dist/index.js');
        });

        it('should show help when --help flag is used', async () => {
          const result = await runCLI(['--help']);

          expect(result.exitCode).toBe(0);
          expect(result.stdout).toContain('Usage:');
          expect(result.stdout).toContain('Options:');
        });

        it('should show version when --version flag is used', async () => {
          const result = await runCLI(['--version']);

          expect(result.exitCode).toBe(0);
          expect(result.stdout).toMatch(/\d+\.\d+\.\d+/);
        });
      });

      describe('Error Handling', () => {
        it('should handle non-existent directory', async () => {
          const nonExistentDir = path.join(tempDir, 'non-existent');
          const result = await runCLI([nonExistentDir]);

          expect(result.exitCode).not.toBe(0);
          expect(result.stderr).toContain('Error');
        });

        it('should handle invalid output directory', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const invalidOutput = '/root/cannot-write-here.md';
          const result = await runCLI([
            tempDir,
            '--output', invalidOutput
          ]);

          expect(result.exitCode).not.toBe(0);
        });

        it('should handle invalid ranking strategy', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ranking-strategy', 'invalid-strategy'
          ]);

          expect(result.exitCode).not.toBe(0);
          expect(result.stderr).toContain('Invalid ranking strategy');
        });

        it('should handle malformed include patterns gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '[invalid-pattern'
          ]);

          // Should not crash, but might produce empty output
          expect(result.exitCode).toBe(0);
        });
      });

      describe('Multiple Arguments', () => {
        it('should handle multiple include patterns', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'lib/utils.js': 'export const js = true;',
            'docs/readme.md': '# Documentation'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts',
            '--include', '**/*.js'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).toContain('lib/utils.js');
          expect(content).not.toContain('docs/readme.md');
        });

        it('should handle multiple ignore patterns', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/test.spec.ts': 'test code',
            'src/utils.test.ts': 'test utils',
            'src/helper.ts': 'helper code'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ignore', '**/*.spec.ts',
            '--ignore', '**/*.test.ts'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).toContain('src/helper.ts');
          expect(content).not.toContain('src/test.spec.ts');
          expect(content).not.toContain('src/utils.test.ts');
        });
      });

      describe('Output Validation', () => {
        it('should generate valid markdown structure', async () => {
          const files = {
            'src/calculator.ts': `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
    }`,
            'src/logger.ts': `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([tempDir], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          
          // Check markdown structure
          expect(content).toContain('# RepoGraph');
          expect(content).toContain('## 🚀 Project Overview');
          expect(content).toContain('### Module Dependency Graph');
          expect(content).toContain('### Top 10 Most Important Files');
          expect(content).toContain('## 📂 File & Symbol Breakdown');
          
          // Check Mermaid graph
          expect(containsValidMermaid(content)).toBe(true);
          
          // Check symbol details
          expect(content).toContain('Calculator');
          expect(content).toContain('Logger');
        });

        it('should handle projects with complex dependencies', async () => {
          const files = {
            'src/index.ts': `import { Database } from './database.js';
    import { ApiServer } from './api.js';

    export class App {
      constructor(
        private db: Database,
        private api: ApiServer
      ) {}
    }`,
            'src/database.ts': `export class Database {
      connect(): Promise<void> {
        return Promise.resolve();
      }
    }`,
            'src/api.ts': `import { Database } from './database.js';

    export class ApiServer {
      constructor(private db: Database) {}
    }`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([tempDir], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('App');
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(containsValidMermaid(content)).toBe(true);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should process sample-project fixture via CLI', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Calculator');
          expect(content).toContain('Logger');
          expect(content).toContain('AdvancedCalculator');
        });

        it('should process complex-project fixture via CLI', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts',
            '--ranking-strategy', 'pagerank'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(content).toContain('UserService');
        });

        it('should handle minimal-project fixture via CLI', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await runCLI([tempDir], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('src/main.ts');
          expect(content).toContain('hello');
          expect(content).toContain('greet');
        });
      });

      describe('Performance', () => {
        it('should handle moderately large projects in reasonable time', async () => {
          // Create a project with many files
          const files: Record<string, string> = {};
          
          for (let i = 0; i < 30; i++) {
            files[`src/module${i}.ts`] = `export class Module${i} {
      process(): string {
        return 'module${i}';
      }
    }`;
          }

          // Add some imports
          files['src/index.ts'] = Array.from({ length: 30 }, (_, i) => 
            `import { Module${i} } from './module${i}.js';`
          ).join('\n') + '\n\nexport const modules = [' + 
          Array.from({ length: 30 }, (_, i) => `Module${i}`).join(', ') + '];';

          await createTestFiles(tempDir, files);

          const startTime = Date.now();
          const result = await runCLI([tempDir], tempDir);
          const endTime = Date.now();

          expect(result.exitCode).toBe(0);
          expect(endTime - startTime).toBeLessThan(15000); // Should complete within 15 seconds
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('Module0');
          expect(content).toContain('Module29');
        });
      });

      describe('Real-world Scenarios', () => {
        it('should work with TypeScript project structure', async () => {
          const files = {
            'package.json': JSON.stringify({
              name: 'my-project',
              version: '1.0.0',
              type: 'module',
              scripts: {
                build: 'tsc',
                test: 'bun test'
              }
            }, null, 2),
            'tsconfig.json': JSON.stringify({
              compilerOptions: {
                target: 'ES2022',
                module: 'ESNext',
                outDir: './dist'
              }
            }, null, 2),
            'src/index.ts': `export { Calculator } from './lib/calculator.js';
    export type { CalculatorOptions } from './types.js';`,
            'src/lib/calculator.ts': `import type { CalculatorOptions } from '../types.js';

    export class Calculator {
      constructor(private options: CalculatorOptions) {}
      
      calculate(expression: string): number {
        return eval(expression);
      }
    }`,
            'src/types.ts': `export interface CalculatorOptions {
      precision: number;
      mode: 'strict' | 'loose';
    }`,
            'README.md': '# My Calculator Project'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', 'src/**/*.ts'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('Calculator');
          expect(content).toContain('CalculatorOptions');
          expect(content).not.toContain('package.json');
          expect(content).not.toContain('README.md');
        });

        it('should work with monorepo structure', async () => {
          const files = {
            'packages/core/src/index.ts': `export { Engine } from './engine.js';`,
            'packages/core/src/engine.ts': `export class Engine {
      start(): void {
        console.log('Engine started');
      }
    }`,
            'packages/ui/src/index.ts': `export { Component } from './component.js';`,
            'packages/ui/src/component.ts': `import { Engine } from '../../core/src/engine.js';

    export class Component {
      private engine = new Engine();
      
      render(): void {
        this.engine.start();
      }
    }`,
            'apps/web/src/main.ts': `import { Component } from '../../../packages/ui/src/component.js';

    const component = new Component();
    component.render();`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts'
          ], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('Engine');
          expect(content).toContain('Component');
          expect(content).toContain('packages/core/src/engine.ts');
          expect(content).toContain('packages/ui/src/component.ts');
          expect(content).toContain('apps/web/src/main.ts');
        });

        it('should respect gitignore in real project', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/utils.ts': 'export const util = true;',
            'dist/index.js': 'compiled code',
            'node_modules/package/index.js': 'dependency',
            'coverage/lcov.info': 'coverage data',
            '.env': 'SECRET=value',
            'logs/app.log': 'log content'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, [
            'dist/',
            'node_modules/',
            'coverage/',
            '.env',
            'logs/'
          ]);

          const result = await runCLI([tempDir], tempDir);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).toContain('src/utils.ts');
          expect(content).not.toContain('dist/index.js');
          expect(content).not.toContain('node_modules/package/index.js');
          expect(content).not.toContain('coverage/lcov.info');
          expect(content).not.toContain('.env');
          expect(content).not.toContain('logs/app.log');
        });
      });
    });
  test/test-utilities.test.ts: |
    import { describe, it, expect, beforeEach, afterEach } from 'bun:test';
    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      createGitignore,
      readAllFiles,
      isValidMarkdown,
      containsValidMermaid,
      extractFilePathsFromMarkdown,
      loadFixture,
      createProjectFromFixture
    } from './test.util.js';

    describe('Test Utilities', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('File System Utilities', () => {
        it('should create and cleanup temporary directories', async () => {
          expect(tempDir).toBeDefined();
          expect(tempDir).toContain('repograph-test-');
        });

        it('should create test files', async () => {
          const files = {
            'src/index.ts': 'export const test = true;',
            'README.md': '# Test Project'
          };

          await createTestFiles(tempDir, files);
          const allFiles = await readAllFiles(tempDir);

          expect(allFiles.length).toBe(2);
          expect(allFiles.find(f => f.path === 'src/index.ts')?.content).toBe('export const test = true;');
          expect(allFiles.find(f => f.path === 'README.md')?.content).toBe('# Test Project');
        });

        it('should create gitignore files', async () => {
          await createGitignore(tempDir, ['node_modules/', '*.log']);
          const allFiles = await readAllFiles(tempDir);

          const gitignoreFile = allFiles.find(f => f.path === '.gitignore');
          expect(gitignoreFile).toBeDefined();
          expect(gitignoreFile?.content).toContain('node_modules/');
          expect(gitignoreFile?.content).toContain('*.log');
        });
      });

      describe('Validation Utilities', () => {
        it('should validate markdown content', () => {
          const validMarkdown = '# Title\n\nThis is valid markdown.';
          const invalidMarkdown = 'Just plain text without headers';

          expect(isValidMarkdown(validMarkdown)).toBe(true);
          expect(isValidMarkdown(invalidMarkdown)).toBe(false);
        });

        it('should detect valid Mermaid graphs', () => {
          const withMermaid = '# Title\n\n```mermaid\ngraph TD\nA --> B\n```';
          const withoutMermaid = '# Title\n\nJust regular markdown.';

          expect(containsValidMermaid(withMermaid)).toBe(true);
          expect(containsValidMermaid(withoutMermaid)).toBe(false);
        });

        it('should extract file paths from markdown', () => {
          const markdown = `
    # Project
    Files: \`src/index.ts\`, \`lib/utils.js\`, and \`README.md\`.
    Also \`src/components/Button.tsx\`.
          `;

          const paths = extractFilePathsFromMarkdown(markdown);
          expect(paths).toContain('src/index.ts');
          expect(paths).toContain('lib/utils.js');
          expect(paths).toContain('src/components/Button.tsx');
          expect(paths).not.toContain('README.md'); // Not a .ts/.js file
        });
      });

      describe('Fixture Utilities', () => {
        it('should load sample-project fixture', async () => {
          const fixture = await loadFixture('sample-project');

          expect(fixture.name).toBe('Sample TypeScript Project');
          expect(fixture.files).toBeDefined();
          expect(fixture.files.length).toBeGreaterThan(0);
          expect(fixture.expected_nodes).toBeDefined();
          expect(fixture.expected_files).toBeDefined();
        });

        it('should create project from fixture', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const allFiles = await readAllFiles(tempDir);
          expect(allFiles.length).toBe(fixture.files.length);

          const mainFile = allFiles.find(f => f.path === 'src/main.ts');
          expect(mainFile).toBeDefined();
          expect(mainFile?.content).toContain('export function hello()');
        });

        it('should handle fixture with gitignore', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const allFiles = await readAllFiles(tempDir);
          const gitignoreFile = allFiles.find(f => f.path === '.gitignore');

          expect(gitignoreFile).toBeDefined();
          expect(gitignoreFile?.content).toContain('node_modules');
          expect(gitignoreFile?.content).toContain('tests/**');
        });
      });

      describe('Edge Cases', () => {
        it('should handle empty directories', async () => {
          const allFiles = await readAllFiles(tempDir);
          expect(allFiles.length).toBe(0);
        });

        it('should handle nested directory structures', async () => {
          const files = {
            'src/components/ui/Button.tsx': 'export const Button = () => {};',
            'src/utils/helpers/format.ts': 'export const format = () => {};',
            'docs/api/endpoints.md': '# API Endpoints'
          };

          await createTestFiles(tempDir, files);
          const allFiles = await readAllFiles(tempDir);

          expect(allFiles.length).toBe(3);
          expect(allFiles.find(f => f.path === 'src/components/ui/Button.tsx')).toBeDefined();
          expect(allFiles.find(f => f.path === 'src/utils/helpers/format.ts')).toBeDefined();
          expect(allFiles.find(f => f.path === 'docs/api/endpoints.md')).toBeDefined();
        });

        it('should normalize file paths consistently', async () => {
          const files = {
            'src\\windows\\style\\path.ts': 'export const test = true;'
          };

          await createTestFiles(tempDir, files);
          const allFiles = await readAllFiles(tempDir);

          // Should normalize to forward slashes
          expect(allFiles[0].path).toBe('src/windows/style/path.ts');
        });
      });
    });
  test/test.util.ts: >-
    import fs from 'node:fs/promises';

    import path from 'node:path';

    import { tmpdir } from 'node:os';

    import yaml from 'js-yaml';

    import type { FileContent } from '../src/types.js';


    /**
     * Test utilities for RepoGraph testing
     */

    /**
     * Creates a temporary directory for testing
     */
    export const createTempDir = async (): Promise<string> => {
      const tempDir = await fs.mkdtemp(path.join(tmpdir(), 'repograph-test-'));
      return tempDir;
    };


    /**
     * Cleans up a temporary directory
     */
    export const cleanupTempDir = async (dir: string): Promise<void> => {
      try {
        await fs.rm(dir, { recursive: true, force: true });
      } catch (error) {
        // Ignore cleanup errors
      }
    };


    /**
     * Creates a test file structure in a directory
     */
    export const createTestFiles = async (
      baseDir: string,
      files: Record<string, string>
    ): Promise<void> => {
      for (const [filePath, content] of Object.entries(files)) {
        const fullPath = path.join(baseDir, filePath);
        await fs.mkdir(path.dirname(fullPath), { recursive: true });
        await fs.writeFile(fullPath, content);
      }
    };


    /**
     * Creates a .gitignore file in the specified directory
     */
    export const createGitignore = async (
      baseDir: string,
      patterns: string[]
    ): Promise<void> => {
      const gitignorePath = path.join(baseDir, '.gitignore');
      await fs.writeFile(gitignorePath, patterns.join('\n'));
    };


    /**
     * Reads all files in a directory recursively
     */
    export const readAllFiles = async (dir: string): Promise<FileContent[]> => {
      const files: FileContent[] = [];
      
      const readDir = async (currentDir: string, relativePath = ''): Promise<void> => {
        const entries = await fs.readdir(currentDir, { withFileTypes: true });
        
        for (const entry of entries) {
          const entryPath = path.join(currentDir, entry.name);
          const relativeEntryPath = path.join(relativePath, entry.name);
          
          if (entry.isDirectory()) {
            await readDir(entryPath, relativeEntryPath);
          } else if (entry.isFile()) {
            try {
              const content = await fs.readFile(entryPath, 'utf-8');
              files.push({
                path: relativeEntryPath.replace(/\\/g, '/'), // Normalize path separators
                content
              });
            } catch {
              // Skip files that can't be read
            }
          }
        }
      };
      
      await readDir(dir);
      return files;
    };


    /**
     * Creates sample TypeScript files for testing
     */
    export const createSampleTSFiles = (): Record<string, string> => {
      return {
        'src/index.ts': `export { Calculator } from './calculator.js';
    export { Logger } from './utils/logger.js';`,
        
        'src/calculator.ts': `import { Logger } from './utils/logger.js';

    export class Calculator {
      private logger: Logger;
      
      constructor() {
        this.logger = new Logger();
      }
      
      add(a: number, b: number): number {
        this.logger.log('Adding numbers');
        return a + b;
      }
      
      multiply = (a: number, b: number): number => {
        return a * b;
      };
    }`,
        
        'src/utils/logger.ts': `export interface LogLevel {
      level: 'info' | 'warn' | 'error';
    }


    export type LogMessage = string;


    export class Logger {
      log(message: LogMessage): void {
        console.log(message);
      }
      
      warn(message: LogMessage): void {
        console.warn(message);
      }
    }


    export const createLogger = (): Logger => {
      return new Logger();
    };`,
        
        'src/types.ts': `export interface Config {
      debug: boolean;
      version: string;
    }


    export type Status = 'active' | 'inactive';`,
        
        'README.md': '# Test Project\n\nThis is a test project.',
        
        'package.json': JSON.stringify({
          name: 'test-project',
          version: '1.0.0',
          type: 'module'
        }, null, 2)
      };
    };


    /**
     * Creates a minimal test project structure
     */
    export const createMinimalProject = (): Record<string, string> => {
      return {
        'src/main.ts': `export function hello(): string {
      return 'Hello, World!';
    }`,
        'package.json': JSON.stringify({
          name: 'minimal-project',
          version: '1.0.0'
        }, null, 2)
      };
    };


    /**
     * Asserts that a file exists
     */
    export const assertFileExists = async (filePath: string): Promise<void> => {
      try {
        await fs.access(filePath);
      } catch {
        throw new Error(`File does not exist: ${filePath}`);
      }
    };


    /**
     * Reads a file and returns its content
     */
    export const readFile = async (filePath: string): Promise<string> => {
      return await fs.readFile(filePath, 'utf-8');
    };


    /**
     * Checks if a directory exists
     */
    export const directoryExists = async (dirPath: string): Promise<boolean> =>
    {
      try {
        const stat = await fs.stat(dirPath);
        return stat.isDirectory();
      } catch {
        return false;
      }
    };


    /**
     * Creates a symbolic link for testing
     */
    export const createSymlink = async (target: string, linkPath: string):
    Promise<void> => {
      try {
        await fs.symlink(target, linkPath);
      } catch {
        // Ignore symlink creation errors (may not be supported on all platforms)
      }
    };


    /**
     * Validates that a string contains valid Markdown
     */
    export const isValidMarkdown = (content: string): boolean => {
      // Basic markdown validation - check for common markdown patterns
      const hasHeaders = /^#{1,6}\s+.+$/m.test(content);
      const hasContent = content.trim().length > 0;
      return hasHeaders && hasContent;
    };


    /**
     * Validates that a string contains valid Mermaid syntax
     */
    export const containsValidMermaid = (content: string): boolean => {
      return content.includes('```mermaid') && content.includes('graph TD');
    };


    /**
     * Extracts file paths from markdown content
     */
    export const extractFilePathsFromMarkdown = (content: string): string[] => {
      const pathRegex = /`([^`]+\.(ts|js|tsx|jsx))`/g;
      const paths: string[] = [];
      let match;
      
      while ((match = pathRegex.exec(content)) !== null) {
        paths.push(match[1]);
      }
      
      return paths;
    };


    /**
     * Test fixture structure
     */
    export interface TestFixture {
      name: string;
      description: string;
      files: Array<{
        path: string;
        content: string;
      }>;
      gitignore?: string[];
      expected_nodes?: number;
      expected_files?: number;
      expected_symbols?: number;
    }


    /**
     * Loads a test fixture from a YAML file
     */
    export const loadFixture = async (fixtureName: string): Promise<TestFixture>
    => {
      // Get the correct path relative to the project root
      const projectRoot = process.cwd().endsWith('/test') ? path.dirname(process.cwd()) : process.cwd();
      const fixturePath = path.join(projectRoot, 'test', 'fixtures', `${fixtureName}.yaml`);
      const content = await fs.readFile(fixturePath, 'utf-8');
      return yaml.load(content) as TestFixture;
    };


    /**
     * Creates a test project from a fixture
     */
    export const createProjectFromFixture = async (
      baseDir: string,
      fixture: TestFixture
    ): Promise<void> => {
      // Create files
      const fileMap: Record<string, string> = {};
      for (const file of fixture.files) {
        fileMap[file.path] = file.content;
      }
      await createTestFiles(baseDir, fileMap);
      
      // Create .gitignore if specified
      if (fixture.gitignore && fixture.gitignore.length > 0) {
        await createGitignore(baseDir, fixture.gitignore);
      }
    };
  test/unit/analyze.test.ts: |-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
    import type { FileContent, CodeNode, CodeGraph } from '../../src/types.js';
    import {
      createTempDir,
      cleanupTempDir,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';

    describe('Tree-sitter Analysis', () => {
      let tempDir: string;
      let analyzer: ReturnType<typeof createTreeSitterAnalyzer>;

      beforeEach(async () => {
        tempDir = await createTempDir();
        analyzer = createTreeSitterAnalyzer();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createTreeSitterAnalyzer()', () => {
        it('should return an Analyzer function', () => {
          expect(typeof analyzer).toBe('function');
        });

        it('should create a CodeGraph from file content', async () => {
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `export function hello(): string {
      return 'Hello, World!';
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph).toBeDefined();
          expect(graph.order).toBeGreaterThan(0); // Should have nodes
        });

        it('should add file nodes to the graph', async () => {
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: 'export const hello = "world";'
            },
            {
              path: 'src/utils.ts',
              content: 'export const util = () => {};'
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasNode('src/index.ts')).toBe(true);
          expect(graph.hasNode('src/utils.ts')).toBe(true);

          const indexNode = graph.getNodeAttributes('src/index.ts');
          expect(indexNode.type).toBe('file');
          expect(indexNode.name).toBe('index.ts');
          expect(indexNode.filePath).toBe('src/index.ts');
        });

        it('should identify function declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/functions.ts',
              content: `export function add(a: number, b: number): number {
      return a + b;
    }

    export function multiply(x: number, y: number): number {
      return x * y;
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasNode('src/functions.ts#add')).toBe(true);
          expect(graph.hasNode('src/functions.ts#multiply')).toBe(true);

          const addNode = graph.getNodeAttributes('src/functions.ts#add');
          expect(addNode.type).toBe('function');
          expect(addNode.name).toBe('add');
          expect(addNode.filePath).toBe('src/functions.ts');
          expect(addNode.startLine).toBeGreaterThan(0);
        });

        it('should identify arrow function declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/arrows.ts',
              content: `export const greet = (name: string): string => {
      return \`Hello, \${name}!\`;
    };

    const calculate = (x: number, y: number): number => x + y;`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasNode('src/arrows.ts#greet')).toBe(true);
          expect(graph.hasNode('src/arrows.ts#calculate')).toBe(true);

          const greetNode = graph.getNodeAttributes('src/arrows.ts#greet');
          expect(greetNode.type).toBe('arrow_function');
          expect(greetNode.name).toBe('greet');
        });

        it('should identify class declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/classes.ts',
              content: `export class Calculator {
      private value: number = 0;
      
      add(n: number): this {
        this.value += n;
        return this;
      }
    }

    class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasNode('src/classes.ts#Calculator')).toBe(true);
          expect(graph.hasNode('src/classes.ts#Logger')).toBe(true);

          const calculatorNode = graph.getNodeAttributes('src/classes.ts#Calculator');
          expect(calculatorNode.type).toBe('class');
          expect(calculatorNode.name).toBe('Calculator');
          expect(calculatorNode.codeSnippet).toContain('export class Calculator');
        });

        it('should identify interface declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/interfaces.ts',
              content: `export interface User {
      id: number;
      name: string;
      email: string;
    }

    interface Config {
      debug: boolean;
      version: string;
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasNode('src/interfaces.ts#User')).toBe(true);
          expect(graph.hasNode('src/interfaces.ts#Config')).toBe(true);

          const userNode = graph.getNodeAttributes('src/interfaces.ts#User');
          expect(userNode.type).toBe('interface');
          expect(userNode.name).toBe('User');
        });

        it('should identify type alias declarations', async () => {
          const files: FileContent[] = [
            {
              path: 'src/types.ts',
              content: `export type Status = 'active' | 'inactive' | 'pending';

    type Handler = (event: Event) => void;

    export type UserRole = 'admin' | 'user' | 'guest';`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasNode('src/types.ts#Status')).toBe(true);
          expect(graph.hasNode('src/types.ts#Handler')).toBe(true);
          expect(graph.hasNode('src/types.ts#UserRole')).toBe(true);

          const statusNode = graph.getNodeAttributes('src/types.ts#Status');
          expect(statusNode.type).toBe('type');
          expect(statusNode.name).toBe('Status');
        });

        it('should identify import statements and create edges', async () => {
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';
    import { Logger } from './utils/logger.js';

    export { Calculator, Logger };`
            },
            {
              path: 'src/calculator.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
    }`
            },
            {
              path: 'src/utils/logger.ts',
              content: `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          // Check if import edges exist
          expect(graph.hasEdge('src/index.ts', 'src/calculator.ts')).toBe(true);
          expect(graph.hasEdge('src/index.ts', 'src/utils/logger.ts')).toBe(true);
        });

        it('should create edges from files to their symbols', async () => {
          const files: FileContent[] = [
            {
              path: 'src/example.ts',
              content: `export class Example {
      method(): void {}
    }

    export function helper(): string {
      return 'help';
    }`
            }
          ];

          const graph = await analyzer(files);

          // Check if contains edges exist
          expect(graph.hasEdge('src/example.ts', 'src/example.ts#Example')).toBe(true);
          expect(graph.hasEdge('src/example.ts', 'src/example.ts#helper')).toBe(true);
        });

        it('should handle files with no symbols gracefully', async () => {
          const files: FileContent[] = [
            {
              path: 'README.md',
              content: '# Project\n\nThis is a readme file.'
            },
            {
              path: 'src/empty.ts',
              content: '// This file is empty\n'
            }
          ];

          const graph = await analyzer(files);

          // Should still create file nodes
          expect(graph.hasNode('README.md')).toBe(true);
          expect(graph.hasNode('src/empty.ts')).toBe(true);

          const readmeNode = graph.getNodeAttributes('README.md');
          expect(readmeNode.type).toBe('file');
        });

        it('should handle malformed or unparseable files gracefully', async () => {
          const files: FileContent[] = [
            {
              path: 'src/valid.ts',
              content: 'export const valid = true;'
            },
            {
              path: 'src/invalid.ts',
              content: 'this is not valid typescript syntax {'
            }
          ];

          const graph = await analyzer(files);

          // Should still create file nodes for both
          expect(graph.hasNode('src/valid.ts')).toBe(true);
          expect(graph.hasNode('src/invalid.ts')).toBe(true);
        });

        it('should set correct line numbers for symbols', async () => {
          const files: FileContent[] = [
            {
              path: 'src/multiline.ts',
              content: `// Line 1
    // Line 2
    export class FirstClass {
      // Line 4
      method(): void {}
    }

    // Line 8
    export function secondFunction(): string {
      return 'hello';
    }

    // Line 13
    export interface ThirdInterface {
      prop: string;
    }`
            }
          ];

          const graph = await analyzer(files);

          const firstClass = graph.getNodeAttributes('src/multiline.ts#FirstClass');
          const secondFunction = graph.getNodeAttributes('src/multiline.ts#secondFunction');
          const thirdInterface = graph.getNodeAttributes('src/multiline.ts#ThirdInterface');

          expect(firstClass.startLine).toBe(3);
          expect(secondFunction.startLine).toBe(9);
          expect(thirdInterface.startLine).toBe(14);

          expect(firstClass.endLine).toBeGreaterThan(firstClass.startLine);
          expect(secondFunction.endLine).toBeGreaterThan(secondFunction.startLine);
          expect(thirdInterface.endLine).toBeGreaterThan(thirdInterface.startLine);
        });

        it('should include code snippets for symbols', async () => {
          const files: FileContent[] = [
            {
              path: 'src/snippets.ts',
              content: `export class Calculator {
      private value: number = 0;
      
      add(n: number): this {
        this.value += n;
        return this;
      }
    }

    export function multiply(a: number, b: number): number {
      return a * b;
    }`
            }
          ];

          const graph = await analyzer(files);

          const calculatorNode = graph.getNodeAttributes('src/snippets.ts#Calculator');
          const multiplyNode = graph.getNodeAttributes('src/snippets.ts#multiply');

          expect(calculatorNode.codeSnippet).toContain('export class Calculator');
          expect(multiplyNode.codeSnippet).toContain('export function multiply(a: number, b: number): number');
        });

        it('should handle complex import patterns', async () => {
          const files: FileContent[] = [
            {
              path: 'src/imports.ts',
              content: `import { Calculator } from './math/calculator.js';
    import * as utils from './utils.js';
    import type { Config } from './config.js';
    import Logger, { LogLevel } from './logger.js';`
            },
            {
              path: 'src/math/calculator.ts',
              content: 'export class Calculator {}'
            },
            {
              path: 'src/utils.ts',
              content: 'export const helper = () => {};'
            },
            {
              path: 'src/config.ts',
              content: 'export interface Config {}'
            },
            {
              path: 'src/logger.ts',
              content: 'export default class Logger {}'
            }
          ];

          const graph = await analyzer(files);

          // Check import edges
          expect(graph.hasEdge('src/imports.ts', 'src/math/calculator.ts')).toBe(true);
          expect(graph.hasEdge('src/imports.ts', 'src/utils.ts')).toBe(true);
          expect(graph.hasEdge('src/imports.ts', 'src/config.ts')).toBe(true);
          expect(graph.hasEdge('src/imports.ts', 'src/logger.ts')).toBe(true);
        });

        it('should handle nested class and function definitions', async () => {
          const files: FileContent[] = [
            {
              path: 'src/nested.ts',
              content: `export class OuterClass {
      private inner = class InnerClass {
        method(): void {}
      };
      
      outerMethod(): void {
        function nestedFunction(): string {
          return 'nested';
        }
        nestedFunction();
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          // Should identify the outer class
          expect(graph.hasNode('src/nested.ts#OuterClass')).toBe(true);
          
          const outerClass = graph.getNodeAttributes('src/nested.ts#OuterClass');
          expect(outerClass.type).toBe('class');
          expect(outerClass.name).toBe('OuterClass');
        });
      });

      describe('Graph Structure', () => {
        it('should create a directed graph', async () => {
          const files: FileContent[] = [
            {
              path: 'src/test.ts',
              content: 'export const test = true;'
            }
          ];

          const graph = await analyzer(files);

          expect(graph.type).toBe('directed');
          expect(graph.multi).toBe(true);
          expect(graph.allowSelfLoops).toBe(false);
        });

        it('should not create duplicate nodes for the same symbol', async () => {
          const files: FileContent[] = [
            {
              path: 'src/duplicate.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
    }

    // This should not create a duplicate
    export class Calculator {
      multiply(a: number, b: number): number {
        return a * b;
      }
    }`
            }
          ];

          const graph = await analyzer(files);

          // Should only have one Calculator node (first one wins)
          const calculatorNodes = graph.filterNodes((nodeId) => 
            nodeId.includes('#Calculator')
          );
          expect(calculatorNodes.length).toBe(1);
        });

        it('should handle circular imports gracefully', async () => {
          const files: FileContent[] = [
            {
              path: 'src/a.ts',
              content: `import { B } from './b.js';
    export class A {
      b: B;
    }`
            },
            {
              path: 'src/b.ts',
              content: `import { A } from './a.js';
    export class B {
      a: A;
    }`
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasEdge('src/a.ts', 'src/b.ts')).toBe(true);
          expect(graph.hasEdge('src/b.ts', 'src/a.ts')).toBe(true);
          expect(graph.hasNode('src/a.ts#A')).toBe(true);
          expect(graph.hasNode('src/b.ts#B')).toBe(true);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should analyze sample-project fixture correctly', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);

          expect(graph.order).toBe(fixture.expected_nodes);
          
          // Check for specific symbols from the fixture
          expect(graph.hasNode('src/calculator.ts#Calculator')).toBe(true);
          expect(graph.hasNode('src/utils/logger.ts#Logger')).toBe(true);
          expect(graph.hasNode('src/types.ts#Config')).toBe(true);
        });

        it('should analyze complex-project fixture correctly', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts') && !file.path.includes('test')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);

          // Check for key classes and interfaces
          expect(graph.hasNode('src/database/index.ts#Database')).toBe(true);
          expect(graph.hasNode('src/api/server.ts#ApiServer')).toBe(true);
          expect(graph.hasNode('src/services/user.ts#UserService')).toBe(true);
          
          // Check for import relationships
          expect(graph.hasEdge('src/api/server.ts', 'src/database/index.ts')).toBe(true);
          expect(graph.hasEdge('src/api/server.ts', 'src/services/user.ts')).toBe(true);
        });

        it('should handle minimal-project fixture', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const files: FileContent[] = [
            {
              path: 'src/main.ts',
              content: fixture.files[0].content
            }
          ];

          const graph = await analyzer(files);

          expect(graph.hasNode('src/main.ts')).toBe(true);
          expect(graph.hasNode('src/main.ts#hello')).toBe(true);
          expect(graph.hasNode('src/main.ts#greet')).toBe(true);

          const helloNode = graph.getNodeAttributes('src/main.ts#hello');
          const greetNode = graph.getNodeAttributes('src/main.ts#greet');

          expect(helloNode.type).toBe('function');
          expect(greetNode.type).toBe('arrow_function');
        });
      });
    });
  test/unit/composer.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMapGenerator } from '../../src/composer.js';

    import { createDefaultDiscoverer } from '../../src/pipeline/discover.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import type { FileDiscoverer, Analyzer, Ranker, Renderer,
    MapGeneratorOptions } from '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      assertFileExists,
      readFile,
      isValidMarkdown
    } from '../test.util.js';

    import path from 'node:path';


    describe('Composer', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMapGenerator()', () => {
        it('should return a function when given valid components', () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          expect(typeof generator).toBe('function');
        });

        it('should require all four components', () => {
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker()
            // Missing render
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            // Missing rank
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            // Missing analyze
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            // Missing discover
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();
        });

        it('should execute the full pipeline with default components', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Example');
        });

        it('should pass options through the pipeline correctly', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;',
            'src/test.spec.ts': 'test code'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'filtered.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts'],
            ignore: ['**/*.spec.ts']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/index.js');
          expect(content).not.toContain('src/test.spec.ts');
        });

        it('should pass renderer options correctly', async () => {
          const files = {
            'src/index.ts': `export class Test {
      method(): void {}
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath,
            rendererOptions: {
              customHeader: '# Custom Project',
              includeMermaidGraph: false,
              includeSymbolDetails: false
            }
          });

          const content = await readFile(outputPath);
          expect(content).toStartWith('# Custom Project');
          expect(content).not.toContain('```mermaid');
          expect(content).not.toContain('## 📂 File & Symbol Breakdown');
        });

        it('should create output directory if it does not exist', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'nested', 'deep', 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should handle empty projects gracefully', async () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'empty.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });
      });

      describe('Custom Components', () => {
        it('should work with custom discoverer', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer that only finds .js files
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            const allFiles = await defaultDiscoverer(options);
            return allFiles.filter(file => file.path.endsWith('.js'));
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'js-only.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.js');
          expect(content).not.toContain('src/index.ts');
        });

        it('should work with custom analyzer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          // Custom analyzer that adds extra metadata
          const customAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            const graph = await defaultAnalyzer(files);
            
            // Add custom metadata to all nodes
            graph.forEachNode((nodeId) => {
              const attrs = graph.getNodeAttributes(nodeId);
              graph.setNodeAttribute(nodeId, 'customMetadata', 'processed by custom analyzer');
            });
            
            return graph;
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: customAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom-analyzed.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should work with custom ranker', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;',
            'src/c.ts': 'export const c = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom ranker that assigns alphabetical ranks
          const customRanker: Ranker = async (graph, files) => {
            const ranks = new Map<string, number>();
            const fileNodes = graph.filterNodes(nodeId => 
              graph.getNodeAttribute(nodeId, 'type') === 'file'
            );
            
            fileNodes.sort().forEach((nodeId, index) => {
              ranks.set(nodeId, 1 - (index / fileNodes.length));
            });
            
            // Set rank 0 for non-file nodes
            graph.forEachNode(nodeId => {
              if (!ranks.has(nodeId)) {
                ranks.set(nodeId, 0);
              }
            });
            
            return { graph, ranks };
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: customRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom-ranked.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          // src/a.ts should be ranked highest (alphabetically first)
          const aIndex = content.indexOf('src/a.ts');
          const bIndex = content.indexOf('src/b.ts');
          expect(aIndex).toBeLessThan(bIndex);
        });

        it('should work with custom renderer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          // Custom renderer that adds extra sections
          const customRenderer: Renderer = (rankedGraph, options) => {
            const defaultRenderer = createMarkdownRenderer();
            const baseMarkdown = defaultRenderer(rankedGraph, options);
            
            return `${baseMarkdown}\n\n## Custom Section\n\nThis was added by a custom renderer.\n\n### Statistics\n- Total nodes: ${rankedGraph.graph.order}\n- Total edges: ${rankedGraph.graph.size}`;
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'custom-rendered.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('## Custom Section');
          expect(content).toContain('This was added by a custom renderer');
          expect(content).toContain('### Statistics');
          expect(content).toContain('Total nodes:');
          expect(content).toContain('Total edges:');
        });

        it('should work with all custom components', async () => {
          const files = {
            'custom.special': 'special file content',
            'src/index.ts': 'export const normal = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer for .special files
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            const defaultFiles = await defaultDiscoverer(options);
            
            // Add special files
            const specialFiles = defaultFiles.filter(f => f.path.endsWith('.special'));
            return [...defaultFiles, ...specialFiles];
          };

          // Custom analyzer that handles .special files
          const customAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            const graph = await defaultAnalyzer(files.filter(f => !f.path.endsWith('.special')));
            
            // Add special file nodes
            files.filter(f => f.path.endsWith('.special')).forEach(file => {
              graph.addNode(file.path, {
                id: file.path,
                type: 'special',
                name: path.basename(file.path),
                filePath: file.path,
                startLine: 1,
                endLine: 1
              });
            });
            
            return graph;
          };

          // Custom ranker that gives special files high rank
          const customRanker: Ranker = async (graph, files) => {
            const ranks = new Map<string, number>();
            
            graph.forEachNode(nodeId => {
              const nodeType = graph.getNodeAttribute(nodeId, 'type');
              if (nodeType === 'special') {
                ranks.set(nodeId, 1.0);
              } else {
                ranks.set(nodeId, 0.5);
              }
            });
            
            return { graph, ranks };
          };

          // Custom renderer that handles special files
          const customRenderer: Renderer = (rankedGraph, options) => {
            const specialNodes = rankedGraph.graph.filterNodes(nodeId =>
              rankedGraph.graph.getNodeAttribute(nodeId, 'type') === 'special'
            );
            
            let markdown = '# Custom Project with Special Files\n\n';
            
            if (specialNodes.length > 0) {
              markdown += '## Special Files\n\n';
              specialNodes.forEach(nodeId => {
                const node = rankedGraph.graph.getNodeAttributes(nodeId);
                markdown += `- **${node.name}** (rank: ${rankedGraph.ranks.get(nodeId)?.toFixed(2)})\n`;
              });
              markdown += '\n';
            }
            
            const defaultRenderer = createMarkdownRenderer();
            const baseMarkdown = defaultRenderer(rankedGraph, options);
            
            return markdown + baseMarkdown.split('\n').slice(2).join('\n'); // Remove default header
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: customAnalyzer,
            rank: customRanker,
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'all-custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('# Custom Project with Special Files');
          expect(content).toContain('## Special Files');
          expect(content).toContain('custom.special');
        });
      });

      describe('Error Handling', () => {
        it('should handle discoverer errors gracefully', async () => {
          const errorDiscoverer: FileDiscoverer = async () => {
            throw new Error('Discoverer failed');
          };

          const generator = createMapGenerator({
            discover: errorDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Discoverer failed');
        });

        it('should handle analyzer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorAnalyzer: Analyzer = async () => {
            throw new Error('Analyzer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: errorAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Analyzer failed');
        });

        it('should handle ranker errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRanker: Ranker = async () => {
            throw new Error('Ranker failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: errorRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Ranker failed');
        });

        it('should handle renderer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRenderer: Renderer = () => {
            throw new Error('Renderer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: errorRenderer
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Renderer failed');
        });

        it('should handle file write errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          // Try to write to an invalid path
          const invalidOutputPath = '/root/cannot-write.md';
          
          await expect(generator({
            root: tempDir,
            output: invalidOutputPath
          })).rejects.toThrow();
        });
      });

      describe('Component Interface Validation', () => {
        it('should validate discoverer interface', () => {
          const invalidDiscoverer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: invalidDiscoverer as any,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate analyzer interface', () => {
          const invalidAnalyzer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: invalidAnalyzer as any,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate ranker interface', () => {
          const invalidRanker = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: invalidRanker as any,
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate renderer interface', () => {
          const invalidRenderer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: invalidRenderer as any
          })).toThrow();
        });
      });

      describe('Pipeline Data Flow', () => {
        it('should pass files from discoverer to analyzer', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;'
          };
          await createTestFiles(tempDir, files);

          let discoveredFiles: any[] = [];
          let analyzedFiles: any[] = [];

          const trackingDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            discoveredFiles = await defaultDiscoverer(options);
            return discoveredFiles;
          };

          const trackingAnalyzer: Analyzer = async (files) => {
            analyzedFiles = files;
            const defaultAnalyzer = createTreeSitterAnalyzer();
            return await defaultAnalyzer(files);
          };

          const generator = createMapGenerator({
            discover: trackingDiscoverer,
            analyze: trackingAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(discoveredFiles.length).toBe(2);
          expect(analyzedFiles.length).toBe(2);
          expect(analyzedFiles).toEqual(discoveredFiles);
        });

        it('should pass graph from analyzer to ranker', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let analyzedGraph: any;
          let rankedGraph: any;

          const trackingAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            analyzedGraph = await defaultAnalyzer(files);
            return analyzedGraph;
          };

          const trackingRanker: Ranker = async (graph, files) => {
            rankedGraph = graph;
            const defaultRanker = createPageRanker();
            return await defaultRanker(graph, files);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: trackingAnalyzer,
            rank: trackingRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rankedGraph).toBe(analyzedGraph);
        });

        it('should pass ranked graph from ranker to renderer', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let rankerOutput: any;
          let rendererInput: any;

          const trackingRanker: Ranker = async (graph, files) => {
            const defaultRanker = createPageRanker();
            rankerOutput = await defaultRanker(graph, files);
            return rankerOutput;
          };

          const trackingRenderer: Renderer = (rankedGraph, options) => {
            rendererInput = rankedGraph;
            const defaultRenderer = createMarkdownRenderer();
            return defaultRenderer(rankedGraph, options);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: trackingRanker,
            render: trackingRenderer
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rendererInput).toBe(rankerOutput);
        });
      });
    });
  test/unit/discover.test.ts: |-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
    import { createDefaultDiscoverer } from '../../src/pipeline/discover.js';
    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      createGitignore,
      loadFixture,
      createProjectFromFixture,
      createSymlink,
      directoryExists
    } from '../test.util.js';
    import path from 'node:path';
    import fs from 'node:fs/promises';

    describe('File Discovery', () => {
      let tempDir: string;
      let discoverer: ReturnType<typeof createDefaultDiscoverer>;

      beforeEach(async () => {
        tempDir = await createTempDir();
        discoverer = createDefaultDiscoverer();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createDefaultDiscoverer()', () => {
        it('should return a FileDiscoverer function', () => {
          expect(typeof discoverer).toBe('function');
        });

        it('should discover files using default patterns when no include patterns provided', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'src/utils.ts': 'export const util = () => {};',
            'README.md': '# Test Project'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(3);
          expect(result.map(f => f.path).sort()).toEqual([
            'README.md',
            'src/index.ts',
            'src/utils.ts'
          ]);
        });

        it('should respect custom include patterns when provided', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'src/utils.js': 'export const util = () => {};',
            'README.md': '# Test Project',
            'package.json': '{"name": "test"}'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir,
            include: ['**/*.ts']
          });

          expect(result.length).toBe(1);
          expect(result[0].path).toBe('src/index.ts');
        });

        it('should exclude files matching ignore patterns', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'src/test.spec.ts': 'test code',
            'src/utils.ts': 'export const util = () => {};'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir,
            ignore: ['**/*.spec.ts']
          });

          expect(result.length).toBe(2);
          expect(result.map(f => f.path).sort()).toEqual([
            'src/index.ts',
            'src/utils.ts'
          ]);
        });

        it('should respect .gitignore by default', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'dist/index.js': 'compiled code',
            'node_modules/package/index.js': 'dependency',
            '.env': 'SECRET=value'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['dist/', '.env']);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(1);
          expect(result[0].path).toBe('src/index.ts');
        });

        it('should ignore .gitignore when noGitignore is true', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'dist/index.js': 'compiled code',
            '.env': 'SECRET=value'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['dist/', '.env']);

          const result = await discoverer({
            root: tempDir,
            noGitignore: true
          });

          expect(result.length).toBe(3);
          expect(result.map(f => f.path).sort()).toEqual([
            '.env',
            'dist/index.js',
            'src/index.ts'
          ]);
        });

        it('should always exclude node_modules directory', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'node_modules/package/index.js': 'dependency code'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir,
            noGitignore: true
          });

          expect(result.length).toBe(1);
          expect(result[0].path).toBe('src/index.ts');
        });

        it('should handle non-existent root directory gracefully', async () => {
          const nonExistentDir = path.join(tempDir, 'non-existent');

          await expect(discoverer({
            root: nonExistentDir
          })).rejects.toThrow();
        });

        it('should filter out binary files that cannot be read', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'README.md': '# Test Project'
          };
          await createTestFiles(tempDir, files);

          // Create a binary file by writing raw bytes
          const binaryPath = path.join(tempDir, 'binary.bin');
          await fs.writeFile(binaryPath, Buffer.from([0x00, 0x01, 0x02, 0x03]));

          const result = await discoverer({
            root: tempDir
          });

          // Should only include text files
          expect(result.length).toBe(2);
          expect(result.map(f => f.path).sort()).toEqual([
            'README.md',
            'src/index.ts'
          ]);
        });

        it('should return FileContent objects with correct path and content properties', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(1);
          expect(result[0]).toHaveProperty('path');
          expect(result[0]).toHaveProperty('content');
          expect(result[0].path).toBe('src/index.ts');
          expect(result[0].content).toBe('export const hello = "world";');
        });

        it('should handle empty directories', async () => {
          // Create an empty directory structure
          await fs.mkdir(path.join(tempDir, 'empty-dir'), { recursive: true });

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(0);
        });

        it('should handle symbolic links appropriately', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'target.ts': 'export const target = true;'
          };
          await createTestFiles(tempDir, files);

          // Create a symbolic link
          const linkPath = path.join(tempDir, 'link.ts');
          const targetPath = path.join(tempDir, 'target.ts');
          await createSymlink(targetPath, linkPath);

          const result = await discoverer({
            root: tempDir
          });

          // Should include both original files and potentially the symlink
          expect(result.length).toBeGreaterThanOrEqual(2);
          const paths = result.map(f => f.path);
          expect(paths).toContain('src/index.ts');
          expect(paths).toContain('target.ts');
        });

        it('should normalize file paths consistently across platforms', async () => {
          const files = {
            'src/nested/deep/index.ts': 'export const hello = "world";'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(1);
          // Path should use forward slashes regardless of platform
          expect(result[0].path).toBe('src/nested/deep/index.ts');
        });
      });

      describe('Gitignore Integration', () => {
        it('should read .gitignore file when present', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'build/output.js': 'compiled code',
            'logs/app.log': 'log content'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['build/', 'logs/']);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(1);
          expect(result[0].path).toBe('src/index.ts');
        });

        it('should handle missing .gitignore file gracefully', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(1);
          expect(result[0].path).toBe('src/index.ts');
        });

        it('should combine .gitignore patterns with ignore option', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'build/output.js': 'compiled code',
            'test/spec.ts': 'test code',
            'docs/readme.md': 'documentation'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['build/']);

          const result = await discoverer({
            root: tempDir,
            ignore: ['test/', 'docs/']
          });

          expect(result.length).toBe(1);
          expect(result[0].path).toBe('src/index.ts');
        });

        it('should handle complex .gitignore patterns', async () => {
          const files = {
            'src/index.ts': 'export const hello = "world";',
            'src/temp.tmp': 'temporary file',
            'config/dev.env': 'dev config',
            'config/prod.env': 'prod config',
            'logs/2023.log': 'old log',
            'logs/current.log': 'current log'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, [
            '*.tmp',
            '*.env',
            'logs/*.log',
            '!logs/current.log'
          ]);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(2);
          const paths = result.map(f => f.path).sort();
          expect(paths).toEqual(['logs/current.log', 'src/index.ts']);
        });
      });

      describe('Pattern Matching', () => {
        it('should support glob patterns in include option', async () => {
          const files = {
            'src/index.ts': 'typescript',
            'src/utils.js': 'javascript',
            'tests/spec.ts': 'test typescript',
            'docs/readme.md': 'markdown'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir,
            include: ['src/**/*.ts', 'tests/**/*.ts']
          });

          expect(result.length).toBe(2);
          const paths = result.map(f => f.path).sort();
          expect(paths).toEqual(['src/index.ts', 'tests/spec.ts']);
        });

        it('should support glob patterns in ignore option', async () => {
          const files = {
            'src/index.ts': 'typescript',
            'src/test.spec.ts': 'test file',
            'src/utils.test.ts': 'test file',
            'src/helper.ts': 'helper file'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir,
            ignore: ['**/*.spec.ts', '**/*.test.ts']
          });

          expect(result.length).toBe(2);
          const paths = result.map(f => f.path).sort();
          expect(paths).toEqual(['src/helper.ts', 'src/index.ts']);
        });

        it('should handle dot files correctly', async () => {
          const files = {
            'src/index.ts': 'typescript',
            '.env': 'environment',
            '.gitignore': 'git ignore',
            '.hidden/file.ts': 'hidden typescript'
          };
          await createTestFiles(tempDir, files);

          const result = await discoverer({
            root: tempDir
          });

          expect(result.length).toBe(4);
          const paths = result.map(f => f.path).sort();
          expect(paths).toEqual(['.env', '.gitignore', '.hidden/file.ts', 'src/index.ts']);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should work with sample-project fixture', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await discoverer({
            root: tempDir,
            include: ['**/*.ts']
          });

          expect(result.length).toBe(fixture.expected_files);
          
          // Verify all TypeScript files are discovered
          const tsFiles = result.filter(f => f.path.endsWith('.ts'));
          expect(tsFiles.length).toBe(fixture.expected_files);
        });

        it('should work with minimal-project fixture', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await discoverer({
            root: tempDir,
            include: ['**/*.ts']
          });

          expect(result.length).toBe(fixture.expected_files);
          expect(result[0].path).toBe('src/main.ts');
          expect(result[0].content).toContain('export function hello()');
        });

        it('should respect gitignore from complex-project fixture', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await discoverer({
            root: tempDir,
            include: ['**/*.ts']
          });

          // Should exclude test files due to gitignore
          expect(result.length).toBe(fixture.expected_files);
          const paths = result.map(f => f.path);
          expect(paths).not.toContain('tests/user.test.ts');
        });
      });
    });
  test/unit/rank.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createPageRanker, createGitRanker } from
    '../../src/pipeline/rank.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import type { FileContent, CodeGraph, RankedCodeGraph } from
    '../../src/types.js';

    import Graph from 'graphology';

    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';

    import fs from 'node:fs/promises';

    import path from 'node:path';

    import { execSync } from 'node:child_process';


    describe('Graph Ranking', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createPageRanker()', () => {
        let pageRanker: ReturnType<typeof createPageRanker>;

        beforeEach(() => {
          pageRanker = createPageRanker();
        });

        it('should return a Ranker function', () => {
          expect(typeof pageRanker).toBe('function');
        });

        it('should handle empty graphs gracefully', async () => {
          const emptyGraph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const result = await pageRanker(emptyGraph, []);

          expect(result.graph).toBe(emptyGraph);
          expect(result.ranks.size).toBe(0);
        });

        it('should assign ranks to all nodes in the graph', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          // Create a simple graph with nodes and edges
          graph.addNode('file1', {
            id: 'file1',
            type: 'file',
            name: 'file1.ts',
            filePath: 'file1.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('file2', {
            id: 'file2',
            type: 'file',
            name: 'file2.ts',
            filePath: 'file2.ts',
            startLine: 1,
            endLine: 15
          });

          graph.addNode('symbol1', {
            id: 'symbol1',
            type: 'function',
            name: 'func1',
            filePath: 'file1.ts',
            startLine: 2,
            endLine: 5
          });

          graph.addDirectedEdge('file1', 'file2', { type: 'imports' });
          graph.addDirectedEdge('file1', 'symbol1', { type: 'contains' });

          const result = await pageRanker(graph, []);

          expect(result.ranks.size).toBe(3);
          expect(result.ranks.has('file1')).toBe(true);
          expect(result.ranks.has('file2')).toBe(true);
          expect(result.ranks.has('symbol1')).toBe(true);

          // All ranks should be positive numbers
          for (const rank of result.ranks.values()) {
            expect(rank).toBeGreaterThan(0);
          }
        });

        it('should assign higher ranks to more connected nodes', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          // Create a hub node that many others connect to
          graph.addNode('hub', {
            id: 'hub',
            type: 'file',
            name: 'hub.ts',
            filePath: 'hub.ts',
            startLine: 1,
            endLine: 10
          });

          // Create several nodes that import from the hub
          for (let i = 1; i <= 5; i++) {
            const nodeId = `node${i}`;
            graph.addNode(nodeId, {
              id: nodeId,
              type: 'file',
              name: `${nodeId}.ts`,
              filePath: `${nodeId}.ts`,
              startLine: 1,
              endLine: 10
            });
            graph.addDirectedEdge(nodeId, 'hub', { type: 'imports' });
          }

          // Create an isolated node
          graph.addNode('isolated', {
            id: 'isolated',
            type: 'file',
            name: 'isolated.ts',
            filePath: 'isolated.ts',
            startLine: 1,
            endLine: 10
          });

          const result = await pageRanker(graph, []);

          const hubRank = result.ranks.get('hub')!;
          const isolatedRank = result.ranks.get('isolated')!;

          // Hub should have higher rank than isolated node
          expect(hubRank).toBeGreaterThan(isolatedRank);
        });

        it('should return RankedCodeGraph with correct structure', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('test', {
            id: 'test',
            type: 'file',
            name: 'test.ts',
            filePath: 'test.ts',
            startLine: 1,
            endLine: 10
          });

          const result = await pageRanker(graph, []);

          expect(result).toHaveProperty('graph');
          expect(result).toHaveProperty('ranks');
          expect(result.graph).toBe(graph);
          expect(result.ranks).toBeInstanceOf(Map);
        });

        it('should work with complex graph structures', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';
    import { Logger } from './logger.js';


    export { Calculator, Logger };`
            },
            {
              path: 'src/calculator.ts',
              content: `import { Logger } from './logger.js';

    export class Calculator {
      private logger: Logger;
      
      constructor() {
        this.logger = new Logger();
      }
      
      add(a: number, b: number): number {
        return a + b;
      }
    }`
            },
            {
              path: 'src/logger.ts',
              content: `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
            }
          ];

          const graph = await analyzer(files);
          const result = await pageRanker(graph, files);

          expect(result.ranks.size).toBeGreaterThan(0);
          
          // Logger should have high rank as it's imported by multiple files
          const loggerRank = result.ranks.get('src/logger.ts');
          expect(loggerRank).toBeGreaterThan(0);
        });
      });

      describe('createGitRanker()', () => {
        let gitRanker: ReturnType<typeof createGitRanker>;

        beforeEach(() => {
          gitRanker = createGitRanker();
        });

        it('should return a Ranker function', () => {
          expect(typeof gitRanker).toBe('function');
        });

        it('should handle empty graphs gracefully', async () => {
          const emptyGraph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const result = await gitRanker(emptyGraph, []);

          expect(result.graph).toBe(emptyGraph);
          expect(result.ranks.size).toBe(0);
        });

        it('should assign zero ranks when git is not available', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('file1', {
            id: 'file1',
            type: 'file',
            name: 'file1.ts',
            filePath: 'file1.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('symbol1', {
            id: 'symbol1',
            type: 'function',
            name: 'func1',
            filePath: 'file1.ts',
            startLine: 2,
            endLine: 5
          });

          // Change to a directory without git
          const originalCwd = process.cwd();
          process.chdir(tempDir);

          try {
            const result = await gitRanker(graph, []);

            expect(result.ranks.size).toBe(2);
            expect(result.ranks.get('file1')).toBe(0);
            expect(result.ranks.get('symbol1')).toBe(0);
          } finally {
            process.chdir(originalCwd);
          }
        });

        it('should only rank file nodes with git strategy', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('file1', {
            id: 'file1',
            type: 'file',
            name: 'file1.ts',
            filePath: 'file1.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('symbol1', {
            id: 'symbol1',
            type: 'function',
            name: 'func1',
            filePath: 'file1.ts',
            startLine: 2,
            endLine: 5
          });

          const result = await gitRanker(graph, []);

          // Symbol nodes should get rank 0 with git strategy
          expect(result.ranks.get('symbol1')).toBe(0);
        });

        it('should respect maxCommits option', () => {
          const customGitRanker = createGitRanker({ maxCommits: 100 });
          expect(typeof customGitRanker).toBe('function');
        });

        it('should normalize ranks between 0 and 1', async () => {
          // Create a mock git repository for testing
          await fs.mkdir(path.join(tempDir, '.git'), { recursive: true });
          await createTestFiles(tempDir, {
            'file1.ts': 'content1',
            'file2.ts': 'content2'
          });

          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('file1.ts', {
            id: 'file1.ts',
            type: 'file',
            name: 'file1.ts',
            filePath: 'file1.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('file2.ts', {
            id: 'file2.ts',
            type: 'file',
            name: 'file2.ts',
            filePath: 'file2.ts',
            startLine: 1,
            endLine: 10
          });

          const originalCwd = process.cwd();
          process.chdir(tempDir);

          try {
            // Initialize git repo and create some commits
            execSync('git init', { stdio: 'ignore' });
            execSync('git config user.email "test@example.com"', { stdio: 'ignore' });
            execSync('git config user.name "Test User"', { stdio: 'ignore' });
            execSync('git add .', { stdio: 'ignore' });
            execSync('git commit -m "Initial commit"', { stdio: 'ignore' });

            // Modify file1 more frequently
            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'modified content1');
            execSync('git add file1.ts', { stdio: 'ignore' });
            execSync('git commit -m "Update file1"', { stdio: 'ignore' });

            await fs.writeFile(path.join(tempDir, 'file1.ts'), 'modified content1 again');
            execSync('git add file1.ts', { stdio: 'ignore' });
            execSync('git commit -m "Update file1 again"', { stdio: 'ignore' });

            const result = await gitRanker(graph, []);

            // All ranks should be between 0 and 1
            for (const rank of result.ranks.values()) {
              expect(rank).toBeGreaterThanOrEqual(0);
              expect(rank).toBeLessThanOrEqual(1);
            }

            // file1.ts should have higher rank than file2.ts
            const file1Rank = result.ranks.get('file1.ts')!;
            const file2Rank = result.ranks.get('file2.ts')!;
            expect(file1Rank).toBeGreaterThan(file2Rank);

          } catch (error) {
            // Skip test if git is not available
            console.warn('Git not available, skipping git ranking test');
          } finally {
            process.chdir(originalCwd);
          }
        });
      });

      describe('Ranking Comparison', () => {
        it('should produce different rankings for PageRank vs Git strategies', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Utils } from './utils.js';
    export { Utils };`
            },
            {
              path: 'src/utils.ts',
              content: `export class Utils {
      static helper(): string {
        return 'help';
      }
    }`
            },
            {
              path: 'src/standalone.ts',
              content: `export const standalone = true;`
            }
          ];

          const graph = await analyzer(files);
          
          const pageRanker = createPageRanker();
          const gitRanker = createGitRanker();

          const pageRankResult = await pageRanker(graph, files);
          const gitRankResult = await gitRanker(graph, files);

          // Results should have same structure but potentially different ranks
          expect(pageRankResult.ranks.size).toBe(gitRankResult.ranks.size);
          
          // In PageRank, utils.ts should have high rank due to being imported
          const pageRankUtilsRank = pageRankResult.ranks.get('src/utils.ts')!;
          expect(pageRankUtilsRank).toBeGreaterThan(0);
        });

        it('should handle graphs with no edges', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          // Add isolated nodes
          graph.addNode('file1', {
            id: 'file1',
            type: 'file',
            name: 'file1.ts',
            filePath: 'file1.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('file2', {
            id: 'file2',
            type: 'file',
            name: 'file2.ts',
            filePath: 'file2.ts',
            startLine: 1,
            endLine: 10
          });

          const pageRanker = createPageRanker();
          const result = await pageRanker(graph, []);

          expect(result.ranks.size).toBe(2);
          
          // All nodes should have equal rank in a graph with no edges
          const ranks = Array.from(result.ranks.values());
          expect(ranks[0]).toBeCloseTo(ranks[1], 5);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should rank sample-project fixture correctly', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [];
          
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const pageRanker = createPageRanker();
          const result = await pageRanker(graph, files);

          expect(result.ranks.size).toBeGreaterThan(0);
          
          // Files that are imported more should have higher ranks
          const loggerRank = result.ranks.get('src/utils/logger.ts');
          const typesRank = result.ranks.get('src/types.ts');
          
          expect(loggerRank).toBeGreaterThan(0);
          expect(typesRank).toBeGreaterThan(0);
        });

        it('should rank complex-project fixture correctly', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [];
          
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts') && !file.path.includes('test')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const pageRanker = createPageRanker();
          const result = await pageRanker(graph, files);

          // Database and types should have high ranks as they're widely imported
          const databaseRank = result.ranks.get('src/database/index.ts');
          const typesRank = result.ranks.get('src/types/index.ts');
          
          expect(databaseRank).toBeGreaterThan(0);
          expect(typesRank).toBeGreaterThan(0);
        });

        it('should handle minimal-project fixture', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const files: FileContent[] = [
            {
              path: 'src/main.ts',
              content: fixture.files[0].content
            }
          ];

          const graph = await analyzer(files);
          const pageRanker = createPageRanker();
          const result = await pageRanker(graph, files);

          expect(result.ranks.size).toBe(fixture.expected_nodes);
          
          // All nodes should have positive ranks
          for (const rank of result.ranks.values()) {
            expect(rank).toBeGreaterThan(0);
          }
        });
      });

      describe('Edge Cases', () => {
        it('should handle self-referential imports', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('file1', {
            id: 'file1',
            type: 'file',
            name: 'file1.ts',
            filePath: 'file1.ts',
            startLine: 1,
            endLine: 10
          });

          // Note: self-loops are disabled in our graph configuration
          // This tests that the ranker handles this gracefully

          const pageRanker = createPageRanker();
          const result = await pageRanker(graph, []);

          expect(result.ranks.size).toBe(1);
          expect(result.ranks.get('file1')).toBeGreaterThan(0);
        });

        it('should handle very large graphs efficiently', async () => {
          const graph: CodeGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          // Create a large graph with many nodes
          const nodeCount = 1000;
          for (let i = 0; i < nodeCount; i++) {
            graph.addNode(`node${i}`, {
              id: `node${i}`,
              type: 'file',
              name: `file${i}.ts`,
              filePath: `file${i}.ts`,
              startLine: 1,
              endLine: 10
            });
          }

          // Add some edges
          for (let i = 0; i < nodeCount - 1; i++) {
            graph.addDirectedEdge(`node${i}`, `node${i + 1}`, { type: 'imports' });
          }

          const pageRanker = createPageRanker();
          const startTime = Date.now();
          const result = await pageRanker(graph, []);
          const endTime = Date.now();

          expect(result.ranks.size).toBe(nodeCount);
          expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
        });
      });
    });
  test/unit/render.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import type { FileContent, RankedCodeGraph, RendererOptions } from
    '../../src/types.js';

    import Graph from 'graphology';

    import {
      createTempDir,
      cleanupTempDir,
      isValidMarkdown,
      containsValidMermaid,
      extractFilePathsFromMarkdown,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';


    describe('Markdown Rendering', () => {
      let tempDir: string;
      let renderer: ReturnType<typeof createMarkdownRenderer>;

      beforeEach(async () => {
        tempDir = await createTempDir();
        renderer = createMarkdownRenderer();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMarkdownRenderer()', () => {
        it('should return a Renderer function', () => {
          expect(typeof renderer).toBe('function');
        });

        it('should generate valid markdown from empty graph', () => {
          const emptyGraph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const rankedGraph: RankedCodeGraph = {
            graph: emptyGraph,
            ranks: new Map()
          };

          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('# RepoGraph');
          expect(markdown).toContain('This repository contains 0 nodes (0 files)');
        });

        it('should include project overview section', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/index.ts', {
            id: 'src/index.ts',
            type: 'file',
            name: 'index.ts',
            filePath: 'src/index.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## 🚀 Project Overview');
          expect(markdown).toContain('This repository contains 1 nodes (1 files)');
          expect(markdown).toContain('_Generated by RepoGraph on');
        });

        it('should include Mermaid graph by default', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/a.ts', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### Module Dependency Graph');
          expect(containsValidMermaid(markdown)).toBe(true);
          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
        });

        it('should exclude Mermaid graph when option is false', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/index.ts', {
            id: 'src/index.ts',
            type: 'file',
            name: 'index.ts',
            filePath: 'src/index.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeMermaidGraph: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('### Module Dependency Graph');
          expect(markdown).not.toContain('```mermaid');
        });

        it('should include top 10 most important files', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const ranks = new Map<string, number>();

          // Create 15 files with different ranks
          for (let i = 1; i <= 15; i++) {
            const nodeId = `src/file${i}.ts`;
            graph.addNode(nodeId, {
              id: nodeId,
              type: 'file',
              name: `file${i}.ts`,
              filePath: nodeId,
              startLine: 1,
              endLine: 10
            });
            ranks.set(nodeId, i / 15); // Higher numbers get higher ranks
          }

          const rankedGraph: RankedCodeGraph = { graph, ranks };
          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### Top 10 Most Important Files');
          expect(markdown).toContain('| Rank | File | Description |');
          
          // Should contain the top 10 files (file15 to file6)
          expect(markdown).toContain('`src/file15.ts`');
          expect(markdown).toContain('`src/file6.ts`');
          
          // Should not contain the lower ranked files
          expect(markdown).not.toContain('`src/file1.ts`');
          expect(markdown).not.toContain('`src/file5.ts`');
        });

        it('should include symbol details by default', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 20
          });

          graph.addNode('src/test.ts#TestClass', {
            id: 'src/test.ts#TestClass',
            type: 'class',
            name: 'TestClass',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 15,
            codeSnippet: 'export class TestClass {'
          });

          graph.addNode('src/test.ts#testFunction', {
            id: 'src/test.ts#testFunction',
            type: 'function',
            name: 'testFunction',
            filePath: 'src/test.ts',
            startLine: 17,
            endLine: 19,
            codeSnippet: 'export function testFunction(): void'
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#TestClass', { type: 'contains' });
          graph.addDirectedEdge('src/test.ts', 'src/test.ts#testFunction', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#TestClass', 0.5],
              ['src/test.ts#testFunction', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## 📂 File & Symbol Breakdown');
          expect(markdown).toContain('### [`src/test.ts`](./src/test.ts)');
          expect(markdown).toContain('**`class TestClass`** - _L5_');
          expect(markdown).toContain('**`function testFunction`** - _L17_');
          expect(markdown).toContain('export class TestClass {');
          expect(markdown).toContain('export function testFunction(): void');
        });

        it('should exclude symbol details when option is false', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/test.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeSymbolDetails: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('## 📂 File & Symbol Breakdown');
        });

        it('should include custom header when provided', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map()
          };

          const customHeader = '# My Custom Project\n\nThis is a custom description.';
          const options: RendererOptions = {
            customHeader
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).toStartWith(customHeader);
          expect(markdown).not.toContain('# RepoGraph');
        });

        it('should handle files with no symbols', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('README.md', {
            id: 'README.md',
            type: 'file',
            name: 'README.md',
            filePath: 'README.md',
            startLine: 1,
            endLine: 5
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['README.md', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`README.md`](./README.md)');
          expect(markdown).toContain('_No symbols identified in this file._');
        });

        it('should sort symbols by line number', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 30
          });

          // Add symbols in non-sequential order
          graph.addNode('src/test.ts#lastFunction', {
            id: 'src/test.ts#lastFunction',
            type: 'function',
            name: 'lastFunction',
            filePath: 'src/test.ts',
            startLine: 25,
            endLine: 28
          });

          graph.addNode('src/test.ts#firstFunction', {
            id: 'src/test.ts#firstFunction',
            type: 'function',
            name: 'firstFunction',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 10
          });

          graph.addNode('src/test.ts#middleClass', {
            id: 'src/test.ts#middleClass',
            type: 'class',
            name: 'middleClass',
            filePath: 'src/test.ts',
            startLine: 15,
            endLine: 20
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#lastFunction', { type: 'contains' });
          graph.addDirectedEdge('src/test.ts', 'src/test.ts#firstFunction', { type: 'contains' });
          graph.addDirectedEdge('src/test.ts', 'src/test.ts#middleClass', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#lastFunction', 0.3],
              ['src/test.ts#firstFunction', 0.5],
              ['src/test.ts#middleClass', 0.4]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Check that symbols appear in line number order
          const firstFunctionIndex = markdown.indexOf('firstFunction');
          const middleClassIndex = markdown.indexOf('middleClass');
          const lastFunctionIndex = markdown.indexOf('lastFunction');

          expect(firstFunctionIndex).toBeLessThan(middleClassIndex);
          expect(middleClassIndex).toBeLessThan(lastFunctionIndex);
        });

        it('should sort files by rank (highest first)', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const files = [
            { id: 'src/low.ts', rank: 0.2 },
            { id: 'src/high.ts', rank: 0.8 },
            { id: 'src/medium.ts', rank: 0.5 }
          ];

          const ranks = new Map<string, number>();

          for (const file of files) {
            graph.addNode(file.id, {
              id: file.id,
              type: 'file',
              name: file.id.split('/').pop()!,
              filePath: file.id,
              startLine: 1,
              endLine: 10
            });
            ranks.set(file.id, file.rank);
          }

          const rankedGraph: RankedCodeGraph = { graph, ranks };
          const markdown = renderer(rankedGraph);

          // Check order in the file breakdown section
          const highIndex = markdown.indexOf('[`src/high.ts`]');
          const mediumIndex = markdown.indexOf('[`src/medium.ts`]');
          const lowIndex = markdown.indexOf('[`src/low.ts`]');

          expect(highIndex).toBeLessThan(mediumIndex);
          expect(mediumIndex).toBeLessThan(lowIndex);
        });

        it('should handle symbols without code snippets', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/test.ts#noSnippet', {
            id: 'src/test.ts#noSnippet',
            type: 'function',
            name: 'noSnippet',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 8
            // No codeSnippet property
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#noSnippet', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#noSnippet', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function noSnippet`** - _L5_');
          // Should not include empty code block
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });

        it('should generate proper markdown links for files', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/nested/deep/file.ts', {
            id: 'src/nested/deep/file.ts',
            type: 'file',
            name: 'file.ts',
            filePath: 'src/nested/deep/file.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/nested/deep/file.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`src/nested/deep/file.ts`](./src/nested/deep/file.ts)');
        });
      });

      describe('Mermaid Graph Generation', () => {
        it('should only include file nodes in Mermaid graph', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/a.ts#Class', {
            id: 'src/a.ts#Class',
            type: 'class',
            name: 'Class',
            filePath: 'src/a.ts',
            startLine: 2,
            endLine: 8
          });

          graph.addNode('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });
          graph.addDirectedEdge('src/a.ts', 'src/a.ts#Class', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/a.ts#Class', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
          expect(markdown).not.toContain('src/a.ts#Class');
        });

        it('should handle graphs with no file-to-file edges', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/isolated.ts', {
            id: 'src/isolated.ts',
            type: 'file',
            name: 'isolated.ts',
            filePath: 'src/isolated.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/isolated.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('```mermaid');
          expect(markdown).toContain('graph TD');
          expect(markdown).toContain('```');
        });

        it('should deduplicate edges in Mermaid graph', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          // Add multiple edges between the same files (multi-graph)
          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });
          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Should only appear once in the Mermaid graph
          const edgePattern = /src\/a\.ts\["a\.ts"\] --> src\/b\.ts\["b\.ts"\]/g;
          const matches = markdown.match(edgePattern);
          expect(matches).toHaveLength(1);
        });
      });

      describe('Integration with Real Analysis', () => {
        it('should render analyzed TypeScript code correctly', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';

    export { Calculator };


    export function main(): void {
      const calc = new Calculator();
      console.log(calc.add(1, 2));
    }`
            },
            {
              path: 'src/calculator.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
      
      subtract = (a: number, b: number): number => {
        return a - b;
      };
    }`
            }
          ];

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Calculator');
          expect(markdown).toContain('**`class Calculator`**');
          expect(markdown).toContain('**`function main`**');
          expect(markdown).toContain('**`arrow_function subtract`**');
          expect(containsValidMermaid(markdown)).toBe(true);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should render sample-project fixture correctly', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Calculator');
          expect(markdown).toContain('Logger');
          expect(markdown).toContain('Config');
          
          const filePaths = extractFilePathsFromMarkdown(markdown);
          expect(filePaths.length).toBeGreaterThan(0);
          expect(filePaths).toContain('src/calculator.ts');
          expect(filePaths).toContain('src/utils/logger.ts');
        });

        it('should render complex-project fixture correctly', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts') && !file.path.includes('test')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Database');
          expect(markdown).toContain('ApiServer');
          expect(markdown).toContain('UserService');
          expect(containsValidMermaid(markdown)).toBe(true);
        });

        it('should handle all renderer options with fixtures', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [
            {
              path: 'src/main.ts',
              content: fixture.files[0].content
            }
          ];

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);

          const options: RendererOptions = {
            customHeader: '# My Minimal Project\n\nCustom description here.',
            includeMermaidGraph: false,
            includeSymbolDetails: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).toStartWith('# My Minimal Project');
          expect(markdown).not.toContain('```mermaid');
          expect(markdown).not.toContain('## 📂 File & Symbol Breakdown');
          expect(markdown).toContain('### Top 10 Most Important Files');
        });
      });

      describe('Edge Cases', () => {
        it('should handle very long file paths', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const longPath = 'src/very/deeply/nested/directory/structure/with/many/levels/file.ts';
          graph.addNode(longPath, {
            id: longPath,
            type: 'file',
            name: 'file.ts',
            filePath: longPath,
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([[longPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`[\`${longPath}\`](./${longPath})`);
        });

        it('should handle special characters in file names', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const specialPath = 'src/file-with-dashes_and_underscores.spec.ts';
          graph.addNode(specialPath, {
            id: specialPath,
            type: 'file',
            name: 'file-with-dashes_and_underscores.spec.ts',
            filePath: specialPath,
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([[specialPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`\`${specialPath}\``);
        });

        it('should handle empty code snippets gracefully', () => {
          const graph = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/test.ts#empty', {
            id: 'src/test.ts#empty',
            type: 'function',
            name: 'empty',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 6,
            codeSnippet: ''
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#empty', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#empty', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function empty`** - _L5_');
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });
      });
    });
approved: true
