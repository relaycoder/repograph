uuid: 440263f9-ff4a-4710-8588-444749f7e4f9
projectId: repograph
createdAt: '2025-06-29T15:25:54.022Z'
gitCommitMsg: 'test(renderer): add comprehensive tests for output customization'
promptSummary: Add test cases to verify the new renderer customization options.
reasoning:
  - >-
    I've added a comprehensive suite of tests to validate the new renderer
    customization options across unit, integration, and end-to-end test suites.
  - >-
    First, I added a new `describe` block to the renderer unit tests
    (`test/unit/render.test.ts`) to check each new customization option in
    isolation. This includes verifying that sections are correctly hidden,
    custom values like `topFileCount` and `fileSectionSeparator` are respected,
    and that all `symbolDetailOptions` work as expected. I also added a test to
    ensure an empty file is generated when all render sections are disabled.
  - >-
    Second, I introduced a new "Output Customization Flags" test suite in the
    E2E tests (`test/e2e/cli.test.ts`). This suite tests all the new
    command-line flags (e.g., `--no-header`, `--no-mermaid`, `--top-file-count`)
    to ensure they are parsed correctly and produce the expected changes in the
    final Markdown output.
  - >-
    Third, I updated the integration tests for both the high-level API
    (`test/integration/high-level.test.ts`) and the core pipeline
    (`test/integration/pipeline.test.ts`). I replaced the existing, simpler
    tests for `rendererOptions` with more thorough tests that check a wide
    combination of the new options, confirming they are passed correctly through
    `generateMap` and the `createMapGenerator` pipeline. This ensures the
    options are correctly wired from the top-level API down to the renderer.
operations:
  - type: write
    path: test/unit/render.test.ts
    content: >-
      --- test/unit/render.test.ts

      +++ test/unit/render.test.ts

      @@ -282,6 +282,88 @@
             expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
           });
       
      +    describe('Renderer Customization Options', () => {

      +      let rankedGraph: RankedCodeGraph;

      +

      +      beforeEach(() => {

      +        const nodes = new Map<string, CodeNode>();

      +        const edges: CodeEdge[] = [];

      +

      +        nodes.set('src/main.ts', { id: 'src/main.ts', type: 'file', name:
      'main.ts', filePath: 'src/main.ts', startLine: 1, endLine: 10, language:
      'typescript' });

      +        nodes.set('src/utils.ts', { id: 'src/utils.ts', type: 'file',
      name: 'utils.ts', filePath: 'src/utils.ts', startLine: 1, endLine: 10,
      language: 'typescript' });

      +        nodes.set('src/main.ts#main', { id: 'src/main.ts#main', type:
      'function', name: 'main', filePath: 'src/main.ts', startLine: 2, endLine:
      5, codeSnippet: 'function main() {}' });

      +        nodes.set('src/utils.ts#helper', { id: 'src/utils.ts#helper',
      type: 'function', name: 'helper', filePath: 'src/utils.ts', startLine: 2,
      endLine: 5, codeSnippet: 'function helper() {}' });

      +        nodes.set('src/utils.ts#another', { id: 'src/utils.ts#another',
      type: 'function', name: 'another', filePath: 'src/utils.ts', startLine: 6,
      endLine: 8 });

      +        nodes.set('src/utils.ts#onemore', { id: 'src/utils.ts#onemore',
      type: 'function', name: 'onemore', filePath: 'src/utils.ts', startLine: 9,
      endLine: 10 });

      +

      +        edges.push({ fromId: 'src/main.ts', toId: 'src/utils.ts', type:
      'imports' });

      +        edges.push({ fromId: 'src/main.ts#main', toId:
      'src/utils.ts#helper', type: 'calls' });

      +        edges.push({ fromId: 'src/main.ts#main', toId:
      'src/utils.ts#another', type: 'calls' });

      +        edges.push({ fromId: 'src/main.ts#main', toId:
      'src/utils.ts#onemore', type: 'calls' });

      +

      +        const ranks = new Map([

      +          ['src/main.ts', 0.8],

      +          ['src/utils.ts', 0.6],

      +          ['src/main.ts#main', 0.5],

      +          ['src/utils.ts#helper', 0.4],

      +          ['src/utils.ts#another', 0.3],

      +          ['src/utils.ts#onemore', 0.2]

      +        ]);

      +        

      +        rankedGraph = { nodes, edges, ranks };

      +      });

      +      

      +      it('should exclude header when option is false', () => {

      +        const markdown = renderer(rankedGraph, { includeHeader: false });

      +        expect(markdown).not.toContain('# RepoGraph');

      +        expect(markdown).not.toContain('_Generated by RepoGraph on');

      +      });

      +

      +      it('should exclude project overview when option is false', () => {

      +        const markdown = renderer(rankedGraph, { includeOverview: false
      });

      +        expect(markdown).not.toContain('## ðŸš€ Project Overview');

      +      });

      +

      +      it('should exclude file list when option is false', () => {

      +        const markdown = renderer(rankedGraph, { includeFileList: false
      });

      +        expect(markdown).not.toContain('### Top 10 Most Important
      Files');

      +      });

      +

      +      it('should respect topFileCount option', () => {

      +        const markdown = renderer(rankedGraph, { topFileCount: 1 });

      +        expect(markdown).toContain('### Top 1 Most Important Files');

      +        expect(markdown).toContain('`src/main.ts`');

      +        expect(markdown).not.toContain('`src/utils.ts`');

      +      });

      +

      +      it('should use custom file section separator', () => {

      +        const markdown = renderer(rankedGraph, { fileSectionSeparator:
      '***' });

      +        expect(markdown).toContain('\n***\n\n');

      +        expect(markdown).not.toContain('\n---\n\n');

      +      });

      +      

      +      it('should not include relations when
      symbolDetailOptions.includeRelations is false', () => {

      +        const markdown = renderer(rankedGraph, { symbolDetailOptions: {
      includeRelations: false } });

      +        expect(markdown).not.toContain('(calls');

      +        expect(markdown).toContain('**`function main`** - _L2_');

      +      });

      +      

      +      it('should not include line numbers when
      symbolDetailOptions.includeLineNumber is false', () => {

      +        const markdown = renderer(rankedGraph, { symbolDetailOptions: {
      includeLineNumber: false } });

      +        expect(markdown).not.toContain('- _L2_');

      +        expect(markdown).toContain('**`function main`** (calls `helper`,
      `another`, `onemore`)');

      +      });

      +      

      +      it('should not include code snippets when
      symbolDetailOptions.includeCodeSnippet is false', () => {

      +        const markdown = renderer(rankedGraph, { symbolDetailOptions: {
      includeCodeSnippet: false } });

      +        expect(markdown).not.toContain('```');

      +        expect(markdown).not.toContain('function main() {}');

      +        expect(markdown).toContain('**`function main`**');

      +      });

      +      

      +      it('should respect maxRelationsToShow option', () => {

      +        const markdown = renderer(rankedGraph, { symbolDetailOptions: {
      maxRelationsToShow: 1 } });

      +        expect(markdown).toContain('(calls `helper`...)');

      +        expect(markdown).not.toContain('`another`');

      +        expect(markdown).not.toContain('`onemore`');

      +      });

      +

      +      it('should render an empty string if all sections are disabled', ()
      => {

      +        const markdown = renderer(rankedGraph, {

      +          includeHeader: false,

      +          includeOverview: false,

      +          includeMermaidGraph: false,

      +          includeFileList: false,

      +          includeSymbolDetails: false,

      +        });

      +        expect(markdown).toBe('');

      +      });

      +    });

      +
           it('should include custom header when provided', () => {
             const rankedGraph: RankedCodeGraph = {
               nodes: new Map(),
    patchStrategy: new-unified
  - type: write
    path: test/e2e/cli.test.ts
    content: >-
      --- test/e2e/cli.test.ts

      +++ test/e2e/cli.test.ts

      @@ -242,6 +242,75 @@
           });
         });
       
      +  describe('Output Customization Flags', () => {

      +    beforeEach(async () => {

      +      const files = {

      +        'src/index.ts': `import { helper, another, onemore } from
      './utils.js';

      +export function main() { helper(); another(); onemore(); }`,

      +        'src/utils.ts': `export function helper() {}

      +export function another() {}

      +export function onemore() {}`

      +      };

      +      await createTestFiles(tempDir, files);

      +    });

      +

      +    it('should handle --no-header', async () => {

      +      await runCLI([tempDir, '--no-header']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('# RepoGraph');

      +    });

      +    

      +    it('should handle --no-overview', async () => {

      +      await runCLI([tempDir, '--no-overview']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('## ðŸš€ Project Overview');

      +    });

      +

      +    it('should handle --no-mermaid', async () => {

      +      await runCLI([tempDir, '--no-mermaid']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('```mermaid');

      +    });

      +

      +    it('should handle --no-file-list', async () => {

      +      await runCLI([tempDir, '--no-file-list']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('### Top 10 Most Important Files');

      +    });

      +

      +    it('should handle --no-symbol-details', async () => {

      +      await runCLI([tempDir, '--no-symbol-details']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('## ðŸ“‚ File & Symbol Breakdown');

      +    });

      +    

      +    it('should handle --top-file-count', async () => {

      +      await runCLI([tempDir, '--top-file-count', '1']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).toContain('### Top 1 Most Important Files');

      +    });

      +

      +    it('should handle --file-section-separator', async () => {

      +      await runCLI([tempDir, '--file-section-separator', '***']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).toContain('\n***\n\n');

      +    });

      +    

      +    it('should handle --no-symbol-relations', async () => {

      +      await runCLI([tempDir, '--no-symbol-relations']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('(calls');

      +    });

      +

      +    it('should handle --no-symbol-line-numbers', async () => {

      +      await runCLI([tempDir, '--no-symbol-line-numbers']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('_L2_');

      +    });

      +

      +    it('should handle --no-symbol-snippets', async () => {

      +      await runCLI([tempDir, '--no-symbol-snippets']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).not.toContain('```typescript');

      +    });

      +

      +    it('should handle --max-relations-to-show', async () => {

      +      await runCLI([tempDir, '--max-relations-to-show', '1']);

      +      const content = await readFile(path.join(tempDir, 'repograph.md'));

      +      expect(content).toContain('calls `helper`...');

      +      expect(content).not.toContain('`another`');

      +    });

      +  });

      +
         describe('Output Validation', () => {
           it('should generate valid markdown structure', async () => {
             const files = {
    patchStrategy: new-unified
  - type: write
    path: test/integration/pipeline.test.ts
    content: >-
      --- test/integration/pipeline.test.ts

      +++ test/integration/pipeline.test.ts

      @@ -213,29 +213,44 @@
             await assertFileExists(outputPath);
           });
       
      -    it('should pass renderer options through pipeline', async () => {

      -      const files = {

      -        'src/index.ts': `export class TestClass {

      -  method(): void {}

      -}`

      -      };

      -      await createTestFiles(tempDir, files);

      -

      -      const generator = createMapGenerator({

      -        discover: createDefaultDiscoverer(),

      -        analyze: createTreeSitterAnalyzer(),

      -        rank: createPageRanker(),

      -        render: createMarkdownRenderer()

      -      });

      -

      -      const rendererOptions: RendererOptions = {

      -        customHeader: '# Custom Project Header',

      -        includeMermaidGraph: false,

      -        includeSymbolDetails: false

      -      };

      -

      -      const outputPath = path.join(tempDir, 'custom.md');

      +    it('should pass renderer options through pipeline', async () => {

      +      const files = {

      +        'src/index.ts': `import { util1, util2, util3 } from
      './utils.js';

      +export function main() { util1(); util2(); util3(); }`,

      +        'src/utils.ts': `export function util1() {}

      +export function util2() {}

      +export function util3() {}`

      +      };

      +      await createTestFiles(tempDir, files);

      +

      +      const generator = createMapGenerator({

      +        discover: createDefaultDiscoverer(),

      +        analyze: createTreeSitterAnalyzer(),

      +        rank: createPageRanker(),

      +        render: createMarkdownRenderer()

      +      });

      +

      +      const rendererOptions: RendererOptions = {

      +        includeHeader: false,

      +        includeOverview: false,

      +        includeMermaidGraph: false,

      +        includeFileList: false,

      +        includeSymbolDetails: true,

      +        fileSectionSeparator: '***',

      +        symbolDetailOptions: {

      +          includeRelations: false,

      +          includeLineNumber: false,

      +          includeCodeSnippet: false,

      +        },

      +      };

      +

      +      const outputPath = path.join(tempDir, 'custom.md');
             await generator({
               root: tempDir,
               output: outputPath,
               rendererOptions
             });
       
             const content = await readFile(outputPath);
      -      expect(content).toStartWith('# Custom Project Header');

      -      expect(content).not.toContain('```mermaid');

      -      expect(content).not.toContain('## ðŸ“‚ File & Symbol Breakdown');

      +      expect(content).not.toContain('# RepoGraph');

      +      expect(content).not.toContain('## ðŸš€ Project Overview');

      +      expect(content).not.toContain('```mermaid');

      +      expect(content).not.toContain('### Top');

      +      expect(content).toContain('## ðŸ“‚ File & Symbol Breakdown');

      +      expect(content).toContain('\n***\n\n');

      +      expect(content).not.toContain('(calls `util1`');

      +      expect(content).not.toContain('_L2_');

      +      expect(content).not.toContain('```typescript');
           });
         });
    patchStrategy: new-unified
  - type: write
    path: test/integration/high-level.test.ts
    content: >-
      --- test/integration/high-level.test.ts

      +++ test/integration/high-level.test.ts

      @@ -194,27 +194,62 @@
             expect(content).toContain('src/index.ts');
           });
       
      -    it('should pass renderer options correctly', async () => {

      -      const files = {

      -        'src/index.ts': `export class Test {

      -  method(): void {}

      -}`

      -      };

      -      await createTestFiles(tempDir, files);

      -

      -      const outputPath = path.join(tempDir, 'custom.md');

      -      await generateMap({

      -        root: tempDir,

      -        output: outputPath,

      -        rendererOptions: {

      -          customHeader: '# My Custom Project',

      -          includeMermaidGraph: false,

      -          includeSymbolDetails: false

      -        }

      -      });

      -

      -      const content = await readFile(outputPath);

      -      expect(content).toStartWith('# My Custom Project');

      -      expect(content).not.toContain('```mermaid');

      -      expect(content).not.toContain('## ðŸ“‚ File & Symbol Breakdown');

      +    it('should pass renderer options correctly', async () => {

      +      const files = {

      +        'src/index.ts': `import { util1, util2, util3 } from
      './utils.js';

      +export function main() { util1(); util2(); util3(); }`,

      +        'src/utils.ts': `export function util1() {}

      +export function util2() {}

      +export function util3() {}`

      +      };

      +      await createTestFiles(tempDir, files);

      +

      +      const outputPath = path.join(tempDir, 'custom.md');

      +      await generateMap({

      +        root: tempDir,

      +        output: outputPath,

      +        rendererOptions: {

      +          customHeader: '# My Custom Project',

      +          includeOverview: false,

      +          includeMermaidGraph: false,

      +          includeFileList: true,

      +          topFileCount: 1,

      +          includeSymbolDetails: true,

      +          fileSectionSeparator: '***',

      +          symbolDetailOptions: {

      +            includeRelations: true,

      +            includeLineNumber: false,

      +            includeCodeSnippet: false,

      +            maxRelationsToShow: 1,

      +          },

      +        }

      +      });

      +

      +      const content = await readFile(outputPath);

      +      expect(content).toStartWith('# My Custom Project');

      +      expect(content).not.toContain('## ðŸš€ Project Overview');

      +      expect(content).not.toContain('```mermaid');

      +      expect(content).toContain('### Top 1 Most Important Files');

      +      expect(content).toContain('## ðŸ“‚ File & Symbol Breakdown');

      +      expect(content).toContain('\n***\n\n');

      +      expect(content).toContain('(calls `util1`...)');

      +      expect(content).not.toContain('`util2`');

      +      expect(content).not.toContain('_L2_');

      +      expect(content).not.toContain('```typescript');

      +    });

      +

      +    it('should handle all boolean false renderer options', async () => {

      +       const files = { 'src/index.ts': 'export function main() {}' };

      +       await createTestFiles(tempDir, files);

      +

      +       const outputPath = path.join(tempDir, 'custom-bools.md');

      +       await generateMap({

      +         root: tempDir,

      +         output: outputPath,

      +         rendererOptions: {

      +           includeHeader: false,

      +           includeOverview: false,

      +           includeMermaidGraph: false,

      +           includeFileList: false,

      +           includeSymbolDetails: false,

      +         }

      +       });

      +

      +       const content = await readFile(outputPath);

      +       expect(content.trim()).toBe('');
           });
       
           it('should handle empty projects gracefully', async () => {
    patchStrategy: new-unified
snapshot:
  test/unit/render.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import type { CodeNode, CodeEdge, FileContent, RankedCodeGraph,
    RendererOptions } from '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      isValidMarkdown,
      containsValidMermaid,
      extractFilePathsFromMarkdown,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';


    describe('Markdown Rendering', () => {
      let tempDir: string;
      let renderer: ReturnType<typeof createMarkdownRenderer>;

      beforeEach(async () => {
        tempDir = await createTempDir();
        renderer = createMarkdownRenderer();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMarkdownRenderer()', () => {
        it('should return a Renderer function', () => {
          expect(typeof renderer).toBe('function');
        });

        it('should generate valid markdown from empty graph', () => {
          const rankedGraph: RankedCodeGraph = {
            nodes: new Map(),
            edges: [],
            ranks: new Map()
          };

          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('# RepoGraph');
          expect(markdown).toContain('This repository contains 0 nodes (0 files)');
        });

        it('should include project overview section', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/index.ts', {
            id: 'src/index.ts',
            type: 'file',
            name: 'index.ts',
            filePath: 'src/index.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## ðŸš€ Project Overview');
          expect(markdown).toContain('This repository contains 1 nodes (1 files)');
          expect(markdown).toContain('_Generated by RepoGraph on');
        });

        it('should include Mermaid graph by default', () => {
          const nodes = new Map<string, CodeNode>();
          const edges: CodeEdge[] = [];

          nodes.set('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          nodes.set('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges,
            ranks: new Map([
              ['src/a.ts', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### Module Dependency Graph');
          expect(containsValidMermaid(markdown)).toBe(true);
          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
        });

        it('should exclude Mermaid graph when option is false', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/index.ts', {
            id: 'src/index.ts',
            type: 'file',
            name: 'index.ts',
            filePath: 'src/index.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeMermaidGraph: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('### Module Dependency Graph');
          expect(markdown).not.toContain('```mermaid');
        });

        it('should include top 10 most important files', () => {
          const nodes = new Map<string, CodeNode>();
          const ranks = new Map<string, number>();

          // Create 15 files with different ranks
          for (let i = 1; i <= 15; i++) {
            const nodeId = `src/file${i}.ts`;
            nodes.set(nodeId, {
              id: nodeId,
              type: 'file',
              name: `file${i}.ts`,
              filePath: nodeId,
              startLine: 1,
              endLine: 10
            });
            ranks.set(nodeId, i / 15); // Higher numbers get higher ranks
          }

          const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
          const markdown = renderer(rankedGraph);

          const topFilesSection = markdown.split('## ðŸ“‚ File & Symbol Breakdown')[0]!;

          expect(topFilesSection).toContain('### Top 10 Most Important Files');
          expect(topFilesSection).toContain('| Rank | File | Description |');
          
          // Should contain the top 10 files (file15 to file6)
          expect(topFilesSection).toContain('`src/file15.ts`');
          expect(topFilesSection).toContain('`src/file6.ts`');
          
          // Should not contain the lower ranked files
          expect(topFilesSection).not.toContain('`src/file1.ts`');
          expect(topFilesSection).not.toContain('`src/file5.ts`');
        });

        it('should include symbol details by default', () => {
          const nodes = new Map<string, CodeNode>();

          nodes.set('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 20
          });

          nodes.set('src/test.ts#TestClass', {
            id: 'src/test.ts#TestClass',
            type: 'class',
            name: 'TestClass',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 15,
            codeSnippet: 'export class TestClass {'
          });

          nodes.set('src/test.ts#testFunction', {
            id: 'src/test.ts#testFunction',
            type: 'function',
            name: 'testFunction',
            filePath: 'src/test.ts',
            startLine: 17,
            endLine: 19,
            codeSnippet: 'export function testFunction(): void'
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#TestClass', 0.5],
              ['src/test.ts#testFunction', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## ðŸ“‚ File & Symbol Breakdown');
          expect(markdown).toContain('### [`src/test.ts`](./src/test.ts)');
          expect(markdown).toContain('**`class TestClass`** - _L5_');
          expect(markdown).toContain('**`function testFunction`** - _L17_');
          expect(markdown).toContain('export class TestClass {');
          expect(markdown).toContain('export function testFunction(): void');
        });

        it('should exclude symbol details when option is false', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/test.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeSymbolDetails: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
        });

        it('should include custom header when provided', () => {
          const rankedGraph: RankedCodeGraph = {
            nodes: new Map(),
            edges: [],
            ranks: new Map()
          };

          const customHeader = '# My Custom Project\n\nThis is a custom description.';
          const options: RendererOptions = {
            customHeader
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).toStartWith(customHeader);
          expect(markdown).not.toContain('# RepoGraph');
        });

        it('should handle files with no symbols', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('README.md', {
            id: 'README.md',
            type: 'file',
            name: 'README.md',
            filePath: 'README.md',
            startLine: 1,
            endLine: 5
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['README.md', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`README.md`](./README.md)');
          expect(markdown).toContain('_No symbols identified in this file._');
        });

        it('should sort symbols by line number', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 30
          });

          // Add symbols in non-sequential order
          nodes.set('src/test.ts#lastFunction', {
            id: 'src/test.ts#lastFunction',
            type: 'function',
            name: 'lastFunction',
            filePath: 'src/test.ts',
            startLine: 25,
            endLine: 28
          });

          nodes.set('src/test.ts#firstFunction', {
            id: 'src/test.ts#firstFunction',
            type: 'function',
            name: 'firstFunction',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 10
          });

          nodes.set('src/test.ts#middleClass', {
            id: 'src/test.ts#middleClass',
            type: 'class',
            name: 'middleClass',
            filePath: 'src/test.ts',
            startLine: 15,
            endLine: 20
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#lastFunction', 0.3],
              ['src/test.ts#firstFunction', 0.5],
              ['src/test.ts#middleClass', 0.4]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Check that symbols appear in line number order
          const firstFunctionIndex = markdown.indexOf('firstFunction');
          const middleClassIndex = markdown.indexOf('middleClass');
          const lastFunctionIndex = markdown.indexOf('lastFunction');

          expect(firstFunctionIndex).toBeLessThan(middleClassIndex);
          expect(middleClassIndex).toBeLessThan(lastFunctionIndex);
        });

        it('should sort files by rank (highest first)', () => {
          const nodes = new Map<string, CodeNode>();
          const files = [
            { id: 'src/low.ts', rank: 0.2 },
            { id: 'src/high.ts', rank: 0.8 },
            { id: 'src/medium.ts', rank: 0.5 }
          ];

          const ranks = new Map<string, number>();

          for (const file of files) {
            nodes.set(file.id, {
              id: file.id,
              type: 'file',
              name: file.id.split('/').pop()!,
              filePath: file.id,
              startLine: 1,
              endLine: 10
            });
            ranks.set(file.id, file.rank);
          }

          const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
          const markdown = renderer(rankedGraph);

          // Check order in the file breakdown section
          const highIndex = markdown.indexOf('[`src/high.ts`]');
          const mediumIndex = markdown.indexOf('[`src/medium.ts`]');
          const lowIndex = markdown.indexOf('[`src/low.ts`]');

          expect(highIndex).toBeLessThan(mediumIndex);
          expect(mediumIndex).toBeLessThan(lowIndex);
        });

        it('should handle symbols without code snippets', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          nodes.set('src/test.ts#noSnippet', {
            id: 'src/test.ts#noSnippet',
            type: 'function',
            name: 'noSnippet',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 8
            // No codeSnippet property
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#noSnippet', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function noSnippet`** - _L5_');
          // Should not include empty code block
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });

        it('should generate proper markdown links for files', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/nested/deep/file.ts', {
            id: 'src/nested/deep/file.ts',
            type: 'file',
            name: 'file.ts',
            filePath: 'src/nested/deep/file.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/nested/deep/file.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`src/nested/deep/file.ts`](./src/nested/deep/file.ts)');
        });
      });

      describe('Mermaid Graph Generation', () => {
        it('should only include file nodes in Mermaid graph', () => {
          const nodes = new Map<string, CodeNode>();
          const edges: CodeEdge[] = [];

          nodes.set('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          nodes.set('src/a.ts#Class', {
            id: 'src/a.ts#Class',
            type: 'class',
            name: 'Class',
            filePath: 'src/a.ts',
            startLine: 2,
            endLine: 8
          });

          nodes.set('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/a.ts#Class', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
          expect(markdown).not.toContain('src/a.ts#Class');
        });

        it('should handle graphs with no file-to-file edges', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/isolated.ts', {
            id: 'src/isolated.ts',
            type: 'file',
            name: 'isolated.ts',
            filePath: 'src/isolated.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([['src/isolated.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('```mermaid');
          expect(markdown).toContain('graph TD');
          expect(markdown).toContain('```');
        });

        it('should deduplicate edges in Mermaid graph', () => {
          const nodes = new Map<string, CodeNode>();
          const edges: CodeEdge[] = [];
          nodes.set('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          nodes.set('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          // Add multiple edges between the same files (multi-graph)
          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });
          edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Should only appear once in the Mermaid graph
          const edgePattern = /src\/a\.ts\["a\.ts"\] --> src\/b\.ts\["b\.ts"\]/g;
          const matches = markdown.match(edgePattern);
          expect(matches).toHaveLength(1);
        });
      });

      describe('Integration with Real Analysis', () => {
        it('should render analyzed TypeScript code correctly', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';

    export { Calculator };


    export function main(): void {
      const calc = new Calculator();
      console.log(calc.add(1, 2));
    }`
            },
            {
              path: 'src/calculator.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
      
      subtract = (a: number, b: number): number => {
        return a - b;
      };
    }`
            }
          ];

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Calculator');
          expect(markdown).toContain('**`class Calculator`**');
          expect(markdown).toContain('**`function main`**');
          expect(markdown).toContain('**`arrow_function subtract`**');
          expect(containsValidMermaid(markdown)).toBe(true);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should render sample-project fixture correctly', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Calculator');
          expect(markdown).toContain('Logger');
          expect(markdown).toContain('Config');
          
          const filePaths = extractFilePathsFromMarkdown(markdown);
          expect(filePaths.length).toBeGreaterThan(0);
          expect(filePaths).toContain('src/calculator.ts');
          expect(filePaths).toContain('src/utils/logger.ts');
        });

        it('should render complex-project fixture correctly', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts') && !file.path.includes('test')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Database');
          expect(markdown).toContain('ApiServer');
          expect(markdown).toContain('UserService');
          expect(containsValidMermaid(markdown)).toBe(true);
        });

        it('should handle all renderer options with fixtures', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [
            {
              path: 'src/main.ts',
              content: fixture.files[0]!.content
            }
          ];

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph);

          const options: RendererOptions = {
            customHeader: '# My Minimal Project\n\nCustom description here.',
            includeMermaidGraph: false,
            includeSymbolDetails: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).toStartWith('# My Minimal Project');
          expect(markdown).not.toContain('```mermaid');
          expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
          expect(markdown).toContain('### Top 10 Most Important Files');
        });
      });

      describe('Edge Cases', () => {
        it('should handle very long file paths', () => {
          const nodes = new Map<string, CodeNode>();
          const longPath = 'src/very/deeply/nested/directory/structure/with/many/levels/file.ts';
          nodes.set(longPath, {
            id: longPath,
            type: 'file',
            name: 'file.ts',
            filePath: longPath,
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([[longPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`[\`${longPath}\`](./${longPath})`);
        });

        it('should handle special characters in file names', () => {
          const nodes = new Map<string, CodeNode>();
          const specialPath = 'src/file-with-dashes_and_underscores.spec.ts';
          nodes.set(specialPath, {
            id: specialPath,
            type: 'file',
            name: 'file-with-dashes_and_underscores.spec.ts',
            filePath: specialPath,
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([[specialPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`\`${specialPath}\``);
        });

        it('should handle empty code snippets gracefully', () => {
          const nodes = new Map<string, CodeNode>();
          nodes.set('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          nodes.set('src/test.ts#empty', {
            id: 'src/test.ts#empty',
            type: 'function',
            name: 'empty',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 6,
            codeSnippet: ''
          });

          const rankedGraph: RankedCodeGraph = {
            nodes,
            edges: [],
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#empty', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function empty`** - _L5_');
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });
      });
    });
  test/e2e/cli.test.ts: |-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
    import { spawn } from 'node:child_process';
    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      createGitignore,
      assertFileExists,
      readFile,
      isValidMarkdown,
      containsValidMermaid,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';
    import path from 'node:path';

    describe('CLI End-to-End Tests', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      const runCLI = async (args: string[], cwd?: string): Promise<{ stdout: string; stderr: string; exitCode: number }> => {
        return new Promise((resolve, reject) => {
          const child = spawn('bun', ['run', 'src/index.ts', ...args], {
            cwd: cwd || process.cwd(),
            stdio: 'pipe'
          });

          let stdout = '';
          let stderr = '';

          child.stdout?.on('data', (data) => {
            stdout += data.toString();
          });

          child.stderr?.on('data', (data) => {
            stderr += data.toString();
          });

          child.on('close', (code) => {
            resolve({
              stdout,
              stderr,
              exitCode: code || 0
            });
          });

          child.on('error', reject);
        });
      };

      describe('Basic CLI Usage', () => {
        it('should generate map with default options', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([tempDir]);

          expect(result.exitCode).toBe(0);
          await assertFileExists(path.join(tempDir, 'repograph.md'));
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Example');
        });

        it('should accept custom output path', async () => {
          const files = {
            'src/test.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'custom-output.md');
          const result = await runCLI([tempDir, '--output', outputPath]);

          expect(result.exitCode).toBe(0);
          await assertFileExists(outputPath);
        });

        it('should accept include patterns', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/index.js');
        });

        it('should accept ignore patterns', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/test.spec.ts': 'test code'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ignore', '**/*.spec.ts'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/test.spec.ts');
        });

        it('should accept ranking strategy option', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ranking-strategy', 'git-changes'
          ]);

          expect(result.exitCode).toBe(0);
          await assertFileExists(path.join(tempDir, 'repograph.md'));
        });

        it('should accept no-gitignore flag', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'dist/index.js': 'compiled code'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['dist/']);

          const result = await runCLI([
            tempDir,
            '--no-gitignore'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('dist/index.js');
        });

        it('should show help when --help flag is used', async () => {
          const result = await runCLI(['--help']);

          expect(result.exitCode).toBe(0);
          expect(result.stdout).toContain('Usage:');
          expect(result.stdout).toContain('Options:');
        });

        it('should show version when --version flag is used', async () => {
          const result = await runCLI(['--version']);

          expect(result.exitCode).toBe(0);
          expect(result.stdout).toMatch(/\d+\.\d+\.\d+/);
        });
      });

      describe('Error Handling', () => {
        it('should handle non-existent directory', async () => {
          const nonExistentDir = path.join(tempDir, 'non-existent');
          const result = await runCLI([nonExistentDir]);

          expect(result.exitCode).not.toBe(0);
          expect(result.stderr).toContain('Error');
        });

        it('should handle invalid output directory', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const invalidOutput = '/root/cannot-write-here.md';
          const result = await runCLI([
            tempDir,
            '--output', invalidOutput
          ]);

          expect(result.exitCode).not.toBe(0);
        });

        it('should handle invalid ranking strategy', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ranking-strategy', 'invalid-strategy'
          ]);

          expect(result.exitCode).not.toBe(0);
          expect(result.stderr).toContain('Invalid ranking strategy');
        });

        it('should handle malformed include patterns gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '[invalid-pattern'
          ]);

          // Should not crash, but might produce empty output
          expect(result.exitCode).toBe(0);
        });
      });

      describe('Multiple Arguments', () => {
        it('should handle multiple include patterns', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'lib/utils.js': 'export const js = true;',
            'docs/readme.md': '# Documentation'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts',
            '--include', '**/*.js'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).toContain('lib/utils.js');
          expect(content).not.toContain('docs/readme.md');
        });

        it('should handle multiple ignore patterns', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/test.spec.ts': 'test code',
            'src/utils.test.ts': 'test utils',
            'src/helper.ts': 'helper code'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--ignore', '**/*.spec.ts',
            '--ignore', '**/*.test.ts'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).toContain('src/helper.ts');
          expect(content).not.toContain('src/test.spec.ts');
          expect(content).not.toContain('src/utils.test.ts');
        });
      });

      describe('Output Validation', () => {
        it('should generate valid markdown structure', async () => {
          const files = {
            'src/calculator.ts': `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
    }`,
            'src/logger.ts': `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([tempDir]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          
          // Check markdown structure
          expect(content).toContain('# RepoGraph');
          expect(content).toContain('## ðŸš€ Project Overview');
          expect(content).toContain('### Module Dependency Graph');
          expect(content).toContain('### Top 10 Most Important Files');
          expect(content).toContain('## ðŸ“‚ File & Symbol Breakdown');
          
          // Check Mermaid graph
          expect(containsValidMermaid(content)).toBe(true);
          
          // Check symbol details
          expect(content).toContain('Calculator');
          expect(content).toContain('Logger');
        });

        it('should handle projects with complex dependencies', async () => {
          const files = {
            'src/index.ts': `import { Database } from './database.js';
    import { ApiServer } from './api.js';

    export class App {
      constructor(
        private db: Database,
        private api: ApiServer
      ) {}
    }`,
            'src/database.ts': `export class Database {
      connect(): Promise<void> {
        return Promise.resolve();
      }
    }`,
            'src/api.ts': `import { Database } from './database.js';

    export class ApiServer {
      constructor(private db: Database) {}
    }`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([tempDir]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('App');
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(containsValidMermaid(content)).toBe(true);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should process sample-project fixture via CLI', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Calculator');
          expect(content).toContain('Logger');
          expect(content).toContain('AdvancedCalculator');
        });

        it('should process complex-project fixture via CLI', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts',
            '--ranking-strategy', 'pagerank'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(content).toContain('UserService');
        });

        it('should handle minimal-project fixture via CLI', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const result = await runCLI([tempDir]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('src/main.ts');
          expect(content).toContain('hello');
          expect(content).toContain('greet');
        });
      });

      describe('Performance', () => {
        it('should handle moderately large projects in reasonable time', async () => {
          // Create a project with many files
          const files: Record<string, string> = {};
          
          for (let i = 0; i < 30; i++) {
            files[`src/module${i}.ts`] = `export class Module${i} {
      process(): string {
        return 'module${i}';
      }
    }`;
          }

          // Add some imports
          files['src/index.ts'] = Array.from({ length: 30 }, (_, i) => 
            `import { Module${i} } from './module${i}.js';`
          ).join('\n') + '\n\nexport const modules = [' + 
          Array.from({ length: 30 }, (_, i) => `Module${i}`).join(', ') + '];';

          await createTestFiles(tempDir, files);

          const startTime = Date.now();
          const result = await runCLI([tempDir]);
          const endTime = Date.now();

          expect(result.exitCode).toBe(0);
          expect(endTime - startTime).toBeLessThan(15000); // Should complete within 15 seconds
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('Module0');
          expect(content).toContain('Module29');
        });
      });

      describe('Real-world Scenarios', () => {
        it('should work with TypeScript project structure', async () => {
          const files = {
            'package.json': JSON.stringify({
              name: 'my-project',
              version: '1.0.0',
              type: 'module',
              scripts: {
                build: 'tsc',
                test: 'bun test'
              }
            }, null, 2),
            'tsconfig.json': JSON.stringify({
              compilerOptions: {
                target: 'ES2022',
                module: 'ESNext',
                outDir: './dist'
              }
            }, null, 2),
            'src/index.ts': `export { Calculator } from './lib/calculator.js';
    export type { CalculatorOptions } from './types.js';`,
            'src/lib/calculator.ts': `import type { CalculatorOptions } from '../types.js';

    export class Calculator {
      constructor(private options: CalculatorOptions) {}
      
      calculate(expression: string): number {
        return eval(expression);
      }
    }`,
            'src/types.ts': `export interface CalculatorOptions {
      precision: number;
      mode: 'strict' | 'loose';
    }`,
            'README.md': '# My Calculator Project'
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', 'src/**/*.ts'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('Calculator');
          expect(content).toContain('CalculatorOptions');
          expect(content).not.toContain('package.json');
          expect(content).not.toContain('README.md');
        });

        it('should work with monorepo structure', async () => {
          const files = {
            'packages/core/src/index.ts': `export { Engine } from './engine.js';`,
            'packages/core/src/engine.ts': `export class Engine {
      start(): void {
        console.log('Engine started');
      }
    }`,
            'packages/ui/src/index.ts': `export { Component } from './component.js';`,
            'packages/ui/src/component.ts': `import { Engine } from '../../core/src/engine.js';

    export class Component {
      private engine = new Engine();
      
      render(): void {
        this.engine.start();
      }
    }`,
            'apps/web/src/main.ts': `import { Component } from '../../../packages/ui/src/component.js';

    const component = new Component();
    component.render();`
          };
          await createTestFiles(tempDir, files);

          const result = await runCLI([
            tempDir,
            '--include', '**/*.ts'
          ]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('Engine');
          expect(content).toContain('Component');
          expect(content).toContain('packages/core/src/engine.ts');
          expect(content).toContain('packages/ui/src/component.ts');
          expect(content).toContain('apps/web/src/main.ts');
        });

        it('should respect gitignore in real project', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/utils.ts': 'export const util = true;',
            'dist/index.js': 'compiled code',
            'node_modules/package/index.js': 'dependency',
            'coverage/lcov.info': 'coverage data',
            '.env': 'SECRET=value',
            'logs/app.log': 'log content'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, [
            'dist/',
            'node_modules/',
            'coverage/',
            '.env',
            'logs/'
          ]);

          const result = await runCLI([tempDir]);

          expect(result.exitCode).toBe(0);
          
          const content = await readFile(path.join(tempDir, 'repograph.md'));
          expect(content).toContain('src/index.ts');
          expect(content).toContain('src/utils.ts');
          expect(content).not.toContain('dist/index.js');
          expect(content).not.toContain('node_modules/package/index.js');
          expect(content).not.toContain('coverage/lcov.info');
          expect(content).not.toContain('.env');
          expect(content).not.toContain('logs/app.log');
        });
      });
    });
  test/integration/pipeline.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMapGenerator } from '../../src/composer.js';

    import { createDefaultDiscoverer } from '../../src/pipeline/discover.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker, createGitRanker } from
    '../../src/pipeline/rank.js';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import type { RendererOptions } from '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      createGitignore,
      assertFileExists,
      readFile,
      isValidMarkdown,
      containsValidMermaid,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';

    import path from 'node:path';


    describe('Pipeline Integration', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('Full Pipeline Execution', () => {
        it('should execute complete pipeline with default components', async () => {
          const files = {
            'src/index.ts': `import { Calculator } from './calculator.js';
    export { Calculator };`,
            'src/calculator.ts': `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'output.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts']
          });

          await assertFileExists(outputPath);
          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Calculator');
          expect(containsValidMermaid(content)).toBe(true);
        });

        it('should handle empty project gracefully', async () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'empty.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });

        it('should respect include patterns in pipeline', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;',
            'README.md': '# Project'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'ts-only.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/index.js');
          expect(content).not.toContain('README.md');
        });

        it('should respect ignore patterns in pipeline', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/test.spec.ts': 'test code',
            'src/utils.ts': 'export const util = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'no-tests.md');
          await generator({
            root: tempDir,
            output: outputPath,
            ignore: ['**/*.spec.ts']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).toContain('src/utils.ts');
          expect(content).not.toContain('src/test.spec.ts');
        });

        it('should respect gitignore in pipeline', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'dist/index.js': 'compiled code',
            'node_modules/package/index.js': 'dependency'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['dist/', 'node_modules/']);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'with-gitignore.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('dist/index.js');
          expect(content).not.toContain('node_modules/package/index.js');
        });

        it('should create output directory if it does not exist', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'nested', 'deep', 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should pass renderer options through pipeline', async () => {
          const files = {
            'src/index.ts': `export class TestClass {
      method(): void {}
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const rendererOptions: RendererOptions = {
            customHeader: '# Custom Project Header',
            includeMermaidGraph: false,
            includeSymbolDetails: false
          };

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath,
            rendererOptions
          });

          const content = await readFile(outputPath);
          expect(content).toStartWith('# Custom Project Header');
          expect(content).not.toContain('```mermaid');
          expect(content).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
        });
      });

      describe('Component Composition', () => {
        it('should work with PageRank ranking strategy', async () => {
          const files = {
            'src/hub.ts': 'export class Hub {}',
            'src/a.ts': `import { Hub } from './hub.js';`,
            'src/b.ts': `import { Hub } from './hub.js';`,
            'src/c.ts': `import { Hub } from './hub.js';`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'pagerank.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('Hub');
          
          // Hub should appear early in the ranking due to being imported by multiple files
          const hubIndex = content.indexOf('src/hub.ts');
          expect(hubIndex).toBeGreaterThan(-1);
        });

        it('should work with Git ranking strategy', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/utils.ts': 'export const util = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createGitRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'git-rank.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('src/index.ts');
          expect(content).toContain('src/utils.ts');
        });

        it('should allow custom pipeline component combinations', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'test';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          // Create a custom renderer that adds extra information
          const customRenderer = () => {
            const baseRenderer = createMarkdownRenderer();
            return (rankedGraph: any, options?: any) => {
              const baseMarkdown = baseRenderer(rankedGraph, options);
              return `${baseMarkdown}\n\n<!-- Generated with custom renderer -->`;
            };
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: customRenderer()
          });

          const outputPath = path.join(tempDir, 'custom-renderer.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('<!-- Generated with custom renderer -->');
        });
      });

      describe('Error Handling', () => {
        it('should handle invalid root directory', async () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const invalidRoot = path.join(tempDir, 'non-existent');
          const outputPath = path.join(tempDir, 'error.md');

          await expect(generator({
            root: invalidRoot,
            output: outputPath
          })).rejects.toThrow();
        });

        it('should handle files that cannot be parsed', async () => {
          const files = {
            'src/valid.ts': 'export const valid = true;',
            'src/invalid.ts': 'this is not valid typescript syntax {{{',
            'binary.bin': Buffer.from([0x00, 0x01, 0x02, 0x03]).toString()
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'mixed.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/valid.ts');
          // Should still process the invalid file as a file node
          expect(content).toContain('src/invalid.ts');
        });

        it('should handle circular dependencies gracefully', async () => {
          const files = {
            'src/a.ts': `import { B } from './b.js';
    export class A {
      b: B;
    }`,
            'src/b.ts': `import { A } from './a.js';
    export class B {
      a: A;
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'circular.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/a.ts');
          expect(content).toContain('src/b.ts');
          expect(containsValidMermaid(content)).toBe(true);
        });
      });

      describe('Performance', () => {
        it('should handle moderately large projects efficiently', async () => {
          // Create a project with many files
          const files: Record<string, string> = {};
          
          for (let i = 0; i < 50; i++) {
            files[`src/file${i}.ts`] = `export class Class${i} {
      method${i}(): number {
        return ${i};
      }
    }`;
          }

          // Add some imports to create dependencies
          for (let i = 1; i < 50; i++) {
            files[`src/file${i}.ts`] = `import { Class${i-1} } from './file${i-1}.js';
    ${files[`src/file${i}.ts`]}`;
          }

          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'large.md');
          const startTime = Date.now();
          
          await generator({
            root: tempDir,
            output: outputPath
          });

          const endTime = Date.now();
          const duration = endTime - startTime;

          expect(duration).toBeLessThan(10000); // Should complete within 10 seconds

          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Class0');
          expect(content).toContain('Class49');
        });
      });

      describe('Integration with Fixtures', () => {
        it('should process sample-project fixture end-to-end', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'sample-output.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts']
          });

          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Calculator');
          expect(content).toContain('Logger');
          expect(content).toContain('Config');
          expect(content).toContain('AdvancedCalculator');
          expect(containsValidMermaid(content)).toBe(true);
          
          // Should show import relationships
          expect(content).toContain('src/calculator.ts');
          expect(content).toContain('src/utils/logger.ts');
          expect(content).toContain('src/types.ts');
        });

        it('should process complex-project fixture end-to-end', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'complex-output.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts']
          });

          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(content).toContain('UserService');
          expect(containsValidMermaid(content)).toBe(true);
          
          // Should exclude test files due to gitignore
          expect(content).not.toContain('tests/user.test.ts');
        });

        it('should handle minimal-project fixture', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'minimal-output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('src/main.ts');
          expect(content).toContain('hello');
          expect(content).toContain('greet');
        });

        it('should work with all renderer options on fixtures', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createGitRanker({ maxCommits: 100 }),
            render: createMarkdownRenderer()
          });

          const rendererOptions: RendererOptions = {
            customHeader: `# ${fixture.name}\n\n${fixture.description}`,
            includeMermaidGraph: true,
            includeSymbolDetails: true
          };

          const outputPath = path.join(tempDir, 'full-options.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts'],
            rendererOptions
          });

          const content = await readFile(outputPath);
          
          expect(content).toStartWith(`# ${fixture.name}`);
          expect(content).toContain(fixture.description);
          expect(containsValidMermaid(content)).toBe(true);
          expect(content).toContain('## ðŸ“‚ File & Symbol Breakdown');
        });
      });

      describe('Real-world Scenarios', () => {
        it('should handle TypeScript project with various symbol types', async () => {
          const files = {
            'src/types.ts': `export interface User {
      id: string;
      name: string;
    }


    export type Status = 'active' | 'inactive';


    export enum Role {
      ADMIN = 'admin',
      USER = 'user'
    }`,
            'src/service.ts': `import { User, Status, Role } from './types.js';

    export class UserService {
      private users: User[] = [];
      
      createUser(name: string): User {
        return {
          id: Math.random().toString(),
          name
        };
      }
      
      updateStatus = (userId: string, status: Status): void => {
        // Implementation
      };
    }


    export const validateRole = (role: string): role is Role => {
      return Object.values(Role).includes(role as Role);
    };`,
            'src/index.ts': `export { UserService } from './service.js';
    export type { User, Status } from './types.js';

    export { Role } from './types.js';`
          };

          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'typescript-project.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          
          expect(content).toContain('UserService');
          expect(content).toContain('User');
          expect(content).toContain('Status');
          expect(content).toContain('validateRole');
          expect(containsValidMermaid(content)).toBe(true);
        });

        it('should handle project with nested directory structure', async () => {
          const files = {
            'src/index.ts': `export * from './api/index.js';
    export * from './utils/index.js';`,
            'src/api/index.ts': `export { ApiClient } from './client.js';
    export { ApiServer } from './server.js';`,
            'src/api/client.ts': `export class ApiClient {
      get(url: string): Promise<any> {
        return fetch(url).then(r => r.json());
      }
    }`,
            'src/api/server.ts': `export class ApiServer {
      listen(port: number): void {
        console.log(\`Server listening on port \${port}\`);
      }
    }`,
            'src/utils/index.ts': `export { Logger } from './logger.js';
    export { Cache } from './cache.js';`,
            'src/utils/logger.ts': `export class Logger {
      log(message: string): void {
        console.log(message);
      }
    }`,
            'src/utils/cache.ts': `export class Cache<T> {
      private data = new Map<string, T>();
      
      set(key: string, value: T): void {
        this.data.set(key, value);
      }
      
      get(key: string): T | undefined {
        return this.data.get(key);
      }
    }`
          };

          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'nested-project.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          
          expect(content).toContain('src/api/client.ts');
          expect(content).toContain('src/api/server.ts');
          expect(content).toContain('src/utils/logger.ts');
          expect(content).toContain('src/utils/cache.ts');
          expect(content).toContain('ApiClient');
          expect(content).toContain('ApiServer');
          expect(content).toContain('Logger');
          expect(content).toContain('Cache');
        });
      });
    });
  test/integration/high-level.test.ts: |-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
    import { generateMap } from '../../src/high-level.js';
    import type { RepoGraphOptions } from '../../src/types.js';
    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      createGitignore,
      assertFileExists,
      readFile,
      isValidMarkdown,
      containsValidMermaid,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';
    import path from 'node:path';

    describe('High-Level API Integration', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('generateMap()', () => {
        it('should generate map with default options', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          await generateMap({
            root: tempDir,
            output: path.join(tempDir, 'repograph.md')
          });

          const outputPath = path.join(tempDir, 'repograph.md');
          await assertFileExists(outputPath);
          
          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Example');
        });

        it('should use current working directory as default root', async () => {
          const originalCwd = process.cwd();
          
          try {
            // Change to temp directory
            process.chdir(tempDir);
            
            const files = {
              'src/test.ts': 'export const test = true;'
            };
            await createTestFiles(tempDir, files);

            await generateMap({
              output: 'test-output.md'
            });

            await assertFileExists(path.join(tempDir, 'test-output.md'));
          } finally {
            process.chdir(originalCwd);
          }
        });

        it('should use default output path when not specified', async () => {
          const originalCwd = process.cwd();
          
          try {
            process.chdir(tempDir);
            
            const files = {
              'src/test.ts': 'export const test = true;'
            };
            await createTestFiles(tempDir, files);

            await generateMap();

            await assertFileExists(path.join(tempDir, 'repograph.md'));
          } finally {
            process.chdir(originalCwd);
          }
        });

        it('should respect include patterns', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;',
            'README.md': '# Project'
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'ts-only.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/index.js');
          expect(content).not.toContain('README.md');
        });

        it('should respect ignore patterns', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/test.spec.ts': 'test code',
            'src/utils.ts': 'export const util = true;'
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'no-tests.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            ignore: ['**/*.spec.ts']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).toContain('src/utils.ts');
          expect(content).not.toContain('src/test.spec.ts');
        });

        it('should respect noGitignore option', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'dist/index.js': 'compiled code'
          };
          await createTestFiles(tempDir, files);
          await createGitignore(tempDir, ['dist/']);

          const outputPath = path.join(tempDir, 'with-dist.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            noGitignore: true
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).toContain('dist/index.js');
        });

        it('should use PageRank strategy by default', async () => {
          const files = {
            'src/hub.ts': 'export class Hub {}',
            'src/a.ts': `import { Hub } from './hub.js';`,
            'src/b.ts': `import { Hub } from './hub.js';`
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'pagerank.md');
          await generateMap({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('Hub');
          // Hub should be ranked highly due to imports
        });

        it('should use Git ranking strategy when specified', async () => {
          const files = {
            'src/index.ts': 'export const main = true;',
            'src/utils.ts': 'export const util = true;'
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'git-rank.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            rankingStrategy: 'git-changes'
          });

          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('src/index.ts');
        });

        it('should pass renderer options correctly', async () => {
          const files = {
            'src/index.ts': `export class Test {
      method(): void {}
    }`
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'custom.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            rendererOptions: {
              customHeader: '# My Custom Project',
              includeMermaidGraph: false,
              includeSymbolDetails: false
            }
          });

          const content = await readFile(outputPath);
          expect(content).toStartWith('# My Custom Project');
          expect(content).not.toContain('```mermaid');
          expect(content).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
        });

        it('should handle empty projects gracefully', async () => {
          const outputPath = path.join(tempDir, 'empty.md');
          await generateMap({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });

        it('should resolve relative root paths', async () => {
          const files = {
            'project/src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const projectDir = path.join(tempDir, 'project');
          const outputPath = path.join(tempDir, 'relative.md');
          
          await generateMap({
            root: path.relative(process.cwd(), projectDir),
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
        });

        it('should handle complex TypeScript projects', async () => {
          const files = {
            'src/index.ts': `import { Database } from './database.js';
    import { ApiServer } from './api.js';

    export class Application {
      private db: Database;
      private api: ApiServer;
      
      constructor() {
        this.db = new Database();
        this.api = new ApiServer(this.db);
      }
      
      async start(): Promise<void> {
        await this.db.connect();
        this.api.listen(3000);
      }
    }`,
            'src/database.ts': `export class Database {
      async connect(): Promise<void> {
        console.log('Connected to database');
      }
      
      async query(sql: string): Promise<any[]> {
        return [];
      }
    }`,
            'src/api.ts': `import { Database } from './database.js';

    export class ApiServer {
      constructor(private db: Database) {}
      
      listen(port: number): void {
        console.log(\`API server listening on port \${port}\`);
      }
      
      async handleRequest(path: string): Promise<any> {
        return this.db.query(\`SELECT * FROM \${path}\`);
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'complex.md');
          await generateMap({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('Application');
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(containsValidMermaid(content)).toBe(true);
        });
      });

      describe('Error Handling', () => {
        it('should handle non-existent root directory', async () => {
          const nonExistentPath = path.join(tempDir, 'non-existent');
          const outputPath = path.join(tempDir, 'error.md');

          await expect(generateMap({
            root: nonExistentPath,
            output: outputPath
          })).rejects.toThrow();
        });

        it('should handle invalid include patterns gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'invalid-pattern.md');
          
          // This should not throw, just result in no files
          await generateMap({
            root: tempDir,
            output: outputPath,
            include: ['[invalid-pattern']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });

        it('should handle write permission errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          // Try to write to a directory that doesn't exist and can't be created
          const invalidOutputPath = '/root/cannot-write-here.md';

          await expect(generateMap({
            root: tempDir,
            output: invalidOutputPath
          })).rejects.toThrow();
        });
      });

      describe('Integration with Fixtures', () => {
        it('should process sample-project fixture with high-level API', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const outputPath = path.join(tempDir, 'sample-output.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts']
          });

          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Calculator');
          expect(content).toContain('Logger');
          expect(content).toContain('AdvancedCalculator');
          expect(containsValidMermaid(content)).toBe(true);
        });

        it('should process complex-project fixture with high-level API', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const outputPath = path.join(tempDir, 'complex-output.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts'],
            rankingStrategy: 'pagerank'
          });

          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(content).toContain('UserService');
          expect(containsValidMermaid(content)).toBe(true);
        });

        it('should handle minimal-project fixture', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const outputPath = path.join(tempDir, 'minimal-output.md');
          await generateMap({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('src/main.ts');
          expect(content).toContain('hello');
          expect(content).toContain('greet');
        });

        it('should work with all ranking strategies on fixtures', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          // Test PageRank strategy
          const pageRankOutput = path.join(tempDir, 'pagerank.md');
          await generateMap({
            root: tempDir,
            output: pageRankOutput,
            include: ['**/*.ts'],
            rankingStrategy: 'pagerank'
          });

          // Test Git strategy
          const gitOutput = path.join(tempDir, 'git.md');
          await generateMap({
            root: tempDir,
            output: gitOutput,
            include: ['**/*.ts'],
            rankingStrategy: 'git-changes'
          });

          const pageRankContent = await readFile(pageRankOutput);
          const gitContent = await readFile(gitOutput);

          expect(isValidMarkdown(pageRankContent)).toBe(true);
          expect(isValidMarkdown(gitContent)).toBe(true);
          
          // Both should contain the same symbols but potentially different rankings
          expect(pageRankContent).toContain('Calculator');
          expect(gitContent).toContain('Calculator');
        });

        it('should work with all renderer options on fixtures', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const outputPath = path.join(tempDir, 'full-options.md');
          
          const options: RepoGraphOptions = {
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts'],
            ignore: ['**/*.test.ts'],
            rankingStrategy: 'pagerank',
            rendererOptions: {
              customHeader: `# ${fixture.name}\n\n${fixture.description}`,
              includeMermaidGraph: true,
              includeSymbolDetails: true
            }
          };

          await generateMap(options);

          const content = await readFile(outputPath);
          
          expect(content).toStartWith(`# ${fixture.name}`);
          expect(content).toContain(fixture.description);
          expect(containsValidMermaid(content)).toBe(true);
          expect(content).toContain('## ðŸ“‚ File & Symbol Breakdown');
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
        });
      });

      describe('Real-world Usage Patterns', () => {
        it('should work for analyzing a library project', async () => {
          const files = {
            'src/index.ts': `export { Calculator } from './calculator.js';
    export { Logger } from './logger.js';
    export type { CalculatorOptions } from './types.js';`,
            'src/calculator.ts': `import type { CalculatorOptions } from './types.js';
    import { Logger } from './logger.js';

    export class Calculator {
      private logger: Logger;
      private options: CalculatorOptions;
      
      constructor(options: CalculatorOptions = {}) {
        this.options = { precision: 2, ...options };
        this.logger = new Logger();
      }
      
      add(a: number, b: number): number {
        this.logger.log(\`Adding \${a} + \${b}\`);
        return Number((a + b).toFixed(this.options.precision));
      }
      
      multiply(a: number, b: number): number {
        this.logger.log(\`Multiplying \${a} * \${b}\`);
        return Number((a * b).toFixed(this.options.precision));
      }
    }`,
            'src/logger.ts': `export class Logger {
      log(message: string): void {
        console.log(\`[Calculator] \${message}\`);
      }
    }`,
            'src/types.ts': `export interface CalculatorOptions {
      precision?: number;
    }`,
            'package.json': JSON.stringify({
              name: 'my-calculator',
              version: '1.0.0',
              type: 'module',
              main: './dist/index.js',
              types: './dist/index.d.ts'
            }, null, 2),
            'README.md': '# My Calculator\n\nA simple calculator library.'
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'library-docs.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            include: ['src/**/*.ts'],
            rendererOptions: {
              customHeader: '# My Calculator Library\n\nGenerated API documentation.',
              includeMermaidGraph: true,
              includeSymbolDetails: true
            }
          });

          const content = await readFile(outputPath);
          
          expect(content).toStartWith('# My Calculator Library');
          expect(content).toContain('Calculator');
          expect(content).toContain('Logger');
          expect(content).toContain('CalculatorOptions');
          expect(content).toContain('add');
          expect(content).toContain('multiply');
          expect(containsValidMermaid(content)).toBe(true);
        });

        it('should work for analyzing an application project', async () => {
          const files = {
            'src/main.ts': `import { App } from './app.js';

    const app = new App();
    app.start().catch(console.error);`,
            'src/app.ts': `import { Database } from './database/index.js';
    import { ApiServer } from './api/server.js';
    import { Config } from './config.js';

    export class App {
      private db: Database;
      private api: ApiServer;
      private config: Config;
      
      constructor() {
        this.config = new Config();
        this.db = new Database(this.config.database);
        this.api = new ApiServer(this.db, this.config.api);
      }
      
      async start(): Promise<void> {
        await this.db.connect();
        this.api.listen();
        console.log('Application started');
      }
    }`,
            'src/config.ts': `export class Config {
      database = {
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '5432')
      };
      
      api = {
        port: parseInt(process.env.API_PORT || '3000')
      };
    }`,
            'src/database/index.ts': `export class Database {
      constructor(private config: any) {}
      
      async connect(): Promise<void> {
        console.log('Connected to database');
      }
    }`,
            'src/api/server.ts': `export class ApiServer {
      constructor(private db: any, private config: any) {}
      
      listen(): void {
        console.log(\`API listening on port \${this.config.port}\`);
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'app-architecture.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            include: ['src/**/*.ts'],
            rankingStrategy: 'pagerank',
            rendererOptions: {
              customHeader: '# Application Architecture\n\nOverview of the application structure.',
              includeMermaidGraph: true,
              includeSymbolDetails: true
            }
          });

          const content = await readFile(outputPath);
          
          expect(content).toStartWith('# Application Architecture');
          expect(content).toContain('App');
          expect(content).toContain('Database');
          expect(content).toContain('ApiServer');
          expect(content).toContain('Config');
          expect(containsValidMermaid(content)).toBe(true);
        });

        it('should handle monorepo-style project structure', async () => {
          const files = {
            'packages/core/src/index.ts': `export { Engine } from './engine.js';`,
            'packages/core/src/engine.ts': `export class Engine {
      start(): void {
        console.log('Engine started');
      }
    }`,
            'packages/ui/src/index.ts': `export { Component } from './component.js';`,
            'packages/ui/src/component.ts': `import { Engine } from '../../core/src/engine.js';

    export class Component {
      private engine: Engine;
      
      constructor() {
        this.engine = new Engine();
      }
      
      render(): void {
        this.engine.start();
      }
    }`,
            'apps/web/src/main.ts': `import { Component } from '../../../packages/ui/src/component.js';

    const component = new Component();
    component.render();`
          };
          await createTestFiles(tempDir, files);

          const outputPath = path.join(tempDir, 'monorepo.md');
          await generateMap({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts'],
            rendererOptions: {
              customHeader: '# Monorepo Structure',
              includeMermaidGraph: true,
              includeSymbolDetails: true
            }
          });

          const content = await readFile(outputPath);
          
          expect(content).toContain('Engine');
          expect(content).toContain('Component');
          expect(content).toContain('packages/core/src/engine.ts');
          expect(content).toContain('packages/ui/src/component.ts');
          expect(content).toContain('apps/web/src/main.ts');
          expect(containsValidMermaid(content)).toBe(true);
        });
      });
    });
approved: true
