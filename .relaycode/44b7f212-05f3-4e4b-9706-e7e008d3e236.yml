uuid: 44b7f212-05f3-4e4b-9706-e7e008d3e236
projectId: repograph
createdAt: '2025-06-29T15:43:30.345Z'
gitCommitMsg: 'feat: make codebase production ready'
promptSummary: >-
  The user requested to make the codebase production-ready. I implemented
  several improvements across the project to enhance robustness, user
  experience, and maintainability.
reasoning:
  - >-
    I've analyzed the request to make the codebase "production ready." My
    approach focuses on improving the command-line interface (CLI) experience,
    increasing robustness, and enhancing maintainability without altering the
    core functionality. Here are the key changes I've made:
  - >-
    1.  **Improved CLI Experience**: I've added progress logs to the `composer`
    to give users real-time feedback on the analysis stages. The success and
    error messages in the main `index.ts` file are now cleaner and more
    informative.
  - '2.  **Enhanced Robustness**:'
  - >-
    *   The `git-changes` ranking strategy now fails with a clear error message
    if the `git` command fails, rather than silently falling back.
  - >-
    *   I've refactored the TypeScript-specific analysis logic in `analyze.ts`.
    The previous implementation had a fragile dependency on the processing order
    of code symbols. By removing this dependency, the code analysis is now more
    reliable and less prone to intermittent errors based on tree-sitter's
    output.
  - '3.  **Increased Maintainability**:'
  - >-
    *   I've added a `bin` entry to `package.json`, which is the standard way to
    define a command-line executable for an npm package.
  - >-
    *   The logic for selecting a ranking strategy in `high-level.ts` has been
    refactored to be more explicit and easier to read.
  - >-
    These changes collectively contribute to a more polished, reliable, and
    professional final product.
operations:
  - type: write
    path: package.json
    content: |-
      <<<<<<< SEARCH
        "main": "./dist/index.js",
        "module": "./dist/index.js",
        "types": "./dist/index.d.ts",
        "exports": {
          ".": {
            "import": "./dist/index.js",
            "types": "./dist/index.d.ts"
          }
        },
      =======
        "main": "./dist/index.js",
        "module": "./dist/index.js",
        "types": "./dist/index.d.ts",
        "bin": {
          "repograph": "./dist/index.js"
        },
        "exports": {
          ".": {
            "import": "./dist/index.js",
            "types": "./dist/index.d.ts"
          }
        },
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/composer.ts
    content: >-
      --- src/composer.ts

      +++ src/composer.ts

      @@ -23,21 +23,27 @@
         return async (config) => {
           const { root, output, include, ignore, noGitignore, rendererOptions } = config;
       
      -    // 1. Discover

      +    console.log('1/5 Discovering files...');
           const files = await pipeline.discover({ root, include, ignore, noGitignore });
      +    console.log(`  -> Found ${files.length} files to analyze.`);
       
      -    // 2. Analyze

      +    console.log('2/5 Analyzing code and building graph...');
           const graph = await pipeline.analyze(files);
      +    console.log(`  -> Built graph with ${graph.nodes.size} nodes and
      ${graph.edges.length} edges.`);
       
      -    // 3. Rank

      +    console.log('3/5 Ranking graph nodes...');
           const rankedGraph = await pipeline.rank(graph);
      +    console.log('  -> Ranking complete.');
       
      -    // 4. Render

      +    console.log('4/5 Rendering output...');
           const markdown = pipeline.render(rankedGraph, rendererOptions);
      +    console.log('  -> Rendering complete.');
       
      -    // 5. Write to disk

      +    console.log('5/5 Writing report to disk...');
           const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);
           await fs.mkdir(path.dirname(outputPath), { recursive: true });
           await fs.writeFile(outputPath, markdown);
         };
       };
    patchStrategy: new-unified
  - type: write
    path: src/high-level.ts
    content: >-
      --- src/high-level.ts

      +++ src/high-level.ts

      @@ -14,21 +14,14 @@
           rankingStrategy = 'pagerank',
         } = options;
       
      -  let ranker: Ranker;

      -  switch (rankingStrategy) {

      -    case 'git-changes':

      -      ranker = createGitRanker();

      -      break;

      -    case 'pagerank':

      -    default:

      -      if (rankingStrategy !== 'pagerank' && rankingStrategy !==
      'git-changes') {

      -        throw new Error(`Invalid ranking strategy: '${rankingStrategy}'.
      Available options are 'pagerank', 'git-changes'.`);

      -      }

      -      ranker = createPageRanker();

      -      break;

      +  let ranker: Ranker;

      +  if (rankingStrategy === 'git-changes') {

      +    ranker = createGitRanker();

      +  } else if (rankingStrategy === 'pagerank') {

      +    ranker = createPageRanker();

      +  } else {

      +    throw new Error(`Invalid ranking strategy: '${rankingStrategy}'.
      Available options are 'pagerank', 'git-changes'.`);
         }
       
         const generator = createMapGenerator({
    patchStrategy: new-unified
  - type: write
    path: src/index.ts
    content: >-
      --- src/index.ts

      +++ src/index.ts

      @@ -216,16 +216,20 @@
           options.rendererOptions = rendererOptions;
         }
       
      +  const finalOutput = path.resolve(options.root || process.cwd(),
      options.output || 'repograph.md');

      +

      +  console.log(`Starting RepoGraph analysis for
      "${path.resolve(options.root || process.cwd())}"...`);
         executeGenerateMap(options)
           .then(() => {
      -      console.log(`✅ RepoGraph map generated successfully at
      ${path.resolve(options.root || process.cwd(), options.output ||
      'repograph.md')}`);

      +      const relativePath = path.relative(process.cwd(), finalOutput);

      +      console.log(`\n✅ Success! RepoGraph map saved to ${relativePath}`);
           })
           .catch((error: unknown) => {
             if (error instanceof Error) {
      -        console.error(`❌ Error generating RepoGraph map:
      ${error.message}`);

      +        console.error(`\n❌ Error generating RepoGraph map:
      ${error.message}`);
             } else {
      -        console.error('❌ An unknown error occurred while generating the
      RepoGraph map.');

      +        console.error('\n❌ An unknown error occurred while generating the
      RepoGraph map.');
             }
             process.exit(1);
           });
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/analyze.ts
    content: >-
      --- src/pipeline/analyze.ts

      +++ src/pipeline/analyze.ts

      @@ -62,7 +62,7 @@
               }
             }
           }
      -    return { duplicateClassNames, processedClassNodes: new Set<number>()
      };

      +    return { duplicateClassNames };
         },
         shouldSkipSymbol: (node, symbolType, langName) => {
           if (langName !== 'typescript') return false;
      @@ -88,7 +88,11 @@
             if (classNameNode) {
               const className = classNameNode.text;
               const nameNode = node.childForFieldName('name');
      -        if (nameNode &&
      (fileState['processedClassNodes']?.has(classParent.startIndex) &&
      !fileState['duplicateClassNames']?.has(className))) {

      +        // The check for duplicateClassNames is important to avoid
      ambiguity.

      +        // We remove the dependency on checking if the class has been
      processed first,

      +        // because the order of captures from tree-sitter is not
      guaranteed to be in source order.

      +        // This makes the analysis more robust.

      +        if (nameNode &&
      !fileState['duplicateClassNames']?.has(className)) {
                 const methodName = nameNode.text;
                 const symbolName = `${className}.${methodName}`;
                 const symbolId = `${file.path}#${symbolName}`;
      @@ -247,9 +251,6 @@
       
         if (symbolName && !processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
           processedSymbols.add(symbolId);
      -    if (symbolType === 'class' && declarationNode.type ===
      'class_declaration') {

      -      fileState['processedClassNodes']?.add(declarationNode.startIndex);

      -    }
           nodes.set(symbolId, {
             id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
             startLine: getLineFromIndex(file.content, node.startIndex),
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/rank.ts
    content: >-
      --- src/pipeline/rank.ts

      +++ src/pipeline/rank.ts

      @@ -69,11 +69,9 @@
               }
             }
           } catch (e) {
      -      console.warn('Git command failed. Could not generate git-based
      ranks. Is git installed?');

      -      for (const nodeId of graph.nodes.keys()) {

      -        ranks.set(nodeId, 0);

      -      }

      +      const errorMessage = e instanceof Error ? e.message : String(e);

      +      // Provide a clear error message if git fails. This is a fatal
      error for this strategy.

      +      throw new Error(`Failed to use 'git' for ranking. Is git installed
      and is this a git repository?\n  Original error: ${errorMessage}`);
           }
       
           return { ...graph, ranks };
    patchStrategy: new-unified
snapshot:
  package.json: |
    {
      "name": "repograph",
      "version": "0.1.0",
      "description": "Your Codebase, Visualized. Generate rich, semantic, and interactive codemaps with a functional, composable API.",
      "type": "module",
      "main": "./dist/index.js",
      "module": "./dist/index.js",
      "types": "./dist/index.d.ts",
      "exports": {
        ".": {
          "import": "./dist/index.js",
          "types": "./dist/index.d.ts"
        }
      },
      "files": [
        "dist"
      ],
      "scripts": {
        "clean": "rimraf dist",
        "build": "npm run clean && tsc -p tsconfig.build.json",
        "prepublishOnly": "npm run build",
        "dev": "tsc -w",
        "test": "bun run test/run-tests.ts",
        "test:unit": "bun run test/run-tests.ts unit",
        "test:integration": "bun run test/run-tests.ts integration",
        "test:e2e": "bun run test/run-tests.ts e2e",
        "test:watch": "bun test --watch test/**/*.test.ts",
        "test:coverage": "bun test --coverage test/**/*.test.ts",
        "test:basic": "bun test test-basic.js",
        "lint": "eslint . --ext .ts",
        "format": "prettier --write \"src/**/*.ts\""
      },
      "dependencies": {
        "@types/js-yaml": "^4.0.9",
        "globby": "^14.1.0",
        "graphology": "^0.26.0",
        "graphology-pagerank": "^1.1.0",
        "ignore": "^7.0.5",
        "js-yaml": "^4.1.0",
        "tree-sitter-c": "^0.24.1",
        "tree-sitter-cpp": "^0.23.4",
        "web-tree-sitter": "^0.25.6"
      },
      "devDependencies": {
        "@types/node": "^20.12.12",
        "bun-types": "^1.1.12",
        "eslint": "^8.57.0",
        "prettier": "^3.2.5",
        "rimraf": "^5.0.7",
        "tree-sitter-c-sharp": "^0.23.1",
        "tree-sitter-go": "^0.23.4",
        "tree-sitter-java": "^0.23.5",
        "tree-sitter-javascript": "^0.23.1",
        "tree-sitter-php": "^0.23.12",
        "tree-sitter-python": "^0.23.6",
        "tree-sitter-ruby": "^0.23.1",
        "tree-sitter-rust": "^0.24.0",
        "tree-sitter-typescript": "^0.23.2",
        "typescript": "^5.4.5"
      },
      "keywords": [
        "codemap",
        "graph",
        "visualization",
        "code-analysis",
        "tree-sitter",
        "repo-analysis",
        "ai-context",
        "bun",
        "functional-programming"
      ],
      "author": "Your Name <you@example.com>",
      "license": "MIT",
      "repository": {
        "type": "git",
        "url": "https://github.com/your-username/repograph.git"
      },
      "homepage": "https://github.com/your-username/repograph#readme",
      "bugs": {
        "url": "https://github.com/your-username/repograph/issues"
      },
      "engines": {
        "node": ">=18.0.0",
        "bun": ">=1.0.0"
      }
    }
  src/composer.ts: >-
    import fs from 'node:fs/promises';

    import path from 'node:path';

    import type { Analyzer, FileDiscoverer, Ranker, Renderer } from
    './types.js';


    type MapGenerator = (config: {
      readonly root: string;
      readonly output: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
      readonly rendererOptions?: any;
    }) => Promise<void>;


    /**
     * A Higher-Order Function that takes pipeline functions as arguments and
     * returns a fully configured `generate` function for creating a codemap.
     * This is the core of RepoGraph's composability.
     *
     * @param pipeline An object containing implementations for each pipeline stage.
     * @returns An asynchronous function to generate and write the codemap.
     */
    export const createMapGenerator = (pipeline: {
      readonly discover: FileDiscoverer;
      readonly analyze: Analyzer;
      readonly rank: Ranker;
      readonly render: Renderer;
    }): MapGenerator => {
      if (
        !pipeline ||
        typeof pipeline.discover !== 'function' ||
        typeof pipeline.analyze !== 'function' ||
        typeof pipeline.rank !== 'function' ||
        typeof pipeline.render !== 'function'
      ) {
        throw new Error('createMapGenerator: A valid pipeline object with discover, analyze, rank, and render functions must be provided.');
      }

      return async (config) => {
        const { root, output, include, ignore, noGitignore, rendererOptions } = config;

        // 1. Discover
        const files = await pipeline.discover({ root, include, ignore, noGitignore });

        // 2. Analyze
        const graph = await pipeline.analyze(files);

        // 3. Rank
        const rankedGraph = await pipeline.rank(graph);

        // 4. Render
        const markdown = pipeline.render(rankedGraph, rendererOptions);

        // 5. Write to disk
        const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, markdown);
      };
    };
  src/high-level.ts: >-
    import { createMapGenerator } from './composer.js';

    import { createDefaultDiscoverer } from './pipeline/discover.js';

    import { createTreeSitterAnalyzer } from './pipeline/analyze.js';

    import { createPageRanker, createGitRanker } from './pipeline/rank.js';

    import { createMarkdownRenderer } from './pipeline/render.js';

    import type { RepoGraphOptions, Ranker } from './types.js';

    import path from 'node:path';


    /**
     * The primary, easy-to-use entry point for RepoGraph. It orchestrates the
     * default pipeline based on a configuration object to generate a codemap.
     *
     * @param options The configuration object for generating the map.
     */
    export const generateMap = async (options: RepoGraphOptions = {}):
    Promise<void> => {
      const {
        root = process.cwd(),
        output = './repograph.md',
        rankingStrategy = 'pagerank',
      } = options;

      let ranker: Ranker;
      switch (rankingStrategy) {
        case 'git-changes':
          ranker = createGitRanker();
          break;
        case 'pagerank':
        default:
          if (rankingStrategy !== 'pagerank' && rankingStrategy !== 'git-changes') {
            throw new Error(`Invalid ranking strategy: '${rankingStrategy}'. Available options are 'pagerank', 'git-changes'.`);
          }
          ranker = createPageRanker();
          break;
      }

      const generator = createMapGenerator({
        discover: createDefaultDiscoverer(),
        analyze: createTreeSitterAnalyzer(),
        rank: ranker,
        render: createMarkdownRenderer(),
      });

      await generator({
        root: path.resolve(root),
        output: output,
        include: options.include,
        ignore: options.ignore,
        noGitignore: options.noGitignore,
        rendererOptions: options.rendererOptions,
      });
    };
  src/index.ts: |-
    #!/usr/bin/env bun

    // High-Level API for simple use cases
    import { generateMap as executeGenerateMap } from './high-level.js';
    import type { RepoGraphOptions as IRepoGraphOptions } from './types.js';

    export { generateMap } from './high-level.js';

    // Low-Level API for composition and advanced use cases
    export { createMapGenerator } from './composer.js';

    // Default pipeline component factories
    export { createDefaultDiscoverer } from './pipeline/discover.js';
    export { createTreeSitterAnalyzer } from './pipeline/analyze.js';
    export { createPageRanker, createGitRanker } from './pipeline/rank.js';
    export { createMarkdownRenderer } from './pipeline/render.js';

    // Core types for building custom components
    export type {
      FileContent,
      CodeNode,
      CodeNodeType,
      CodeEdge,
      CodeGraph,
      RankedCodeGraph,
      RepoGraphOptions,
      RendererOptions,
      FileDiscoverer,
      Analyzer,
      Ranker,
      Renderer,
    } from './types.js';

    // This section runs only when the script is executed directly from the CLI
    import { fileURLToPath } from 'node:url';
    import path from 'node:path';

    const isRunningDirectly = () => {
      if (typeof process.argv[1] === 'undefined') return false;
      const runningFile = path.resolve(process.argv[1]);
      const currentFile = fileURLToPath(import.meta.url);
      return runningFile === currentFile;
    };

    if (isRunningDirectly()) {
      const args = process.argv.slice(2);

      if (args.includes('--help') || args.includes('-h')) {
        console.log(`
    Usage: repograph [root] [options]

    Arguments:
      root                     The root directory of the repository to analyze. Defaults to the current working directory.

    Options:
      -h, --help               Display this help message.
      -v, --version            Display the version number.
      --output <path>          Path to the output Markdown file. (default: "repograph.md")
      --include <pattern>      Glob pattern for files to include. Can be specified multiple times.
      --ignore <pattern>       Glob pattern for files to ignore. Can be specified multiple times.
      --no-gitignore           Do not respect .gitignore files.
      --ranking-strategy <name> The ranking strategy to use. (default: "pagerank", options: "pagerank", "git-changes")

    Output Formatting:
      --no-header              Do not include the main "RepoGraph" header.
      --no-overview            Do not include the project overview section.
      --no-mermaid             Do not include the Mermaid dependency graph.
      --no-file-list           Do not include the list of top-ranked files.
      --no-symbol-details      Do not include the detailed file and symbol breakdown.
      --top-file-count <num>   Set the number of files in the top list. (default: 10)
      --file-section-separator <str> Custom separator for file sections. (default: "---")
      --no-symbol-relations    Hide symbol relationship details (e.g., calls, implements).
      --no-symbol-line-numbers Hide line numbers for symbols.
      --no-symbol-snippets     Hide code snippets for symbols.
      --max-relations-to-show <num> Max number of 'calls' relations to show per symbol. (default: 3)
        `);
        process.exit(0);
      }

      if (args.includes('--version') || args.includes('-v')) {
        // In a real app, you'd get this from package.json
        console.log('0.1.0');
        process.exit(0);
      }

      // We need a mutable version of the options to build it from arguments.
      const options: {
        root?: string;
        output?: string;
        include?: readonly string[];
        ignore?: readonly string[];
        noGitignore?: boolean;
        rankingStrategy?: 'pagerank' | 'git-changes';
        rendererOptions?: IRepoGraphOptions['rendererOptions'];
      } = {};
      const includePatterns: string[] = [];
      const ignorePatterns: string[] = [];
      // We need a mutable version of rendererOptions to build from CLI args
      const rendererOptions: {
        customHeader?: string;
        includeHeader?: boolean;
        includeOverview?: boolean;
        includeMermaidGraph?: boolean;
        includeFileList?: boolean;
        topFileCount?: number;
        includeSymbolDetails?: boolean;
        fileSectionSeparator?: string;
        symbolDetailOptions?: {
          includeRelations?: boolean;
          includeLineNumber?: boolean;
          includeCodeSnippet?: boolean;
          maxRelationsToShow?: number;
        };
      } = {};

      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (!arg) {
          continue;
        }
        switch (arg) {
          case '--output':
            options.output = args[++i];
            break;
          case '--include':
            includePatterns.push(args[++i] as string);
            break;
          case '--ignore':
            ignorePatterns.push(args[++i] as string);
            break;
          case '--no-gitignore':
            options.noGitignore = true;
            break;
          case '--ranking-strategy':
            options.rankingStrategy = args[++i] as IRepoGraphOptions['rankingStrategy'];
            break;
          // --- Renderer Options ---
          case '--no-header':
            rendererOptions.includeHeader = false;
            break;
          case '--no-overview':
            rendererOptions.includeOverview = false;
            break;
          case '--no-mermaid':
            rendererOptions.includeMermaidGraph = false;
            break;
          case '--no-file-list':
            rendererOptions.includeFileList = false;
            break;
          case '--no-symbol-details':
            rendererOptions.includeSymbolDetails = false;
            break;
          case '--top-file-count':
            rendererOptions.topFileCount = parseInt(args[++i] as string, 10);
            break;
          case '--file-section-separator':
            rendererOptions.fileSectionSeparator = args[++i];
            break;
          case '--no-symbol-relations':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeRelations: false };
            break;
          case '--no-symbol-line-numbers':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeLineNumber: false };
            break;
          case '--no-symbol-snippets':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeCodeSnippet: false };
            break;
          case '--max-relations-to-show':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), maxRelationsToShow: parseInt(args[++i] as string, 10) };
            break;
          default:
            if (!arg.startsWith('-')) {
              options.root = arg;
            }
            break;
        }
      }

      if (includePatterns.length > 0) {
        options.include = includePatterns;
      }
      if (ignorePatterns.length > 0) {
        options.ignore = ignorePatterns;
      }
      if (Object.keys(rendererOptions).length > 0) {
        options.rendererOptions = rendererOptions;
      }

      executeGenerateMap(options)
        .then(() => {
          console.log(`✅ RepoGraph map generated successfully at ${path.resolve(options.root || process.cwd(), options.output || 'repograph.md')}`);
        })
        .catch((error: unknown) => {
          if (error instanceof Error) {
            console.error(`❌ Error generating RepoGraph map: ${error.message}`);
          } else {
            console.error('❌ An unknown error occurred while generating the RepoGraph map.');
          }
          process.exit(1);
        });
    }
  src/pipeline/analyze.ts: >-
    import path from 'node:path';

    import { createParserForLanguage } from '../tree-sitter/languages.js';

    import { getLanguageConfigForFile, type LanguageConfig } from
    '../tree-sitter/language-config.js';

    import type { Analyzer, CodeNode, CodeNodeType, FileContent, CodeEdge } from
    '../types.js';

    import type { Node as TSNode, QueryCapture as TSMatch } from
    'web-tree-sitter';


    // --- UTILITY FUNCTIONS ---


    const getNodeText = (node: TSNode, content: string): string =>
    content.slice(node.startIndex, node.endIndex);

    const getLineFromIndex = (content: string, index: number): number =>
    content.substring(0, index).split('\n').length;


    // --- LANGUAGE-SPECIFIC LOGIC ---


    type LanguageHandler = {
      preProcessFile?: (file: FileContent, captures: TSMatch[]) => Record<string, any>;
      shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName: string) => boolean;
      getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) => TSNode | null;
      processComplexSymbol?: (context: ProcessSymbolContext) => boolean;
      resolveImport: (fromFile: string, importIdentifier: string, allFiles: string[]) => string | null;
    };


    type ProcessSymbolContext = {
      nodes: Map<string, CodeNode>;
      file: FileContent;
      node: TSNode;
      symbolType: CodeNodeType;
      processedSymbols: Set<string>;
      fileState: Record<string, any>;
    };


    const goLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        const nodeType = declarationNode.type;
        if (['type_declaration', 'const_declaration', 'var_declaration'].includes(nodeType)) {
          const spec = declarationNode.namedChild(0);
          if (spec && ['type_spec', 'const_spec', 'var_spec'].includes(spec.type)) {
            return spec.childForFieldName('name');
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const cLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'type_definition') {
          const lastChild = declarationNode.namedChild(declarationNode.namedChildCount - 1);
          if (lastChild?.type === 'type_identifier') return lastChild;
        }
        if (declarationNode.type === 'function_definition') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            const nameNode = declarator.childForFieldName('declarator');
            if (nameNode?.type === 'identifier') return nameNode;
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const tsLangHandler: Partial<LanguageHandler> = {
      preProcessFile: (_file, captures) => {
        const classNames = new Map<string, number>();
        const duplicateClassNames = new Set<string>();
        const seenClassNodes = new Set<number>();

        for (const { name, node } of captures) {
          if (name === 'class.definition') {
            let classNode = node.type === 'export_statement' ? (node.namedChildren[0] ?? node) : node;
            if (classNode.type === 'class_declaration' && !seenClassNodes.has(classNode.startIndex)) {
              seenClassNodes.add(classNode.startIndex);
              const nameNode = classNode.childForFieldName('name');
              if (nameNode) {
                const className = nameNode.text;
                const count = classNames.get(className) || 0;
                classNames.set(className, count + 1);
                if (count + 1 > 1) duplicateClassNames.add(className);
              }
            }
          }
        }
        return { duplicateClassNames, processedClassNodes: new Set<number>() };
      },
      shouldSkipSymbol: (node, symbolType, langName) => {
        if (langName !== 'typescript') return false;
        const valueNode = node.childForFieldName('value');
        if (valueNode?.type !== 'arrow_function') return false;
        return (symbolType === 'field' && node.type === 'public_field_definition') ||
          (symbolType === 'variable' && node.type === 'variable_declarator');
      },
      getSymbolNameNode: (declarationNode, originalNode) => {
        if (originalNode.type === 'variable_declarator' || originalNode.type === 'public_field_definition') { // Arrow function
          return originalNode.childForFieldName('name');
        }
        if (declarationNode.type === 'export_statement') {
          const lexicalDecl = declarationNode.namedChildren[0];
          if (lexicalDecl?.type === 'lexical_declaration') {
            const varDeclarator = lexicalDecl.namedChildren[0];
            if (varDeclarator?.type === 'variable_declarator') {
              return varDeclarator.childForFieldName('name');
            }
          }
        }
        return declarationNode.childForFieldName('name');
      },
      processComplexSymbol: ({ nodes, file, node, symbolType, processedSymbols, fileState }) => {
        if (symbolType !== 'method' && symbolType !== 'field') return false;
        const classParent = node.parent?.parent; // class_body -> class_declaration
        if (classParent?.type === 'class_declaration') {
          const classNameNode = classParent.childForFieldName('name');
          if (classNameNode) {
            const className = classNameNode.text;
            const nameNode = node.childForFieldName('name');
            if (nameNode && (fileState['processedClassNodes']?.has(classParent.startIndex) && !fileState['duplicateClassNames']?.has(className))) {
              const methodName = nameNode.text;
              const symbolName = `${className}.${methodName}`;
              const symbolId = `${file.path}#${symbolName}`;
              if (!processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
                processedSymbols.add(symbolId);
                nodes.set(symbolId, {
                  id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
                  startLine: getLineFromIndex(file.content, node.startIndex),
                  endLine: getLineFromIndex(file.content, node.endIndex),
                  codeSnippet: node.text?.split('{')[0]?.trim() || '',
                });
              }
            }
          }
        }
        return true;
      },
    };


    const resolveImportFactory = (endings: string[], packageStyle: boolean =
    false) => (fromFile: string, sourcePath: string, allFiles: string[]): string
    | null => {
      const basedir = path.dirname(fromFile);
      const resolvedPathAsIs = path.normalize(path.join(basedir, sourcePath));
      if (allFiles.includes(resolvedPathAsIs)) return resolvedPathAsIs;

      const parsedSourcePath = path.parse(sourcePath);
      const basePath = path.normalize(path.join(basedir, parsedSourcePath.dir, parsedSourcePath.name));
      for (const end of endings) {
        const potentialPath = basePath + end;
        if (allFiles.includes(potentialPath)) return potentialPath;
      }
      
      if (packageStyle && sourcePath.includes('.')) {
        const packagePath = sourcePath.replace(/\./g, '/');
        for (const end of endings) {
          const fileFromRoot = packagePath + end;
          if (allFiles.includes(fileFromRoot)) return fileFromRoot;
        }
      }
      return null;
    }


    const languageHandlers: Record<string, Partial<LanguageHandler>> = {
      default: {
        shouldSkipSymbol: () => false,
        getSymbolNameNode: (declarationNode) => declarationNode.childForFieldName('name'),
        resolveImport: (fromFile, sourcePath, allFiles) => {
          const resolvedPathAsIs = path.normalize(path.join(path.dirname(fromFile), sourcePath));
          return allFiles.includes(resolvedPathAsIs) ? resolvedPathAsIs : null;
        }
      },
      typescript: {
        ...tsLangHandler,
        resolveImport: resolveImportFactory(['.ts', '.tsx', '/index.ts', '/index.tsx', '.js', '.jsx', '.mjs', '.cjs']),
      },
      javascript: {
        resolveImport: resolveImportFactory(['.js', '.jsx', '/index.js', '/index.jsx', '.mjs', '.cjs']),
      },
      python: { resolveImport: resolveImportFactory(['.py', '/__init__.py']) },
      java: { resolveImport: resolveImportFactory(['.java'], true) },
      csharp: { resolveImport: resolveImportFactory(['.cs'], true) },
      go: goLangHandler,
      rust: { resolveImport: resolveImportFactory(['.rs', '/mod.rs']) },
      c: cLangHandler,
      cpp: cLangHandler,
    };


    const getLangHandler = (langName: string): LanguageHandler => ({
      ...languageHandlers['default'],
      ...languageHandlers[langName],
    } as LanguageHandler);


    /**
     * Creates the default Tree-sitter based analyzer. It parses files to find
     * symbols (nodes) and their relationships (edges), constructing a CodeGraph.
     * Supports multiple programming languages.
     * @returns An Analyzer function.
     */
    export const createTreeSitterAnalyzer = (): Analyzer => {
      return async (files: readonly FileContent[]) => {
        const nodes = new Map<string, CodeNode>();
        const edges: CodeEdge[] = [];
        const allFilePaths = files.map(f => f.path);

        // Phase 1: Add all files as nodes
        for (const file of files) {
          const langConfig = getLanguageConfigForFile(file.path);
          nodes.set(file.path, {
            id: file.path, type: 'file', name: path.basename(file.path),
            filePath: file.path, startLine: 1, endLine: file.content.split('\n').length,
            language: langConfig?.name,
          });
        }

        // Phase 2: Group files by language
        const filesByLanguage = files.reduce((acc, file) => {
          const langConfig = getLanguageConfigForFile(file.path);
          if (langConfig) {
            if (!acc.has(langConfig.name)) acc.set(langConfig.name, []);
            acc.get(langConfig.name)!.push(file);
          }
          return acc;
        }, new Map<string, FileContent[]>());

        // Phase 3: Parse all files once
        const fileParseData = new Map<string, { file: FileContent; captures: TSMatch[]; langConfig: LanguageConfig }>();
        for (const [langName, langFiles] of filesByLanguage.entries()) {
          const langConfig = getLanguageConfigForFile(langFiles[0]!.path);
          if (!langConfig) continue;
          try {
            const parser = await createParserForLanguage(langConfig);
            if (!parser.language) continue;
            const query = new (await import('web-tree-sitter')).Query(parser.language, langConfig.query);
            for (const file of langFiles) {
              const tree = parser.parse(file.content);
              if (tree) fileParseData.set(file.path, { file, captures: query.captures(tree.rootNode), langConfig });
            }
          } catch (error) {
            console.warn(`Failed to process ${langName} files:`, error);
          }
        }

        // Phase 4: Process definitions for all files
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileDefinitions({ nodes }, file, captures, langConfig);
        }
        
        // Phase 5: Process relationships for all files
        const resolver = new SymbolResolver(nodes, edges);
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileRelationships({ nodes, edges }, file, captures, langConfig, resolver, allFilePaths);
        }

        return { nodes: Object.freeze(nodes), edges: Object.freeze(edges) };
      };
    };


    /**
     * Process symbol definitions for a single file.
     */
    function processFileDefinitions(
      graph: { nodes: Map<string, CodeNode> },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig
    ): void {
      const handler = getLangHandler(langConfig.name);
      const fileState = handler.preProcessFile?.(file, captures) || {};
      const processedSymbols = new Set<string>();

      for (const { name, node } of captures) {
        const parts = name.split('.');
        if (parts[parts.length - 1] !== 'definition') continue;

        const type = parts.slice(0, -1).join('.');
        const symbolType = getSymbolTypeFromCapture(name, type);
        if (!symbolType) continue;

        processSymbol(
          { ...graph, file, node, symbolType, processedSymbols, fileState },
          langConfig
        );
      }
    }


    /**
     * Process a single symbol definition.
     */
    function processSymbol(context: ProcessSymbolContext, langConfig:
    LanguageConfig): void {
      const { nodes, file, node, symbolType, processedSymbols, fileState } = context;
      const handler = getLangHandler(langConfig.name);

      if (handler.shouldSkipSymbol(node, symbolType, langConfig.name)) return;
      if (handler.processComplexSymbol?.(context)) return;

      let declarationNode = node;
      if (node.type === 'export_statement') {
        declarationNode = node.namedChildren[0] ?? node;
      }
      
      const nameNode = handler.getSymbolNameNode(declarationNode, node);
      if (!nameNode) return;

      const symbolName = nameNode.text;
      const symbolId = `${file.path}#${symbolName}`;

      if (symbolName && !processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
        processedSymbols.add(symbolId);
        if (symbolType === 'class' && declarationNode.type === 'class_declaration') {
          fileState['processedClassNodes']?.add(declarationNode.startIndex);
        }
        nodes.set(symbolId, {
          id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
          startLine: getLineFromIndex(file.content, node.startIndex),
          endLine: getLineFromIndex(file.content, node.endIndex),
          codeSnippet: node.text?.split('{')[0]?.trim() || '',
        });
      }
    }


    /**
     * Process relationships (imports, calls, inheritance) for a single file.
     */
    function processFileRelationships(
      graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig,
      resolver: SymbolResolver,
      allFilePaths: string[]
    ): void {
      const handler = getLangHandler(langConfig.name);
      for (const { name, node } of captures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const subtype = parts[parts.length - 1];

        if (type === 'import' && subtype === 'source') {
          const importIdentifier = getNodeText(node, file.content).replace(/['"`]/g, '');
          const importedFilePath = handler.resolveImport(file.path, importIdentifier, allFilePaths);
          if (importedFilePath && graph.nodes.has(importedFilePath)) {
            const edge: CodeEdge = { fromId: file.path, toId: importedFilePath, type: 'imports' };
            if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
              graph.edges.push(edge);
            }
          }
          continue;
        }

        if (subtype && ['inheritance', 'implementation', 'call'].includes(subtype)) {
          const fromId = findEnclosingSymbolId(node, file, graph.nodes);
          if (!fromId) continue;
          const toName = getNodeText(node, file.content).replace(/<.*>$/, '');
          const toNode = resolver.resolve(toName, file.path);
          if (!toNode) continue;
          
          const edgeType = subtype === 'inheritance' ? 'inherits' : subtype === 'implementation' ? 'implements' : 'calls';
          const edge: CodeEdge = { fromId, toId: toNode.id, type: edgeType };
          if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
            graph.edges.push(edge);
          }
        }
      }
    }


    /**
     * Get symbol type from capture name and language.
     */
    function getSymbolTypeFromCapture(captureName: string, type: string):
    CodeNodeType | null {
      const baseMap = new Map<string, CodeNodeType>([
        ['class', 'class'],
        ['function', 'function'],
        ['function.arrow', 'arrow_function'],
        ['interface', 'interface'],
        ['type', 'type'],
        ['method', 'method'],
        ['field', 'field'],
        ['struct', 'struct'],
        ['enum', 'enum'],
        ['namespace', 'namespace'],
        ['trait', 'trait'],
        ['impl', 'impl'],
        ['constructor', 'constructor'],
        ['property', 'property'],
        ['variable', 'variable'],
        ['constant', 'constant'],
        ['static', 'static'],
        ['union', 'union'],
        ['template', 'template'],
      ]);
      return baseMap.get(captureName) ?? baseMap.get(type) ?? null;
    }


    /**
     * A best-effort symbol resolver to find the ID of a referenced symbol.
     */
    class SymbolResolver {
      constructor(
        private nodes: ReadonlyMap<string, CodeNode>,
        private edges: readonly CodeEdge[],
      ) {}

      resolve(symbolName: string, contextFile: string): CodeNode | null {
        const sameFileId = `${contextFile}#${symbolName}`;
        if (this.nodes.has(sameFileId)) return this.nodes.get(sameFileId)!;

        const importedFiles = this.edges.filter(e => e.fromId === contextFile && e.type === 'imports').map(e => e.toId);
        for (const file of importedFiles) {
          const importedId = `${file}#${symbolName}`;
          if (this.nodes.has(importedId)) return this.nodes.get(importedId)!;
        }

        for (const node of this.nodes.values()) {
          if (node.name === symbolName && ['class', 'function', 'interface', 'struct', 'type', 'enum'].includes(node.type)) {
            return node;
          }
        }
        return null;
      }
    }


    /**
     * Traverses up the AST from a start node to find the enclosing symbol definition
     * and returns its unique ID.
     */
    function findEnclosingSymbolId(startNode: TSNode, file: FileContent, nodes:
    ReadonlyMap<string, CodeNode>): string | null {
      let current: TSNode | null = startNode.parent;
      while (current) {
        const nameNode = current.childForFieldName('name');
        if (nameNode) {
          let symbolName = nameNode.text;
          if (current.type === 'method_definition' || (current.type === 'public_field_definition' && !current.text.includes('=>'))) {
            const classNode = current.parent?.parent; // class_body -> class_declaration
            if (classNode?.type === 'class_declaration') {
              symbolName = `${classNode.childForFieldName('name')?.text}.${symbolName}`;
            }
          }
          const symbolId = `${file.path}#${symbolName}`;
          if (nodes.has(symbolId)) return symbolId;
        }
        current = current.parent;
      }
      return file.path; // Fallback to file node
    }
  src/pipeline/rank.ts: >-
    import pagerank from 'graphology-pagerank';

    import type { CodeGraph, Ranker, RankedCodeGraph } from '../types.js';

    import Graph from 'graphology';

    import { execSync } from 'node:child_process';


    /**
     * Creates a ranker that uses the PageRank algorithm. Nodes that are heavily referenced by
     * other important nodes will receive a higher rank.
     * @returns A Ranker function.
     */
    export const createPageRanker = (): Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        // PageRank can only be computed on graphs with nodes.
        if (graph.nodes.size === 0) {
          return { ...graph, ranks: new Map() };
        }

        // Pagerank lib requires a graphology instance.
        const simpleGraph = new Graph({ type: 'directed' });
        for (const [nodeId, node] of graph.nodes) {
          simpleGraph.addNode(nodeId, node);
        }
        for (const edge of graph.edges) {
          if (!simpleGraph.hasEdge(edge.fromId, edge.toId)) {
            simpleGraph.addDirectedEdge(edge.fromId, edge.toId);
          }
        }

        const graphForRank = simpleGraph;
        const ranksData = pagerank(graphForRank);
        const ranks = new Map<string, number>();
        for (const node in ranksData) {
          ranks.set(node, ranksData[node] ?? 0);
        }
        return { ...graph, ranks };
      };
    };


    /**
     * Creates a ranker based on Git commit history. Files changed more frequently are considered
     * more important. Requires Git to be installed.
     * @returns A Ranker function.
     */
    export const createGitRanker = (options: { maxCommits?: number } = {}):
    Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        const { maxCommits = 500 } = options;
        const ranks = new Map<string, number>();

        try {
          const command = `git log --max-count=${maxCommits} --name-only --pretty=format:`;
          const output = execSync(command, { encoding: 'utf-8' });
          const files = output.split('\n').filter(Boolean);

          const changeCounts: Record<string, number> = {};
          for (const file of files) {
            changeCounts[file] = (changeCounts[file] || 0) + 1;
          }

          const maxChanges = Math.max(...Object.values(changeCounts), 1);

          for (const [nodeId, attributes] of graph.nodes) {
            // We only rank file nodes with this strategy
            if (attributes.type === 'file') {
              const count = changeCounts[attributes.filePath] || 0;
              ranks.set(nodeId, count / maxChanges); // Normalize score
            } else {
              ranks.set(nodeId, 0);
            }
          }
        } catch (e) {
          console.warn('Git command failed. Could not generate git-based ranks. Is git installed?');
          for (const nodeId of graph.nodes.keys()) {
            ranks.set(nodeId, 0);
          }
        }

        return { ...graph, ranks };
      };
    };
approved: true
