uuid: 44b7f739-16e5-4d7a-85d1-67895e63412e
projectId: repograph
createdAt: '2025-06-29T01:51:59.456Z'
gitCommitMsg: 'fix(core): Resolve widespread test failures'
promptSummary: >-
  Fix a large number of failing tests reported by `bun test`. The errors include
  pagerank failures on multigraphs, incorrect symbol analysis, and flawed test
  logic. The goal is to make all tests pass by addressing the underlying core
  issues.
reasoning:
  - >-
    Of course. I've analyzed the test failures and prepared a set of patches to
    address the root causes. The primary issues are related to how the analysis
    graph is constructed, how symbols are parsed, and some logical errors within
    the tests themselves.
  - Here are the step-by-step changes to fix the build.
  - '### Step 1: Fix PageRank by Disabling Multi-Graph'
  - >-
    The `graphology-pagerank` library, which is used for ranking, does not
    support multi-graphs (graphs with multiple edges between the same two
    nodes). The analyzer was creating a multi-graph, causing many tests to fail
    at the ranking stage. I'll configure the graph to be a simple directed
    graph.
  - '### Step 2: Improve Tree-sitter Queries for Accuracy'
  - >-
    The existing Tree-sitter queries were failing to capture some symbols
    correctly (like exported arrow functions) and were omitting the `export`
    keyword from code snippets. These updated queries will correctly capture the
    entire definition, including exports, which fixes several analysis and
    rendering test failures.
  - '### Step 3: Refactor the Analyzer to Use New Queries'
  - >-
    With the more robust queries, I'll refactor the analyzer. It will now
    iterate through definition captures, deduplicate them (since exports and
    non-exports are captured), and correctly extract the symbol name and full
    code snippet. This is a more reliable approach than the previous
    implementation.
  - '### Step 4: Fix File Discovery Logic'
  - >-
    A test for discovering dotfiles was failing because the discoverer was
    hardcoded to ignore the `.gitignore` file itself. I'll remove this exclusion
    to allow the test to pass and to make the behavior consistent.
  - '### Step 5: Add Validation to the Composer'
  - >-
    The tests revealed that the `createMapGenerator` function didn't validate
    its inputs, allowing it to proceed with missing pipeline components. I will
    add runtime checks to ensure all required components are provided and are
    functions, making the composer more robust.
  - '### Step 6: Correct Flawed Test Logic'
  - >-
    Finally, I'll fix a couple of tests that had incorrect assertions or buggy
    implementations.
  - >-
    First, in the rendering test, an assertion was incorrectly checking the
    entire markdown output for the absence of low-ranked files, failing to
    account for the complete file list section. I'll scope the assertion to only
    the "Top 10" section.
  - >-
    Next, a test in the composer suite that combines custom components had a bug
    in its mock `FileDiscoverer`, causing it to add duplicate files to the
    analysis pipeline. I'll correct the implementation of this test-specific
    discoverer.
  - These changes should resolve all the reported test failures.
operations:
  - type: write
    path: src/pipeline/analyze.ts
    content: |-
      --- src/pipeline/analyze.ts
      +++ src/pipeline/analyze.ts
      @@ -23,9 +23,9 @@
           const query = tsLang.query(TS_QUERY);
       
           const graph: Graph<CodeNode> = new Graph({
      -      multi: true,
             allowSelfLoops: false,
             type: 'directed',
      +      multi: false,
           });
       
           // Phase 1: Add all files as nodes
    patchStrategy: new-unified
  - type: write
    path: src/tree-sitter/queries.ts
    content: >-
      /**
       * Tree-sitter query for TypeScript and JavaScript to capture key symbols.
       * This query is designed to find definitions of classes, functions, interfaces,
       * and import statements to build the code graph.
       */
      export const TS_QUERY = `

      (import_statement
        source: (string) @import.source) @import.statement

      (class_declaration) @class.definition

      (export_statement declaration: (class_declaration)) @class.definition


      (function_declaration) @function.definition

      (export_statement declaration: (function_declaration))
      @function.definition


      (lexical_declaration (variable_declarator value: (arrow_function)))
      @function.arrow.definition

      (export_statement declaration: (lexical_declaration (variable_declarator
      value: (arrow_function)))) @function.arrow.definition


      (interface_declaration) @interface.definition

      (export_statement declaration: (interface_declaration))
      @interface.definition


      (type_alias_declaration) @type.definition

      (export_statement declaration: (type_alias_declaration)) @type.definition

      `;
    patchStrategy: replace
  - type: write
    path: src/pipeline/analyze.ts
    content: >-
      --- src/pipeline/analyze.ts

      +++ src/pipeline/analyze.ts

      @@ -46,47 +46,55 @@
             }
             const captures = query.captures(tree.rootNode);
       
      +      const processedDefinitions = new Set<number>();

      +
             for (const { name, node } of captures) {
               const [type, subtype] = name.split('.');
               
               if (type === 'import' && subtype === 'source') {
      -            const sourcePath = getNodeText(node,
      file.content).replace(/['"`]/g, '');

      -            const fromFileId = file.path;

      -            const toFileId = path.join(path.dirname(fromFileId),
      sourcePath).replace(/\.(ts|js)x?$/, '') + '.ts'; // Simplistic resolution

      -             

      -            if (graph.hasNode(toFileId)) {

      -                if(!graph.hasEdge(fromFileId, toFileId)) {

      -                   graph.addDirectedEdge(fromFileId, toFileId, { type:
      'imports' });

      -                }

      -            }

      -            continue;

      -        }

      +          const sourcePath = getNodeText(node,
      file.content).replace(/['"`]/g, '');

      +          const fromFileId = file.path;

      +          const toFileId = path.join(path.dirname(fromFileId),
      sourcePath).replace(/\.(ts|js)x?$/, '') + '.ts'; // Simplistic resolution

      +           

      +          if (graph.hasNode(toFileId)) {

      +            if (!graph.hasEdge(fromFileId, toFileId)) {

      +              graph.addDirectedEdge(fromFileId, toFileId, { type:
      'imports' });

      +            }

      +          }

      +          continue;

      +        }

      +

      +        if (subtype !== 'definition') continue;

      +        if (processedDefinitions.has(node.startIndex)) continue;

      +        processedDefinitions.add(node.startIndex);
       
               const definitionMap: Record<string, CodeNodeType> = {
      -          'class': 'class',

      -          'function': 'function',

      +          class: 'class',

      +          function: 'function',
                 'function.arrow': 'arrow_function',
      -          'interface': 'interface',

      -          'type': 'type',

      +          interface: 'interface',

      +          type: 'type',
               };
      +        const symbolType = definitionMap[type!];

      +        if (!symbolType) continue;
       
      -        if (subtype === 'name' && type && definitionMap[type]) {

      -          const symbolType = definitionMap[type];

      -          const symbolName = getNodeText(node, file.content);

      +        // For exports, the actual declaration is nested.

      +        const declarationNode = node.type === 'export_statement' ?
      node.namedChildren[0] : node;

      +        if (!declarationNode) continue;

      +

      +        const nameNode = declarationNode.childForFieldName('name') ??
      declarationNode.firstNamedChild?.childForFieldName('name');

      +

      +        if (nameNode) {

      +          const symbolName = nameNode.text;
                 const symbolId = `${file.path}#${symbolName}`;
      -          
                 if (!graph.hasNode(symbolId)) {
      -            const definitionNode = captures.find((c: any) =>
      c.name.endsWith('.definition') &&
      c.node.equals(node.parent?.parent))?.node ?? node.parent;

      -            if (definitionNode) {

      -              graph.addNode(symbolId, {

      -                id: symbolId,

      -                type: symbolType,

      -                name: symbolName,

      -                filePath: file.path,

      -                startLine: getLineFromIndex(file.content,
      definitionNode.startIndex),

      -                endLine: getLineFromIndex(file.content,
      definitionNode.endIndex),

      -                codeSnippet: definitionNode.text?.split('{')[0]?.trim()
      || '',

      -              });

      -              // Add edge from file to the symbol it contains

      -              graph.addDirectedEdge(file.path, symbolId, { type:
      'contains' });

      -            }

      +            graph.addNode(symbolId, {

      +              id: symbolId, type: symbolType, name: symbolName, filePath:
      file.path,

      +              startLine: getLineFromIndex(file.content, node.startIndex),

      +              endLine: getLineFromIndex(file.content, node.endIndex),

      +              codeSnippet: node.text?.split('{')[0]?.trim() || '',

      +            });

      +            graph.addDirectedEdge(file.path, symbolId, { type: 'contains'
      });
                 }
               }
             }
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/discover.ts
    content: |-
      --- src/pipeline/discover.ts
      +++ src/pipeline/discover.ts
      @@ -40,7 +40,7 @@
           const relativePaths = await globby(patterns, {
             cwd: root,
             gitignore: false, // We handle gitignore manually with the `ignore` package
      -      ignore: [...(ignore || []), '**/node_modules/**', '.gitignore'],
      +      ignore: [...(ignore || []), '**/node_modules/**'],
             dot: true,
             absolute: false,
           });
    patchStrategy: new-unified
  - type: write
    path: src/composer.ts
    content: >-
      --- src/composer.ts

      +++ src/composer.ts

      @@ -19,6 +19,16 @@
         readonly rank: Ranker;
         readonly render: Renderer;
       }): MapGenerator => {
      +  if (

      +    !pipeline ||

      +    typeof pipeline.discover !== 'function' ||

      +    typeof pipeline.analyze !== 'function' ||

      +    typeof pipeline.rank !== 'function' ||

      +    typeof pipeline.render !== 'function'

      +  ) {

      +    throw new Error('createMapGenerator: A valid pipeline object with
      discover, analyze, rank, and render functions must be provided.');

      +  }

      +
         return async (config) => {
           const { root, output, include, ignore, noGitignore, rendererOptions } = config;
    patchStrategy: new-unified
  - type: write
    path: test/unit/render.test.ts
    content: >-
      --- test/unit/render.test.ts

      +++ test/unit/render.test.ts

      @@ -179,15 +179,16 @@
             const rankedGraph: RankedCodeGraph = { graph: graph, ranks };
             const markdown = renderer(rankedGraph);
       
      +      const topFilesSection = markdown.split('## ðŸ“‚ File & Symbol
      Breakdown')[0]!;

      +

      -      expect(markdown).toContain('### Top 10 Most Important Files');

      -      expect(markdown).toContain('| Rank | File | Description |');

      +      expect(topFilesSection).toContain('### Top 10 Most Important
      Files');

      +      expect(topFilesSection).toContain('| Rank | File | Description |');
             
             // Should contain the top 10 files (file15 to file6)
      -      expect(markdown).toContain('`src/file15.ts`');

      -      expect(markdown).toContain('`src/file6.ts`');

      +      expect(topFilesSection).toContain('`src/file15.ts`');

      +      expect(topFilesSection).toContain('`src/file6.ts`');
             
             // Should not contain the lower ranked files
      -      expect(markdown).not.toContain('`src/file1.ts`');

      -      expect(markdown).not.toContain('`src/file5.ts`');

      +      expect(topFilesSection).not.toContain('`src/file1.ts`');

      +      expect(topFilesSection).not.toContain('`src/file5.ts`');
           });
       
           it('should include symbol details by default', () => {
    patchStrategy: new-unified
  - type: write
    path: test/unit/composer.test.ts
    content: >-
      --- test/unit/composer.test.ts

      +++ test/unit/composer.test.ts

      @@ -375,10 +375,8 @@
             // Custom discoverer for .special files
             const customDiscoverer: FileDiscoverer = async (options) => {
               const defaultDiscoverer = createDefaultDiscoverer();
      -        const defaultFiles = await defaultDiscoverer(options);

      -        

      -        // Add special files

      -        const specialFiles = defaultFiles.filter(f =>
      f.path.endsWith('.special'));

      -        return [...defaultFiles, ...specialFiles];

      +        // The original logic had a bug that duplicated files. We just
      need to

      +        // ensure all files are discovered for the test.

      +        return defaultDiscoverer(options);
             };
       
             // Custom analyzer that handles .special files
    patchStrategy: new-unified
snapshot:
  src/pipeline/analyze.ts: >-
    import Graph from 'graphology';

    import path from 'node:path';

    import { getParser } from '../tree-sitter/languages.js';

    import { TS_QUERY } from '../tree-sitter/queries.js';

    import type { Analyzer, CodeNode, CodeNodeType, FileContent } from
    '../types.js';


    const getNodeText = (node: import('web-tree-sitter').Node, content: string):
    string => {
      return content.slice(node.startIndex, node.endIndex);
    };


    const getLineFromIndex = (content: string, index: number): number => {
      return content.substring(0, index).split('\n').length;
    };


    /**
     * Creates the default Tree-sitter based analyzer. It parses files to find
     * symbols (nodes) and their relationships (edges), constructing a CodeGraph.
     * @returns An Analyzer function.
     */
    export const createTreeSitterAnalyzer = (): Analyzer => {
      return async (files: readonly FileContent[]) => {
        const parser = await getParser();
        const tsLang = parser.language;
        if (!tsLang) {
          throw new Error('Parser language not set');
        }
        const query = tsLang.query(TS_QUERY);

        const graph: Graph<CodeNode> = new Graph({
          multi: true,
          allowSelfLoops: false,
          type: 'directed',
        });

        // Phase 1: Add all files as nodes
        for (const file of files) {
          const fileId = file.path;
          if (!graph.hasNode(fileId)) {
            graph.addNode(fileId, {
              id: fileId,
              type: 'file',
              name: path.basename(file.path),
              filePath: file.path,
              startLine: 1,
              endLine: file.content.split('\n').length,
            });
          }
        }

        // Phase 2: Parse files and add symbol nodes and edges
        for (const file of files) {
          const tree = parser.parse(file.content);
          if (!tree) {
            continue; // Skip files that couldn't be parsed
          }
          const captures = query.captures(tree.rootNode);

          for (const { name, node } of captures) {
            const [type, subtype] = name.split('.');
            
            if (type === 'import' && subtype === 'source') {
                const sourcePath = getNodeText(node, file.content).replace(/['"`]/g, '');
                const fromFileId = file.path;
                const toFileId = path.join(path.dirname(fromFileId), sourcePath).replace(/\.(ts|js)x?$/, '') + '.ts'; // Simplistic resolution
                 
                if (graph.hasNode(toFileId)) {
                    if(!graph.hasEdge(fromFileId, toFileId)) {
                       graph.addDirectedEdge(fromFileId, toFileId, { type: 'imports' });
                    }
                }
                continue;
            }

            const definitionMap: Record<string, CodeNodeType> = {
              'class': 'class',
              'function': 'function',
              'function.arrow': 'arrow_function',
              'interface': 'interface',
              'type': 'type',
            };

            if (subtype === 'name' && type && definitionMap[type]) {
              const symbolType = definitionMap[type];
              const symbolName = getNodeText(node, file.content);
              const symbolId = `${file.path}#${symbolName}`;
              
              if (!graph.hasNode(symbolId)) {
                const definitionNode = captures.find((c: any) => c.name.endsWith('.definition') && c.node.equals(node.parent?.parent))?.node ?? node.parent;
                if (definitionNode) {
                  graph.addNode(symbolId, {
                    id: symbolId,
                    type: symbolType,
                    name: symbolName,
                    filePath: file.path,
                    startLine: getLineFromIndex(file.content, definitionNode.startIndex),
                    endLine: getLineFromIndex(file.content, definitionNode.endIndex),
                    codeSnippet: definitionNode.text?.split('{')[0]?.trim() || '',
                  });
                  // Add edge from file to the symbol it contains
                  graph.addDirectedEdge(file.path, symbolId, { type: 'contains' });
                }
              }
            }
          }
        }
        return graph;
      };
    };
  src/tree-sitter/queries.ts: |-
    /**
     * Tree-sitter query for TypeScript and JavaScript to capture key symbols.
     * This query is designed to find definitions of classes, functions, interfaces,
     * and import statements to build the code graph.
     */
    export const TS_QUERY = `
    (import_statement
      source: (string) @import.source) @import.statement

    (class_declaration
      name: (type_identifier) @class.name) @class.definition

    (function_declaration
      name: (identifier) @function.name) @function.definition

    (lexical_declaration
      (variable_declarator
        name: (identifier) @function.arrow.name
        value: (arrow_function)
      )
    ) @function.arrow.definition

    (interface_declaration
      name: (type_identifier) @interface.name) @interface.definition

    (type_alias_declaration
      name: (type_identifier) @type.name) @type.definition
    `;
  src/pipeline/discover.ts: |-
    import { globby } from 'globby';
    import path from 'node:path';
    import fs from 'node:fs/promises';
    import Ignore from 'ignore';
    import type { FileContent, FileDiscoverer } from '../types.js';

    const readGitignore = async (root: string): Promise<string> => {
      try {
        return await fs.readFile(path.join(root, '.gitignore'), 'utf-8');
      } catch {
        return '';
      }
    };

    /**
     * Creates the default file discoverer. It uses globby to find all files,
     * respecting .gitignore patterns and custom include/exclude rules.
     * @returns A FileDiscoverer function.
     */
    export const createDefaultDiscoverer = (): FileDiscoverer => {
      return async ({ root, include, ignore, noGitignore = false }) => {
        try {
          const stats = await fs.stat(root);
          if (!stats.isDirectory()) {
            throw new Error(`Root path is not a directory: ${root}`);
          }
        } catch (e) {
          // Type guard to check for Node.js file system error
          if (e && typeof e === 'object' && 'code' in e && e.code === 'ENOENT') {
            throw new Error(`Root directory does not exist: ${root}`);
          } else {
            throw e;
          }
        }
        const patterns = include && include.length > 0 ? [...include] : ['**/*'];
        
        const ignoreFilter = Ignore();
        if (!noGitignore) {
          const gitignoreContent = await readGitignore(root);
          ignoreFilter.add(gitignoreContent);
        }
        if (ignore) {
          ignoreFilter.add(ignore.join('\n'));
        }

        const relativePaths = await globby(patterns, {
          cwd: root,
          gitignore: false, // We handle gitignore manually with the `ignore` package
          ignore: [...(ignore || []), '**/node_modules/**', '.gitignore'],
          dot: true,
          absolute: false,
        });

        const filteredPaths = relativePaths.filter(p => !ignoreFilter.ignores(p));

        const fileContents = await Promise.all(
          filteredPaths.map(async (relativePath): Promise<FileContent | null> => {
            try {
              const absolutePath = path.join(root, relativePath);
              const buffer = await fs.readFile(absolutePath);
              // A simple heuristic to filter out binary files is checking for a null byte.
              if (buffer.includes(0)) return null;
              const content = buffer.toString('utf-8');
              return { path: relativePath, content };
            } catch {
              // Ignore files that can't be read (e.g., binary files, permission errors)
              return null;
            }
          })
        );

        return fileContents.filter((c): c is FileContent => c !== null);
      };
    };
  src/composer.ts: >-
    import fs from 'node:fs/promises';

    import path from 'node:path';

    import type { Analyzer, FileDiscoverer, Ranker, Renderer } from
    './types.js';


    type MapGenerator = (config: {
      readonly root: string;
      readonly output: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
      readonly rendererOptions?: any;
    }) => Promise<void>;


    /**
     * A Higher-Order Function that takes pipeline functions as arguments and
     * returns a fully configured `generate` function for creating a codemap.
     * This is the core of RepoGraph's composability.
     *
     * @param pipeline An object containing implementations for each pipeline stage.
     * @returns An asynchronous function to generate and write the codemap.
     */
    export const createMapGenerator = (pipeline: {
      readonly discover: FileDiscoverer;
      readonly analyze: Analyzer;
      readonly rank: Ranker;
      readonly render: Renderer;
    }): MapGenerator => {
      return async (config) => {
        const { root, output, include, ignore, noGitignore, rendererOptions } = config;

        // 1. Discover
        const files = await pipeline.discover({ root, include, ignore, noGitignore });

        // 2. Analyze
        const graph = await pipeline.analyze(files);

        // 3. Rank
        const rankedGraph = await pipeline.rank(graph, files);

        // 4. Render
        const markdown = pipeline.render(rankedGraph, rendererOptions);

        // 5. Write to disk
        const outputPath = path.resolve(root, output);
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, markdown);
      };
    };
  test/unit/render.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import type { CodeNode, FileContent, RankedCodeGraph, RendererOptions } from
    '../../src/types.js';

    import Graph from 'graphology';

    import {
      createTempDir,
      cleanupTempDir,
      isValidMarkdown,
      containsValidMermaid,
      extractFilePathsFromMarkdown,
      loadFixture,
      createProjectFromFixture
    } from '../test.util.js';


    describe('Markdown Rendering', () => {
      let tempDir: string;
      let renderer: ReturnType<typeof createMarkdownRenderer>;

      beforeEach(async () => {
        tempDir = await createTempDir();
        renderer = createMarkdownRenderer();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMarkdownRenderer()', () => {
        it('should return a Renderer function', () => {
          expect(typeof renderer).toBe('function');
        });

        it('should generate valid markdown from empty graph', () => {
          const emptyGraph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const rankedGraph: RankedCodeGraph = {
            graph: emptyGraph,
            ranks: new Map()
          };

          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('# RepoGraph');
          expect(markdown).toContain('This repository contains 0 nodes (0 files)');
        });

        it('should include project overview section', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/index.ts', {
            id: 'src/index.ts',
            type: 'file',
            name: 'index.ts',
            filePath: 'src/index.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## ðŸš€ Project Overview');
          expect(markdown).toContain('This repository contains 1 nodes (1 files)');
          expect(markdown).toContain('_Generated by RepoGraph on');
        });

        it('should include Mermaid graph by default', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/a.ts', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### Module Dependency Graph');
          expect(containsValidMermaid(markdown)).toBe(true);
          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
        });

        it('should exclude Mermaid graph when option is false', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/index.ts', {
            id: 'src/index.ts',
            type: 'file',
            name: 'index.ts',
            filePath: 'src/index.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/index.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeMermaidGraph: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('### Module Dependency Graph');
          expect(markdown).not.toContain('```mermaid');
        });

        it('should include top 10 most important files', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const ranks = new Map<string, number>();

          // Create 15 files with different ranks
          for (let i = 1; i <= 15; i++) {
            const nodeId = `src/file${i}.ts`;
            graph.addNode(nodeId, {
              id: nodeId,
              type: 'file',
              name: `file${i}.ts`,
              filePath: nodeId,
              startLine: 1,
              endLine: 10
            });
            ranks.set(nodeId, i / 15); // Higher numbers get higher ranks
          }

          const rankedGraph: RankedCodeGraph = { graph: graph, ranks };
          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### Top 10 Most Important Files');
          expect(markdown).toContain('| Rank | File | Description |');
          
          // Should contain the top 10 files (file15 to file6)
          expect(markdown).toContain('`src/file15.ts`');
          expect(markdown).toContain('`src/file6.ts`');
          
          // Should not contain the lower ranked files
          expect(markdown).not.toContain('`src/file1.ts`');
          expect(markdown).not.toContain('`src/file5.ts`');
        });

        it('should include symbol details by default', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 20
          });

          graph.addNode('src/test.ts#TestClass', {
            id: 'src/test.ts#TestClass',
            type: 'class',
            name: 'TestClass',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 15,
            codeSnippet: 'export class TestClass {'
          });

          graph.addNode('src/test.ts#testFunction', {
            id: 'src/test.ts#testFunction',
            type: 'function',
            name: 'testFunction',
            filePath: 'src/test.ts',
            startLine: 17,
            endLine: 19,
            codeSnippet: 'export function testFunction(): void'
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#TestClass', { type: 'contains' });
          graph.addDirectedEdge('src/test.ts', 'src/test.ts#testFunction', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#TestClass', 0.5],
              ['src/test.ts#testFunction', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('## ðŸ“‚ File & Symbol Breakdown');
          expect(markdown).toContain('### [`src/test.ts`](./src/test.ts)');
          expect(markdown).toContain('**`class TestClass`** - _L5_');
          expect(markdown).toContain('**`function testFunction`** - _L17_');
          expect(markdown).toContain('export class TestClass {');
          expect(markdown).toContain('export function testFunction(): void');
        });

        it('should exclude symbol details when option is false', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/test.ts', 0.5]])
          };

          const options: RendererOptions = {
            includeSymbolDetails: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
        });

        it('should include custom header when provided', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map()
          };

          const customHeader = '# My Custom Project\n\nThis is a custom description.';
          const options: RendererOptions = {
            customHeader
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).toStartWith(customHeader);
          expect(markdown).not.toContain('# RepoGraph');
        });

        it('should handle files with no symbols', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('README.md', {
            id: 'README.md',
            type: 'file',
            name: 'README.md',
            filePath: 'README.md',
            startLine: 1,
            endLine: 5
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['README.md', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`README.md`](./README.md)');
          expect(markdown).toContain('_No symbols identified in this file._');
        });

        it('should sort symbols by line number', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 30
          });

          // Add symbols in non-sequential order
          graph.addNode('src/test.ts#lastFunction', {
            id: 'src/test.ts#lastFunction',
            type: 'function',
            name: 'lastFunction',
            filePath: 'src/test.ts',
            startLine: 25,
            endLine: 28
          });

          graph.addNode('src/test.ts#firstFunction', {
            id: 'src/test.ts#firstFunction',
            type: 'function',
            name: 'firstFunction',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 10
          });

          graph.addNode('src/test.ts#middleClass', {
            id: 'src/test.ts#middleClass',
            type: 'class',
            name: 'middleClass',
            filePath: 'src/test.ts',
            startLine: 15,
            endLine: 20
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#lastFunction', { type: 'contains' });
          graph.addDirectedEdge('src/test.ts', 'src/test.ts#firstFunction', { type: 'contains' });
          graph.addDirectedEdge('src/test.ts', 'src/test.ts#middleClass', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.8],
              ['src/test.ts#lastFunction', 0.3],
              ['src/test.ts#firstFunction', 0.5],
              ['src/test.ts#middleClass', 0.4]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Check that symbols appear in line number order
          const firstFunctionIndex = markdown.indexOf('firstFunction');
          const middleClassIndex = markdown.indexOf('middleClass');
          const lastFunctionIndex = markdown.indexOf('lastFunction');

          expect(firstFunctionIndex).toBeLessThan(middleClassIndex);
          expect(middleClassIndex).toBeLessThan(lastFunctionIndex);
        });

        it('should sort files by rank (highest first)', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const files = [
            { id: 'src/low.ts', rank: 0.2 },
            { id: 'src/high.ts', rank: 0.8 },
            { id: 'src/medium.ts', rank: 0.5 }
          ];

          const ranks = new Map<string, number>();

          for (const file of files) {
            graph.addNode(file.id, {
              id: file.id,
              type: 'file',
              name: file.id.split('/').pop()!,
              filePath: file.id,
              startLine: 1,
              endLine: 10
            });
            ranks.set(file.id, file.rank);
          }

          const rankedGraph: RankedCodeGraph = { graph: graph, ranks };
          const markdown = renderer(rankedGraph);

          // Check order in the file breakdown section
          const highIndex = markdown.indexOf('[`src/high.ts`]');
          const mediumIndex = markdown.indexOf('[`src/medium.ts`]');
          const lowIndex = markdown.indexOf('[`src/low.ts`]');

          expect(highIndex).toBeLessThan(mediumIndex);
          expect(mediumIndex).toBeLessThan(lowIndex);
        });

        it('should handle symbols without code snippets', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/test.ts#noSnippet', {
            id: 'src/test.ts#noSnippet',
            type: 'function',
            name: 'noSnippet',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 8
            // No codeSnippet property
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#noSnippet', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#noSnippet', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function noSnippet`** - _L5_');
          // Should not include empty code block
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });

        it('should generate proper markdown links for files', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/nested/deep/file.ts', {
            id: 'src/nested/deep/file.ts',
            type: 'file',
            name: 'file.ts',
            filePath: 'src/nested/deep/file.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/nested/deep/file.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('### [`src/nested/deep/file.ts`](./src/nested/deep/file.ts)');
        });
      });

      describe('Mermaid Graph Generation', () => {
        it('should only include file nodes in Mermaid graph', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/a.ts#Class', {
            id: 'src/a.ts#Class',
            type: 'class',
            name: 'Class',
            filePath: 'src/a.ts',
            startLine: 2,
            endLine: 8
          });

          graph.addNode('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });
          graph.addDirectedEdge('src/a.ts', 'src/a.ts#Class', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/a.ts#Class', 0.3],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
          expect(markdown).not.toContain('src/a.ts#Class');
        });

        it('should handle graphs with no file-to-file edges', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/isolated.ts', {
            id: 'src/isolated.ts',
            type: 'file',
            name: 'isolated.ts',
            filePath: 'src/isolated.ts',
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([['src/isolated.ts', 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('```mermaid');
          expect(markdown).toContain('graph TD');
          expect(markdown).toContain('```');
        });

        it('should deduplicate edges in Mermaid graph', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/a.ts', {
            id: 'src/a.ts',
            type: 'file',
            name: 'a.ts',
            filePath: 'src/a.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/b.ts', {
            id: 'src/b.ts',
            type: 'file',
            name: 'b.ts',
            filePath: 'src/b.ts',
            startLine: 1,
            endLine: 10
          });

          // Add multiple edges between the same files (multi-graph)
          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });
          graph.addDirectedEdge('src/a.ts', 'src/b.ts', { type: 'imports' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/a.ts', 0.5],
              ['src/b.ts', 0.7]
            ])
          };

          const markdown = renderer(rankedGraph);

          // Should only appear once in the Mermaid graph
          const edgePattern = /src\/a\.ts\["a\.ts"\] --> src\/b\.ts\["b\.ts"\]/g;
          const matches = markdown.match(edgePattern);
          expect(matches).toHaveLength(1);
        });
      });

      describe('Integration with Real Analysis', () => {
        it('should render analyzed TypeScript code correctly', async () => {
          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [
            {
              path: 'src/index.ts',
              content: `import { Calculator } from './calculator.js';

    export { Calculator };


    export function main(): void {
      const calc = new Calculator();
      console.log(calc.add(1, 2));
    }`
            },
            {
              path: 'src/calculator.ts',
              content: `export class Calculator {
      add(a: number, b: number): number {
        return a + b;
      }
      
      subtract = (a: number, b: number): number => {
        return a - b;
      };
    }`
            }
          ];

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Calculator');
          expect(markdown).toContain('**`class Calculator`**');
          expect(markdown).toContain('**`function main`**');
          expect(markdown).toContain('**`arrow_function subtract`**');
          expect(containsValidMermaid(markdown)).toBe(true);
        });
      });

      describe('Integration with Fixtures', () => {
        it('should render sample-project fixture correctly', async () => {
          const fixture = await loadFixture('sample-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Calculator');
          expect(markdown).toContain('Logger');
          expect(markdown).toContain('Config');
          
          const filePaths = extractFilePathsFromMarkdown(markdown);
          expect(filePaths.length).toBeGreaterThan(0);
          expect(filePaths).toContain('src/calculator.ts');
          expect(filePaths).toContain('src/utils/logger.ts');
        });

        it('should render complex-project fixture correctly', async () => {
          const fixture = await loadFixture('complex-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [];
          for (const file of fixture.files) {
            if (file.path.endsWith('.ts') && !file.path.includes('test')) {
              files.push({
                path: file.path,
                content: file.content
              });
            }
          }

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);
          const markdown = renderer(rankedGraph);

          expect(isValidMarkdown(markdown)).toBe(true);
          expect(markdown).toContain('Database');
          expect(markdown).toContain('ApiServer');
          expect(markdown).toContain('UserService');
          expect(containsValidMermaid(markdown)).toBe(true);
        });

        it('should handle all renderer options with fixtures', async () => {
          const fixture = await loadFixture('minimal-project');
          await createProjectFromFixture(tempDir, fixture);

          const analyzer = createTreeSitterAnalyzer();
          const ranker = createPageRanker();

          const files: FileContent[] = [
            {
              path: 'src/main.ts',
              content: fixture.files[0]!.content
            }
          ];

          const graph = await analyzer(files);
          const rankedGraph = await ranker(graph, files);

          const options: RendererOptions = {
            customHeader: '# My Minimal Project\n\nCustom description here.',
            includeMermaidGraph: false,
            includeSymbolDetails: false
          };

          const markdown = renderer(rankedGraph, options);

          expect(markdown).toStartWith('# My Minimal Project');
          expect(markdown).not.toContain('```mermaid');
          expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
          expect(markdown).toContain('### Top 10 Most Important Files');
        });
      });

      describe('Edge Cases', () => {
        it('should handle very long file paths', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const longPath = 'src/very/deeply/nested/directory/structure/with/many/levels/file.ts';
          graph.addNode(longPath, {
            id: longPath,
            type: 'file',
            name: 'file.ts',
            filePath: longPath,
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([[longPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`[\`${longPath}\`](./${longPath})`);
        });

        it('should handle special characters in file names', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          const specialPath = 'src/file-with-dashes_and_underscores.spec.ts';
          graph.addNode(specialPath, {
            id: specialPath,
            type: 'file',
            name: 'file-with-dashes_and_underscores.spec.ts',
            filePath: specialPath,
            startLine: 1,
            endLine: 10
          });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([[specialPath, 0.5]])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain(`\`${specialPath}\``);
        });

        it('should handle empty code snippets gracefully', () => {
          const graph: Graph<CodeNode> = new Graph({
            multi: true,
            allowSelfLoops: false,
            type: 'directed',
          });

          graph.addNode('src/test.ts', {
            id: 'src/test.ts',
            type: 'file',
            name: 'test.ts',
            filePath: 'src/test.ts',
            startLine: 1,
            endLine: 10
          });

          graph.addNode('src/test.ts#empty', {
            id: 'src/test.ts#empty',
            type: 'function',
            name: 'empty',
            filePath: 'src/test.ts',
            startLine: 5,
            endLine: 6,
            codeSnippet: ''
          });

          graph.addDirectedEdge('src/test.ts', 'src/test.ts#empty', { type: 'contains' });

          const rankedGraph: RankedCodeGraph = {
            graph,
            ranks: new Map([
              ['src/test.ts', 0.5],
              ['src/test.ts#empty', 0.3]
            ])
          };

          const markdown = renderer(rankedGraph);

          expect(markdown).toContain('**`function empty`** - _L5_');
          expect(markdown).not.toContain('```typescript\n  \n  ```');
        });
      });
    });
  test/unit/composer.test.ts: >-
    import { describe, it, beforeEach, afterEach, expect } from 'bun:test';

    import { createMapGenerator } from '../../src/composer.js';

    import { createDefaultDiscoverer } from '../../src/pipeline/discover.js';

    import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';

    import { createPageRanker } from '../../src/pipeline/rank.js';

    import { createMarkdownRenderer } from '../../src/pipeline/render.js';

    import type { FileDiscoverer, Analyzer, Ranker, Renderer, FileContent } from
    '../../src/types.js';

    import {
      createTempDir,
      cleanupTempDir,
      createTestFiles,
      assertFileExists,
      readFile,
      isValidMarkdown
    } from '../test.util.js';

    import path from 'node:path';


    describe('Composer', () => {
      let tempDir: string;

      beforeEach(async () => {
        tempDir = await createTempDir();
      });

      afterEach(async () => {
        await cleanupTempDir(tempDir);
      });

      describe('createMapGenerator()', () => {
        it('should return a function when given valid components', () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          expect(typeof generator).toBe('function');
        });

        it('should require all four components', () => {
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker()
            // Missing render
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            // Missing rank
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            // Missing analyze
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();

          expect(() => createMapGenerator({
            // Missing discover
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          } as any)).toThrow();
        });

        it('should execute the full pipeline with default components', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('Example');
        });

        it('should pass options through the pipeline correctly', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;',
            'src/test.spec.ts': 'test code'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'filtered.md');
          await generator({
            root: tempDir,
            output: outputPath,
            include: ['**/*.ts'],
            ignore: ['**/*.spec.ts']
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.ts');
          expect(content).not.toContain('src/index.js');
          expect(content).not.toContain('src/test.spec.ts');
        });

        it('should pass renderer options correctly', async () => {
          const files = {
            'src/index.ts': `export class Test {
      method(): void {}
    }`
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom.md');
          await generator({
            root: tempDir,
            output: outputPath,
            rendererOptions: {
              customHeader: '# Custom Project',
              includeMermaidGraph: false,
              includeSymbolDetails: false
            }
          });

          const content = await readFile(outputPath);
          expect(content).toStartWith('# Custom Project');
          expect(content).not.toContain('```mermaid');
          expect(content).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
        });

        it('should create output directory if it does not exist', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'nested', 'deep', 'output.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should handle empty projects gracefully', async () => {
          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'empty.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(isValidMarkdown(content)).toBe(true);
          expect(content).toContain('This repository contains 0 nodes (0 files)');
        });
      });

      describe('Custom Components', () => {
        it('should work with custom discoverer', async () => {
          const files = {
            'src/index.ts': 'export const ts = true;',
            'src/index.js': 'export const js = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer that only finds .js files
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            const allFiles = await defaultDiscoverer(options);
            return allFiles.filter(file => file.path.endsWith('.js'));
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'js-only.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('src/index.js');
          expect(content).not.toContain('src/index.ts');
        });

        it('should work with custom analyzer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          // Custom analyzer that adds extra metadata
          const customAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            const graph = await defaultAnalyzer(files);
            
            // Add custom metadata to all nodes
            graph.forEachNode(nodeId => {
              (graph as any).setNodeAttribute(nodeId, 'customMetadata', 'processed by custom analyzer');
            });
            
            return graph;
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: customAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom-analyzed.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          await assertFileExists(outputPath);
        });

        it('should work with custom ranker', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;',
            'src/c.ts': 'export const c = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom ranker that assigns alphabetical ranks
          const customRanker: Ranker = async (graph, _files) => {
            const ranks = new Map<string, number>();
            const fileNodes = graph.filterNodes(nodeId => 
              graph.getNodeAttribute(nodeId, 'type') === 'file'
            );
            
            fileNodes.sort().forEach((nodeId, index) => {
              ranks.set(nodeId, 1 - (index / fileNodes.length));
            });
            
            // Set rank 0 for non-file nodes
            graph.forEachNode(nodeId => {
              if (!ranks.has(nodeId)) {
                ranks.set(nodeId, 0);
              }
            });
            
            return { graph, ranks };
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: customRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'custom-ranked.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          // src/a.ts should be ranked highest (alphabetically first)
          const aIndex = content.indexOf('src/a.ts');
          const bIndex = content.indexOf('src/b.ts');
          expect(aIndex).toBeLessThan(bIndex);
        });

        it('should work with custom renderer', async () => {
          const files = {
            'src/index.ts': `export class Example {
      method(): string {
        return 'hello';
      }
    }`
          };
          await createTestFiles(tempDir, files);

          // Custom renderer that adds extra sections
          const customRenderer: Renderer = (rankedGraph, options) => {
            const defaultRenderer = createMarkdownRenderer();
            const baseMarkdown = defaultRenderer(rankedGraph, options);
            
            return `${baseMarkdown}\n\n## Custom Section\n\nThis was added by a custom renderer.\n\n### Statistics\n- Total nodes: ${rankedGraph.graph.order}\n- Total edges: ${rankedGraph.graph.size}`;
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'custom-rendered.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('## Custom Section');
          expect(content).toContain('This was added by a custom renderer');
          expect(content).toContain('### Statistics');
          expect(content).toContain('Total nodes:');
          expect(content).toContain('Total edges:');
        });

        it('should work with all custom components', async () => {
          const files = {
            'custom.special': 'special file content',
            'src/index.ts': 'export const normal = true;'
          };
          await createTestFiles(tempDir, files);

          // Custom discoverer for .special files
          const customDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            const defaultFiles = await defaultDiscoverer(options);
            
            // Add special files
            const specialFiles = defaultFiles.filter(f => f.path.endsWith('.special'));
            return [...defaultFiles, ...specialFiles];
          };

          // Custom analyzer that handles .special files
          const customAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            const graph = await defaultAnalyzer(files.filter(f => !f.path.endsWith('.special')));
            
            // Add special file nodes
            files.filter(f => f.path.endsWith('.special')).forEach(file => {
              graph.addNode(file.path, {
                id: file.path,
                type: 'special' as any,
                name: path.basename(file.path),
                filePath: file.path,
                startLine: 1,
                endLine: 1
              });
            });
            
            return graph;
          };

          // Custom ranker that gives special files high rank
          const customRanker: Ranker = async (graph, _files) => {
            const ranks = new Map<string, number>();
            
            graph.forEachNode(nodeId => {
              const nodeType = graph.getNodeAttribute(nodeId, 'type') as string;
              if (nodeType === 'special') {
                ranks.set(nodeId, 1.0);
              } else {
                ranks.set(nodeId, 0.5);
              }
            });
            
            return { graph, ranks };
          };

          // Custom renderer that handles special files
          const customRenderer: Renderer = (rankedGraph, options) => {
            const specialNodes = rankedGraph.graph.filterNodes(nodeId =>
              (rankedGraph.graph.getNodeAttribute(nodeId, 'type') as string) === 'special'
            );
            
            let markdown = '# Custom Project with Special Files\n\n';
            
            if (specialNodes.length > 0) {
              markdown += '## Special Files\n\n';
              specialNodes.forEach(nodeId => {
                const node = rankedGraph.graph.getNodeAttributes(nodeId);
                markdown += `- **${node.name}** (rank: ${rankedGraph.ranks.get(nodeId)?.toFixed(2)})\n`;
              });
              markdown += '\n';
            }
            
            const defaultRenderer = createMarkdownRenderer();
            const baseMarkdown = defaultRenderer(rankedGraph, options);
            
            return markdown + baseMarkdown.split('\n').slice(2).join('\n'); // Remove default header
          };

          const generator = createMapGenerator({
            discover: customDiscoverer,
            analyze: customAnalyzer,
            rank: customRanker,
            render: customRenderer
          });

          const outputPath = path.join(tempDir, 'all-custom.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          const content = await readFile(outputPath);
          expect(content).toContain('# Custom Project with Special Files');
          expect(content).toContain('## Special Files');
          expect(content).toContain('custom.special');
        });
      });

      describe('Error Handling', () => {
        it('should handle discoverer errors gracefully', async () => {
          const errorDiscoverer: FileDiscoverer = async () => {
            throw new Error('Discoverer failed');
          };

          const generator = createMapGenerator({
            discover: errorDiscoverer,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Discoverer failed');
        });

        it('should handle analyzer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorAnalyzer: Analyzer = async () => {
            throw new Error('Analyzer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: errorAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Analyzer failed');
        });

        it('should handle ranker errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRanker: Ranker = async () => {
            throw new Error('Ranker failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: errorRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Ranker failed');
        });

        it('should handle renderer errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const errorRenderer: Renderer = () => {
            throw new Error('Renderer failed');
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: errorRenderer
          });

          const outputPath = path.join(tempDir, 'error.md');
          
          await expect(generator({
            root: tempDir,
            output: outputPath
          })).rejects.toThrow('Renderer failed');
        });

        it('should handle file write errors gracefully', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          // Try to write to an invalid path
          const invalidOutputPath = '/root/cannot-write.md';
          
          await expect(generator({
            root: tempDir,
            output: invalidOutputPath
          })).rejects.toThrow();
        });
      });

      describe('Component Interface Validation', () => {
        it('should validate discoverer interface', () => {
          const invalidDiscoverer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: invalidDiscoverer as any,
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate analyzer interface', () => {
          const invalidAnalyzer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: invalidAnalyzer as any,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate ranker interface', () => {
          const invalidRanker = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: invalidRanker as any,
            render: createMarkdownRenderer()
          })).toThrow();
        });

        it('should validate renderer interface', () => {
          const invalidRenderer = 'not a function';
          
          expect(() => createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: createPageRanker(),
            render: invalidRenderer as any
          })).toThrow();
        });
      });

      describe('Pipeline Data Flow', () => {
        it('should pass files from discoverer to analyzer', async () => {
          const files = {
            'src/a.ts': 'export const a = true;',
            'src/b.ts': 'export const b = true;'
          };
          await createTestFiles(tempDir, files);

          let discoveredFiles: readonly FileContent[] = [];
          let analyzedFiles: readonly FileContent[] = [];

          const trackingDiscoverer: FileDiscoverer = async (options) => {
            const defaultDiscoverer = createDefaultDiscoverer();
            discoveredFiles = await defaultDiscoverer(options);
            return discoveredFiles;
          };

          const trackingAnalyzer: Analyzer = async (files) => {
            analyzedFiles = files;
            const defaultAnalyzer = createTreeSitterAnalyzer();
            return await defaultAnalyzer(files);
          };

          const generator = createMapGenerator({
            discover: trackingDiscoverer,
            analyze: trackingAnalyzer,
            rank: createPageRanker(),
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(discoveredFiles.length).toBe(2);
          expect(analyzedFiles.length).toBe(2);
          expect(analyzedFiles).toEqual(discoveredFiles);
        });

        it('should pass graph from analyzer to ranker', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let analyzedGraph: any;
          let rankedGraph: any;

          const trackingAnalyzer: Analyzer = async (files) => {
            const defaultAnalyzer = createTreeSitterAnalyzer();
            analyzedGraph = await defaultAnalyzer(files);
            return analyzedGraph;
          };

          const trackingRanker: Ranker = async (graph, files) => {
            rankedGraph = graph;
            const defaultRanker = createPageRanker();
            return await defaultRanker(graph, files);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: trackingAnalyzer,
            rank: trackingRanker,
            render: createMarkdownRenderer()
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rankedGraph).toBe(analyzedGraph);
        });

        it('should pass ranked graph from ranker to renderer', async () => {
          const files = {
            'src/index.ts': 'export const test = true;'
          };
          await createTestFiles(tempDir, files);

          let rankerOutput: any;
          let rendererInput: any;

          const trackingRanker: Ranker = async (graph, files) => {
            const defaultRanker = createPageRanker();
            rankerOutput = await defaultRanker(graph, files);
            return rankerOutput;
          };

          const trackingRenderer: Renderer = (rankedGraph, options) => {
            rendererInput = rankedGraph;
            const defaultRenderer = createMarkdownRenderer();
            return defaultRenderer(rankedGraph, options);
          };

          const generator = createMapGenerator({
            discover: createDefaultDiscoverer(),
            analyze: createTreeSitterAnalyzer(),
            rank: trackingRanker,
            render: trackingRenderer
          });

          const outputPath = path.join(tempDir, 'tracking.md');
          await generator({
            root: tempDir,
            output: outputPath
          });

          expect(rendererInput).toBe(rankerOutput);
        });
      });
    });
approved: true
