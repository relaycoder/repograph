uuid: 440938da-f6c6-4d26-b844-aa0f135b0e51
projectId: repograph
createdAt: '2025-06-29T15:59:02.648Z'
gitCommitMsg: 'feat(core): introduce advanced logger and error/fs utils'
promptSummary: >-
  Refactor logging, error handling, and fs operations into separate utility
  modules. The logger should be configurable via CLI and programmatically. All
  changes should follow HOF and immutability principles.
reasoning:
  - >-
    I've analyzed your request and have prepared the necessary changes to
    introduce advanced, configurable logging, and dedicated utilities for error
    handling and file system operations, all while adhering to functional and
    immutable principles.
  - 'Here are the step-by-step changes:'
  - >-
    First, I created a new directory `src/utils` to house the new utility
    modules.
  - >-
    I then created `src/utils/error.util.ts` to define custom, structured error
    types. This will help in distinguishing different kinds of errors throughout
    the application.
  - >-
    Next, I created `src/utils/fs.util.ts` to centralize all file system
    interactions. These functions wrap the standard Node.js `fs` calls to
    provide better error handling using the new custom `FileSystemError`, and
    they follow an immutable, functional approach where possible.
  - >-
    I then created `src/utils/logger.util.ts`, which implements a flexible
    logger with support for different log levels. It's exported as a singleton
    that can be configured programmatically or via the new CLI option.
  - >-
    I updated `src/types.ts` to include the `logLevel` option in the main
    `RepoGraphOptions` type.
  - >-
    I refactored the CLI entry point in `src/index.ts` to use the new logger,
    handle the `--log-level` argument, and catch the new structured errors for
    more informative messages.
  - >-
    I updated `src/high-level.ts` to accept the `logLevel` option and configure
    the logger at the start of execution.
  - >-
    I refactored `src/composer.ts` to use the new logger for progress messages
    and the new `writeFile` utility, which simplifies the file writing logic.
  - >-
    I updated the file discoverer in `src/pipeline/discover.ts` to use the new
    file system utilities and logger. This makes the code cleaner and its error
    handling more robust and consistent.
  - >-
    I improved the error handling in `src/pipeline/rank.ts` by using the custom
    `RepoGraphError`.
  - >-
    In `src/pipeline/analyze.ts`, I replaced `console.warn` with `logger.warn`
    and wrapped the warning in a new `ParserError` for better diagnostics.
  - >-
    Finally, I updated the language loader in `src/tree-sitter/languages.ts` to
    use the new logger and `ParserError`, ensuring that failures in loading
    language parsers are logged and thrown in a structured manner.
  - >-
    These changes significantly improve the maintainability, observability, and
    error handling of the application.
operations:
  - type: write
    path: src/utils/error.util.ts
    content: |-
      export class RepoGraphError extends Error {
        constructor(message: string, public readonly originalError?: unknown) {
          super(message);
          this.name = 'RepoGraphError';
          if (this.originalError instanceof Error && this.originalError.stack) {
            this.stack = `${this.stack}\nCaused by: ${this.originalError.stack}`;
          }
        }
      }

      export class FileSystemError extends RepoGraphError {
        constructor(message: string, public readonly path: string, originalError?: unknown) {
          super(`${message}: ${path}`, originalError);
          this.name = 'FileSystemError';
        }
      }

      export class ParserError extends RepoGraphError {
        constructor(message: string, public readonly language?: string, originalError?: unknown) {
          super(language ? `[${language}] ${message}` : message, originalError);
          this.name = 'ParserError';
        }
      }
    patchStrategy: replace
  - type: write
    path: src/utils/fs.util.ts
    content: >-
      import fs from 'node:fs/promises';

      import path from 'node:path';

      import { FileSystemError } from './error.util.js';


      export const readFile = async (filePath: string): Promise<string> => {
        try {
          const buffer = await fs.readFile(filePath);
          // A simple heuristic to filter out binary files is checking for a null byte.
          if (buffer.includes(0)) {
            throw new FileSystemError('File appears to be binary', filePath);
          }
          return buffer.toString('utf-8');
        } catch (e) {
          if (e instanceof FileSystemError) {
            throw e;
          }
          throw new FileSystemError('Failed to read file', filePath, e);
        }
      };


      export const writeFile = async (filePath: string, content: string):
      Promise<void> => {
        try {
          await fs.mkdir(path.dirname(filePath), { recursive: true });
          await fs.writeFile(filePath, content);
        } catch (e) {
          throw new FileSystemError('Failed to write file', filePath, e);
        }
      };


      export const isDirectory = async (filePath: string): Promise<boolean> => {
        try {
          const stats = await fs.stat(filePath);
          return stats.isDirectory();
        } catch (e) {
          if (e && typeof e === 'object' && 'code' in e && e.code === 'ENOENT') {
            return false;
          }
          throw new FileSystemError('Failed to check if path is a directory', filePath, e);
        }
      };
    patchStrategy: replace
  - type: write
    path: src/utils/logger.util.ts
    content: |-
      export const LogLevels = {
        silent: 0,
        error: 1,
        warn: 2,
        info: 3,
        debug: 4,
      } as const;

      export type LogLevel = keyof typeof LogLevels;

      // This state is internal to the logger module.
      let currentLevel: LogLevel = 'info';

      const log = (level: LogLevel, ...args: any[]): void => {
        if (LogLevels[level] > LogLevels[currentLevel]) {
          return;
        }
        // Use console.log for info level for cleaner output in most terminals
        const logFunction = level === 'info' ? console.log : console[level];
        logFunction(...args);
      };

      export type Logger = {
        readonly error: (...args: any[]) => void;
        readonly warn: (...args: any[]) => void;
        readonly info: (...args: any[]) => void;
        readonly debug: (...args: any[]) => void;
        readonly setLevel: (level: LogLevel) => void;
        readonly getLevel: () => LogLevel;
      };

      const createLogger = (): Logger => {
        return Object.freeze({
          error: (...args: any[]) => log('error', ...args),
          warn: (...args: any[]) => log('warn', ...args),
          info: (...args: any[]) => log('info', ...args),
          debug: (...args: any[]) => log('debug', ...args),
          setLevel: (level: LogLevel) => {
            if (level in LogLevels) {
              currentLevel = level;
            }
          },
          getLevel: () => currentLevel,
        });
      };

      export const logger = createLogger();
    patchStrategy: replace
  - type: write
    path: src/types.ts
    content: |-
      --- src/types.ts
      +++ src/types.ts
      @@ -107,6 +107,8 @@
         readonly rankingStrategy?: 'pagerank' | 'git-changes';
         /** Configuration for the final Markdown output. */
         readonly rendererOptions?: RendererOptions;
      +  /** Logging level. @default 'info' */
      +  readonly logLevel?: 'silent' | 'error' | 'warn' | 'info' | 'debug';
       };
       
       // Low-Level Functional Pipeline Contracts
    patchStrategy: new-unified
  - type: write
    path: src/index.ts
    content: >-
      --- src/index.ts

      +++ src/index.ts

      @@ -1,5 +1,7 @@
       #!/usr/bin/env bun
       
      +import { logger } from './utils/logger.util.js';

      +import { RepoGraphError } from './utils/error.util.js';
       // High-Level API for simple use cases
       import { generateMap as executeGenerateMap } from './high-level.js';
       import type { RepoGraphOptions as IRepoGraphOptions } from './types.js';
      @@ -48,6 +50,7 @@
         --ignore <pattern>       Glob pattern for files to ignore. Can be specified multiple times.
         --no-gitignore           Do not respect .gitignore files.
         --ranking-strategy <name> The ranking strategy to use. (default: "pagerank", options: "pagerank", "git-changes")
      +  --log-level <level>      Set the logging level. (default: "info",
      options: "silent", "error", "warn", "info", "debug")
       
       Output Formatting:
         --no-header              Do not include the main "RepoGraph" header.
      @@ -63,7 +66,7 @@
       
         if (args.includes('--version') || args.includes('-v')) {
           // In a real app, you'd get this from package.json
      -    console.log('0.1.0');

      +    logger.info('0.1.0');
           process.exit(0);
         }
       
      @@ -74,6 +77,7 @@
           ignore?: readonly string[];
           noGitignore?: boolean;
           rankingStrategy?: 'pagerank' | 'git-changes';
      +    logLevel?: IRepoGraphOptions['logLevel'];
           rendererOptions?: IRepoGraphOptions['rendererOptions'];
         } = {};
         const includePatterns: string[] = [];
      @@ -113,6 +117,9 @@
               break;
             case '--ranking-strategy':
               options.rankingStrategy = args[++i] as IRepoGraphOptions['rankingStrategy'];
      +        break;

      +      case '--log-level':

      +        options.logLevel = args[++i] as IRepoGraphOptions['logLevel'];
               break;
             // --- Renderer Options ---
             case '--no-header':
      @@ -155,17 +162,17 @@
       
         const finalOutput = path.resolve(options.root || process.cwd(), options.output || 'repograph.md');
       
      -  console.log(`Starting RepoGraph analysis for
      "${path.resolve(options.root || process.cwd())}"...`);

      +  logger.info(`Starting RepoGraph analysis for
      "${path.resolve(options.root || process.cwd())}"...`);
         executeGenerateMap(options)
           .then(() => {
             const relativePath = path.relative(process.cwd(), finalOutput);
      -      console.log(`\n✅ Success! RepoGraph map saved to ${relativePath}`);

      +      logger.info(`\n✅ Success! RepoGraph map saved to ${relativePath}`);
           })
           .catch((error: unknown) => {
      -      if (error instanceof Error) {

      -        console.error(`\n❌ Error generating RepoGraph map:
      ${error.message}`);

      +      if (error instanceof RepoGraphError) {

      +        logger.error(`\n❌ Error generating RepoGraph map:
      ${error.message}`);
             } else {
      -        console.error('\n❌ An unknown error occurred while generating the
      RepoGraph map.');

      +        logger.error('\n❌ An unknown error occurred while generating the
      RepoGraph map.', error);
             }
             process.exit(1);
           });
    patchStrategy: new-unified
  - type: write
    path: src/high-level.ts
    content: |-
      --- src/high-level.ts
      +++ src/high-level.ts
      @@ -4,6 +4,7 @@
       import { createMarkdownRenderer } from './pipeline/render.js';
       import type { RepoGraphOptions, Ranker } from './types.js';
       import path from 'node:path';
      +import { logger } from './utils/logger.util.js';
       
       /**
        * The primary, easy-to-use entry point for RepoGraph. It orchestrates the
      @@ -15,7 +16,12 @@
           root = process.cwd(),
           output = './repograph.md',
           rankingStrategy = 'pagerank',
      +    logLevel = 'info',
         } = options;
      +
      +  if (logLevel) {
      +    logger.setLevel(logLevel);
      +  }
       
         let ranker: Ranker;
         if (rankingStrategy === 'git-changes') {
    patchStrategy: new-unified
  - type: write
    path: src/composer.ts
    content: >-
      --- src/composer.ts

      +++ src/composer.ts

      @@ -1,8 +1,9 @@

      -import fs from 'node:fs/promises';
       import path from 'node:path';
       import type { Analyzer, FileDiscoverer, Ranker, Renderer } from './types.js';
      +import { logger } from './utils/logger.util.js';

      +import { writeFile } from './utils/fs.util.js';
       
       type MapGenerator = (config: {
         readonly root: string;
      @@ -34,24 +35,23 @@
         return async (config) => {
           const { root, output, include, ignore, noGitignore, rendererOptions } = config;
       
      -    console.log('1/5 Discovering files...');

      +    logger.info('1/5 Discovering files...');
           const files = await pipeline.discover({ root, include, ignore, noGitignore });
      -    console.log(`  -> Found ${files.length} files to analyze.`);

      +    logger.info(`  -> Found ${files.length} files to analyze.`);
       
      -    console.log('2/5 Analyzing code and building graph...');

      +    logger.info('2/5 Analyzing code and building graph...');
           const graph = await pipeline.analyze(files);
      -    console.log(`  -> Built graph with ${graph.nodes.size} nodes and
      ${graph.edges.length} edges.`);

      +    logger.info(`  -> Built graph with ${graph.nodes.size} nodes and
      ${graph.edges.length} edges.`);
       
      -    console.log('3/5 Ranking graph nodes...');

      +    logger.info('3/5 Ranking graph nodes...');
           const rankedGraph = await pipeline.rank(graph);
      -    console.log('  -> Ranking complete.');

      +    logger.info('  -> Ranking complete.');
       
      -    console.log('4/5 Rendering output...');

      +    logger.info('4/5 Rendering output...');
           const markdown = pipeline.render(rankedGraph, rendererOptions);
      -    console.log('  -> Rendering complete.');

      +    logger.info('  -> Rendering complete.');
       
      -    console.log('5/5 Writing report to disk...');
           const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);
      -    await fs.mkdir(path.dirname(outputPath), { recursive: true });

      -    await fs.writeFile(outputPath, markdown);

      +    logger.info(`5/5 Writing report to ${path.relative(process.cwd(),
      outputPath)}...`);

      +    await writeFile(outputPath, markdown);

      +    logger.info('  -> Report saved.');
         };
       };
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/discover.ts
    content: >-
      --- src/pipeline/discover.ts

      +++ src/pipeline/discover.ts

      @@ -1,19 +1,11 @@
       import { globby } from 'globby';
       import path from 'node:path';
      -import fs from 'node:fs/promises';
       import Ignore from 'ignore';
       import type { FileContent, FileDiscoverer } from '../types.js';
      -

      -const readGitignore = async (root: string): Promise<string> => {

      -  try {

      -    return await fs.readFile(path.join(root, '.gitignore'), 'utf-8');

      -  } catch {

      -    return '';

      -  }

      -};

      +import { isDirectory, readFile } from '../utils/fs.util.js';

      +import { FileSystemError } from '../utils/error.util.js';

      +import { logger } from '../utils/logger.util.js';
       
       /**
        * Creates the default file discoverer. It uses globby to find all files,
      @@ -23,20 +15,13 @@
       export const createDefaultDiscoverer = (): FileDiscoverer => {
         return async ({ root, include, ignore, noGitignore = false }) => {
           try {
      -      const stats = await fs.stat(root);

      -      if (!stats.isDirectory()) {

      -        throw new Error(`Root path is not a directory: ${root}`);

      +      if (!(await isDirectory(root))) {

      +        throw new FileSystemError('Root path is not a directory or does
      not exist', root);
             }
           } catch (e) {
      -      // Type guard to check for Node.js file system error

      -      if (e && typeof e === 'object' && 'code' in e && e.code ===
      'ENOENT') {

      -        throw new Error(`Root directory does not exist: ${root}`);

      -      } else {

      -        throw e;

      -      }

      +      throw e;
           }
           const patterns = include && include.length > 0 ? [...include] : ['**/*'];
           
           // Use the ignore package for proper gitignore handling
      @@ -48,7 +33,12 @@
           
           // Add .gitignore patterns if not disabled
           if (!noGitignore) {
      -      const gitignoreContent = await readGitignore(root);

      +      let gitignoreContent = '';

      +      try {

      +        gitignoreContent = await readFile(path.join(root, '.gitignore'));

      +      } catch {

      +        // .gitignore is optional, so we can ignore errors here.

      +      }
             if (gitignoreContent) {
               ignoreFilter.add(gitignoreContent);
             }
      @@ -72,13 +62,10 @@
           const fileContents = await Promise.all(
             filteredPaths.map(async (relativePath): Promise<FileContent | null> => {
               try {
                 const absolutePath = path.join(root, relativePath);
      -          const buffer = await fs.readFile(absolutePath);

      -          // A simple heuristic to filter out binary files is checking
      for a null byte.

      -          if (buffer.includes(0)) return null;

      -          const content = buffer.toString('utf-8');

      +          const content = await readFile(absolutePath);
                 return { path: relativePath, content };
      -        } catch {

      -          // Ignore files that can't be read (e.g., binary files,
      permission errors)

      +        } catch (e) {

      +          logger.debug(`Skipping file that could not be read:
      ${relativePath}`, e instanceof Error ? e.message : e);
                 return null;
               }
             })
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/rank.ts
    content: >-
      --- src/pipeline/rank.ts

      +++ src/pipeline/rank.ts

      @@ -1,5 +1,6 @@
       import pagerank from 'graphology-pagerank';
       import type { CodeGraph, Ranker, RankedCodeGraph } from '../types.js';
      +import { RepoGraphError } from '../utils/error.util.js';
       import Graph from 'graphology';
       import { execSync } from 'node:child_process';
       
      @@ -53,8 +54,8 @@
             }
           } catch (e) {
             const errorMessage = e instanceof Error ? e.message : String(e);
             // Provide a clear error message if git fails. This is a fatal error for this strategy.
      -      throw new Error(`Failed to use 'git' for ranking. Is git installed
      and is this a git repository?\n  Original error: ${errorMessage}`);

      +      throw new RepoGraphError(`Failed to use 'git' for ranking. Is git
      installed and is this a git repository?`, e);
           }
       
           return { ...graph, ranks };
         };
       };
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/analyze.ts
    content: >-
      --- src/pipeline/analyze.ts

      +++ src/pipeline/analyze.ts

      @@ -1,8 +1,10 @@
       import path from 'node:path';
       import { createParserForLanguage } from '../tree-sitter/languages.js';
       import { getLanguageConfigForFile, type LanguageConfig } from '../tree-sitter/language-config.js';
       import type { Analyzer, CodeNode, CodeNodeType, FileContent, CodeEdge } from '../types.js';
       import type { Node as TSNode, QueryCapture as TSMatch } from 'web-tree-sitter';
      +import { logger } from '../utils/logger.util.js';

      +import { ParserError } from '../utils/error.util.js';
       
       // --- UTILITY FUNCTIONS ---
       
      @@ -263,7 +265,7 @@
                 if (tree) fileParseData.set(file.path, { file, captures: query.captures(tree.rootNode), langConfig });
               }
             } catch (error) {
      -        console.warn(`Failed to process ${langName} files:`, error);

      +        logger.warn(new ParserError(`Failed to process ${langName}
      files`, langName, error));
             }
           }
    patchStrategy: new-unified
  - type: write
    path: src/tree-sitter/languages.ts
    content: >-
      --- src/tree-sitter/languages.ts

      +++ src/tree-sitter/languages.ts

      @@ -1,6 +1,8 @@
       import * as Parser from 'web-tree-sitter';
       import path from 'node:path';
       import { fileURLToPath } from 'node:url';
       import { LANGUAGE_CONFIGS, type LanguageConfig, type LoadedLanguage } from './language-config.js';
      +import { logger } from '../utils/logger.util.js';

      +import { ParserError } from '../utils/error.util.js';
       
       // Helper to get the correct path in different environments
       const getDirname = () => path.dirname(fileURLToPath(import.meta.url));
      @@ -37,9 +39,9 @@
           loadedLanguages.set(config.name, loadedLanguage);
           return loadedLanguage;
         } catch (error) {
      -    console.error(`Failed to load Tree-sitter WASM file for
      ${config.name}:`, error);

      -    console.error(`Please ensure '${config.wasmPath.split('/')[0]}' is
      installed in node_modules.`);

      -    throw new Error(`Could not load ${config.name} parser.`);

      +    const message = `Failed to load Tree-sitter WASM file for
      ${config.name}. Please ensure '${config.wasmPath.split('/')[0]}' is
      installed.`;

      +    logger.error(message, error);

      +    throw new ParserError(message, config.name, error);
         }
       };
    patchStrategy: new-unified
snapshot:
  src/utils/error.util.ts: null
  src/utils/fs.util.ts: null
  src/utils/logger.util.ts: null
  src/types.ts: >-
    // Core Data Structures


    /** Represents a single file read from disk. Immutable. */

    export type FileContent = {
      readonly path: string;
      readonly content: string;
    };


    /** The type of a symbol identified in the code. */

    export type CodeNodeType =
      | 'file'
      | 'class'
      | 'function'
      | 'interface'
      | 'variable'
      | 'type'
      | 'arrow_function'
      | 'method'
      | 'field'
      | 'struct'
      | 'enum'
      | 'namespace'
      | 'trait'
      | 'impl'
      | 'constructor'
      | 'property'
      | 'constant'
      | 'static'
      | 'union'
      | 'template';

    /** Represents a single, identifiable symbol (or a file) in the code.
    Immutable. */

    export type CodeNode = {
      readonly id: string; // Unique identifier (e.g., 'src/api.ts#MyClass')
      readonly type: CodeNodeType;
      readonly name: string; // e.g., 'MyClass'
      readonly filePath: string;
      readonly startLine: number;
      readonly endLine: number;
      readonly language?: string; // For file nodes, the detected language
      readonly codeSnippet?: string; // e.g., function signature
    };


    /** Represents a directed relationship between two CodeNodes. Immutable. */

    export type CodeEdge = {
      readonly fromId: string; // ID of the source CodeNode
      readonly toId: string;   // ID of the target CodeNode
      readonly type: 'imports' | 'calls' | 'inherits' | 'implements';
    };


    /** The complete, raw model of the repository's structure. Immutable. */

    export type CodeGraph = {
      readonly nodes: ReadonlyMap<string, CodeNode>;
      readonly edges: readonly CodeEdge[];
    };


    /** A CodeGraph with an added 'rank' score for each node. Immutable. */

    export type RankedCodeGraph = CodeGraph & {
      readonly ranks: ReadonlyMap<string, number>; // Key is CodeNode ID
    };


    // High-Level API Options


    /** Configuration for the final Markdown output. */

    export type RendererOptions = {
      /** Custom text to appear at the top of the Markdown file. Overrides `includeHeader`. */
      readonly customHeader?: string;
      /** Include the default `RepoGraph` header. @default true */
      readonly includeHeader?: boolean;
      /** Include the project overview section. @default true */
      readonly includeOverview?: boolean;
      /** Include a Mermaid.js dependency graph. @default true */
      readonly includeMermaidGraph?: boolean;
      /** Include the list of top-ranked files. @default true */
      readonly includeFileList?: boolean;
      /** Number of files to show in the top list. @default 10 */
      readonly topFileCount?: number;
      /** Include detailed breakdowns for each symbol. @default true */
      readonly includeSymbolDetails?: boolean;
      /** String to use as a separator between file sections. @default '---' */
      readonly fileSectionSeparator?: string;

      /** Options for how individual symbols are rendered */
      readonly symbolDetailOptions?: {
        /** Include relationships (calls, inherits, etc.) in the symbol line. @default true */
        readonly includeRelations?: boolean;
        /** Include the starting line number. @default true */
        readonly includeLineNumber?: boolean;
        /** Include the code snippet for the symbol. @default true */
        readonly includeCodeSnippet?: boolean;
        /** Max number of relations to show per type (e.g., 'calls'). @default 3 */
        readonly maxRelationsToShow?: number;
      };
    };


    /** Configuration options for the main `generateMap` function. */

    export type RepoGraphOptions = {
      /** Root directory to analyze. @default process.cwd() */
      readonly root?: string;
      /** Output path for the Markdown file. @default './repograph.md' */
      readonly output?: string;
      /** Glob patterns for files to include. */
      readonly include?: readonly string[];
      /** Glob patterns for files to exclude. */
      readonly ignore?: readonly string[];
      /** Disables the use of .gitignore. @default false */
      readonly noGitignore?: boolean;
      /** The ranking strategy to use. @default 'pagerank' */
      readonly rankingStrategy?: 'pagerank' | 'git-changes';
      /** Configuration for the final Markdown output. */
      readonly rendererOptions?: RendererOptions;
    };


    // Low-Level Functional Pipeline Contracts


    /** Discovers files and returns their content. */

    export type FileDiscoverer = (config: {
      readonly root: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
    }) => Promise<readonly FileContent[]>;


    /** Analyzes file content and builds the dependency graph. */

    export type Analyzer = (files: readonly FileContent[]) =>
    Promise<CodeGraph>;


    /** Ranks the nodes in a graph. */

    export type Ranker = (graph: CodeGraph) => Promise<RankedCodeGraph>;


    /** Renders a ranked graph into a string format. */

    export type Renderer = (rankedGraph: RankedCodeGraph, options?:
    RendererOptions) => string;
  src/index.ts: |-
    #!/usr/bin/env bun

    // High-Level API for simple use cases
    import { generateMap as executeGenerateMap } from './high-level.js';
    import type { RepoGraphOptions as IRepoGraphOptions } from './types.js';

    export { generateMap } from './high-level.js';

    // Low-Level API for composition and advanced use cases
    export { createMapGenerator } from './composer.js';

    // Default pipeline component factories
    export { createDefaultDiscoverer } from './pipeline/discover.js';
    export { createTreeSitterAnalyzer } from './pipeline/analyze.js';
    export { createPageRanker, createGitRanker } from './pipeline/rank.js';
    export { createMarkdownRenderer } from './pipeline/render.js';

    // Core types for building custom components
    export type {
      FileContent,
      CodeNode,
      CodeNodeType,
      CodeEdge,
      CodeGraph,
      RankedCodeGraph,
      RepoGraphOptions,
      RendererOptions,
      FileDiscoverer,
      Analyzer,
      Ranker,
      Renderer,
    } from './types.js';

    // This section runs only when the script is executed directly from the CLI
    import { fileURLToPath } from 'node:url';
    import path from 'node:path';

    const isRunningDirectly = () => {
      if (typeof process.argv[1] === 'undefined') return false;
      const runningFile = path.resolve(process.argv[1]);
      const currentFile = fileURLToPath(import.meta.url);
      return runningFile === currentFile;
    };

    if (isRunningDirectly()) {
      const args = process.argv.slice(2);

      if (args.includes('--help') || args.includes('-h')) {
        console.log(`
    Usage: repograph [root] [options]

    Arguments:
      root                     The root directory of the repository to analyze. Defaults to the current working directory.

    Options:
      -h, --help               Display this help message.
      -v, --version            Display the version number.
      --output <path>          Path to the output Markdown file. (default: "repograph.md")
      --include <pattern>      Glob pattern for files to include. Can be specified multiple times.
      --ignore <pattern>       Glob pattern for files to ignore. Can be specified multiple times.
      --no-gitignore           Do not respect .gitignore files.
      --ranking-strategy <name> The ranking strategy to use. (default: "pagerank", options: "pagerank", "git-changes")

    Output Formatting:
      --no-header              Do not include the main "RepoGraph" header.
      --no-overview            Do not include the project overview section.
      --no-mermaid             Do not include the Mermaid dependency graph.
      --no-file-list           Do not include the list of top-ranked files.
      --no-symbol-details      Do not include the detailed file and symbol breakdown.
      --top-file-count <num>   Set the number of files in the top list. (default: 10)
      --file-section-separator <str> Custom separator for file sections. (default: "---")
      --no-symbol-relations    Hide symbol relationship details (e.g., calls, implements).
      --no-symbol-line-numbers Hide line numbers for symbols.
      --no-symbol-snippets     Hide code snippets for symbols.
      --max-relations-to-show <num> Max number of 'calls' relations to show per symbol. (default: 3)
        `);
        process.exit(0);
      }

      if (args.includes('--version') || args.includes('-v')) {
        // In a real app, you'd get this from package.json
        console.log('0.1.0');
        process.exit(0);
      }

      // We need a mutable version of the options to build it from arguments.
      const options: {
        root?: string;
        output?: string;
        include?: readonly string[];
        ignore?: readonly string[];
        noGitignore?: boolean;
        rankingStrategy?: 'pagerank' | 'git-changes';
        rendererOptions?: IRepoGraphOptions['rendererOptions'];
      } = {};
      const includePatterns: string[] = [];
      const ignorePatterns: string[] = [];
      // We need a mutable version of rendererOptions to build from CLI args
      const rendererOptions: {
        customHeader?: string;
        includeHeader?: boolean;
        includeOverview?: boolean;
        includeMermaidGraph?: boolean;
        includeFileList?: boolean;
        topFileCount?: number;
        includeSymbolDetails?: boolean;
        fileSectionSeparator?: string;
        symbolDetailOptions?: {
          includeRelations?: boolean;
          includeLineNumber?: boolean;
          includeCodeSnippet?: boolean;
          maxRelationsToShow?: number;
        };
      } = {};

      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (!arg) {
          continue;
        }
        switch (arg) {
          case '--output':
            options.output = args[++i];
            break;
          case '--include':
            includePatterns.push(args[++i] as string);
            break;
          case '--ignore':
            ignorePatterns.push(args[++i] as string);
            break;
          case '--no-gitignore':
            options.noGitignore = true;
            break;
          case '--ranking-strategy':
            options.rankingStrategy = args[++i] as IRepoGraphOptions['rankingStrategy'];
            break;
          // --- Renderer Options ---
          case '--no-header':
            rendererOptions.includeHeader = false;
            break;
          case '--no-overview':
            rendererOptions.includeOverview = false;
            break;
          case '--no-mermaid':
            rendererOptions.includeMermaidGraph = false;
            break;
          case '--no-file-list':
            rendererOptions.includeFileList = false;
            break;
          case '--no-symbol-details':
            rendererOptions.includeSymbolDetails = false;
            break;
          case '--top-file-count':
            rendererOptions.topFileCount = parseInt(args[++i] as string, 10);
            break;
          case '--file-section-separator':
            rendererOptions.fileSectionSeparator = args[++i];
            break;
          case '--no-symbol-relations':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeRelations: false };
            break;
          case '--no-symbol-line-numbers':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeLineNumber: false };
            break;
          case '--no-symbol-snippets':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeCodeSnippet: false };
            break;
          case '--max-relations-to-show':
            rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), maxRelationsToShow: parseInt(args[++i] as string, 10) };
            break;
          default:
            if (!arg.startsWith('-')) {
              options.root = arg;
            }
            break;
        }
      }

      if (includePatterns.length > 0) {
        options.include = includePatterns;
      }
      if (ignorePatterns.length > 0) {
        options.ignore = ignorePatterns;
      }
      if (Object.keys(rendererOptions).length > 0) {
        options.rendererOptions = rendererOptions;
      }

      const finalOutput = path.resolve(options.root || process.cwd(), options.output || 'repograph.md');

      console.log(`Starting RepoGraph analysis for "${path.resolve(options.root || process.cwd())}"...`);
      executeGenerateMap(options)
        .then(() => {
          const relativePath = path.relative(process.cwd(), finalOutput);
          console.log(`\n✅ Success! RepoGraph map saved to ${relativePath}`);
        })
        .catch((error: unknown) => {
          if (error instanceof Error) {
            console.error(`\n❌ Error generating RepoGraph map: ${error.message}`);
          } else {
            console.error('\n❌ An unknown error occurred while generating the RepoGraph map.');
          }
          process.exit(1);
        });
    }
  src/high-level.ts: >-
    import { createMapGenerator } from './composer.js';

    import { createDefaultDiscoverer } from './pipeline/discover.js';

    import { createTreeSitterAnalyzer } from './pipeline/analyze.js';

    import { createPageRanker, createGitRanker } from './pipeline/rank.js';

    import { createMarkdownRenderer } from './pipeline/render.js';

    import type { RepoGraphOptions, Ranker } from './types.js';

    import path from 'node:path';


    /**
     * The primary, easy-to-use entry point for RepoGraph. It orchestrates the
     * default pipeline based on a configuration object to generate a codemap.
     *
     * @param options The configuration object for generating the map.
     */
    export const generateMap = async (options: RepoGraphOptions = {}):
    Promise<void> => {
      const {
        root = process.cwd(),
        output = './repograph.md',
        rankingStrategy = 'pagerank',
      } = options;

      let ranker: Ranker;
      if (rankingStrategy === 'git-changes') {
        ranker = createGitRanker();
      } else if (rankingStrategy === 'pagerank') {
        ranker = createPageRanker();
      } else {
        throw new Error(`Invalid ranking strategy: '${rankingStrategy}'. Available options are 'pagerank', 'git-changes'.`);
      }

      const generator = createMapGenerator({
        discover: createDefaultDiscoverer(),
        analyze: createTreeSitterAnalyzer(),
        rank: ranker,
        render: createMarkdownRenderer(),
      });

      await generator({
        root: path.resolve(root),
        output: output,
        include: options.include,
        ignore: options.ignore,
        noGitignore: options.noGitignore,
        rendererOptions: options.rendererOptions,
      });
    };
  src/composer.ts: >-
    import fs from 'node:fs/promises';

    import path from 'node:path';

    import type { Analyzer, FileDiscoverer, Ranker, Renderer } from
    './types.js';


    type MapGenerator = (config: {
      readonly root: string;
      readonly output: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
      readonly rendererOptions?: any;
    }) => Promise<void>;


    /**
     * A Higher-Order Function that takes pipeline functions as arguments and
     * returns a fully configured `generate` function for creating a codemap.
     * This is the core of RepoGraph's composability.
     *
     * @param pipeline An object containing implementations for each pipeline stage.
     * @returns An asynchronous function to generate and write the codemap.
     */
    export const createMapGenerator = (pipeline: {
      readonly discover: FileDiscoverer;
      readonly analyze: Analyzer;
      readonly rank: Ranker;
      readonly render: Renderer;
    }): MapGenerator => {
      if (
        !pipeline ||
        typeof pipeline.discover !== 'function' ||
        typeof pipeline.analyze !== 'function' ||
        typeof pipeline.rank !== 'function' ||
        typeof pipeline.render !== 'function'
      ) {
        throw new Error('createMapGenerator: A valid pipeline object with discover, analyze, rank, and render functions must be provided.');
      }

      return async (config) => {
        const { root, output, include, ignore, noGitignore, rendererOptions } = config;

        console.log('1/5 Discovering files...');
        const files = await pipeline.discover({ root, include, ignore, noGitignore });
        console.log(`  -> Found ${files.length} files to analyze.`);

        console.log('2/5 Analyzing code and building graph...');
        const graph = await pipeline.analyze(files);
        console.log(`  -> Built graph with ${graph.nodes.size} nodes and ${graph.edges.length} edges.`);

        console.log('3/5 Ranking graph nodes...');
        const rankedGraph = await pipeline.rank(graph);
        console.log('  -> Ranking complete.');

        console.log('4/5 Rendering output...');
        const markdown = pipeline.render(rankedGraph, rendererOptions);
        console.log('  -> Rendering complete.');

        console.log('5/5 Writing report to disk...');
        const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);
        await fs.mkdir(path.dirname(outputPath), { recursive: true });
        await fs.writeFile(outputPath, markdown);
      };
    };
  src/pipeline/discover.ts: |-
    import { globby } from 'globby';
    import path from 'node:path';
    import fs from 'node:fs/promises';
    import Ignore from 'ignore';
    import type { FileContent, FileDiscoverer } from '../types.js';

    const readGitignore = async (root: string): Promise<string> => {
      try {
        return await fs.readFile(path.join(root, '.gitignore'), 'utf-8');
      } catch {
        return '';
      }
    };

    /**
     * Creates the default file discoverer. It uses globby to find all files,
     * respecting .gitignore patterns and custom include/exclude rules.
     * @returns A FileDiscoverer function.
     */
    export const createDefaultDiscoverer = (): FileDiscoverer => {
      return async ({ root, include, ignore, noGitignore = false }) => {
        try {
          const stats = await fs.stat(root);
          if (!stats.isDirectory()) {
            throw new Error(`Root path is not a directory: ${root}`);
          }
        } catch (e) {
          // Type guard to check for Node.js file system error
          if (e && typeof e === 'object' && 'code' in e && e.code === 'ENOENT') {
            throw new Error(`Root directory does not exist: ${root}`);
          } else {
            throw e;
          }
        }
        const patterns = include && include.length > 0 ? [...include] : ['**/*'];
        
        // Use the ignore package for proper gitignore handling
        const ignoreFilter = Ignore();
        
        // Always ignore node_modules and .git
        ignoreFilter.add('**/node_modules/**');
        ignoreFilter.add('**/.git/**');
        ignoreFilter.add('.gitignore');
        
        // Add .gitignore patterns if not disabled
        if (!noGitignore) {
          const gitignoreContent = await readGitignore(root);
          if (gitignoreContent) {
            ignoreFilter.add(gitignoreContent);
          }
        }
        
        // Add user-specified ignore patterns
        if (ignore && ignore.length > 0) {
          ignoreFilter.add(ignore.join('\n'));
        }

        // Use globby to find all files matching the include patterns
        const relativePaths = await globby(patterns, {
          cwd: root,
          gitignore: false, // We handle gitignore patterns manually
          dot: true,
          absolute: false,
        });
        
        // Filter the paths using the ignore package
        const filteredPaths = relativePaths.filter(p => !ignoreFilter.ignores(p));

        const fileContents = await Promise.all(
          filteredPaths.map(async (relativePath): Promise<FileContent | null> => {
            try {
              const absolutePath = path.join(root, relativePath);
              const buffer = await fs.readFile(absolutePath);
              // A simple heuristic to filter out binary files is checking for a null byte.
              if (buffer.includes(0)) return null;
              const content = buffer.toString('utf-8');
              return { path: relativePath, content };
            } catch {
              // Ignore files that can't be read (e.g., binary files, permission errors)
              return null;
            }
          })
        );

        return fileContents.filter((c): c is FileContent => c !== null);
      };
    };
  src/pipeline/rank.ts: >-
    import pagerank from 'graphology-pagerank';

    import type { CodeGraph, Ranker, RankedCodeGraph } from '../types.js';

    import Graph from 'graphology';

    import { execSync } from 'node:child_process';


    /**
     * Creates a ranker that uses the PageRank algorithm. Nodes that are heavily referenced by
     * other important nodes will receive a higher rank.
     * @returns A Ranker function.
     */
    export const createPageRanker = (): Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        // PageRank can only be computed on graphs with nodes.
        if (graph.nodes.size === 0) {
          return { ...graph, ranks: new Map() };
        }

        // Pagerank lib requires a graphology instance.
        const simpleGraph = new Graph({ type: 'directed' });
        for (const [nodeId, node] of graph.nodes) {
          simpleGraph.addNode(nodeId, node);
        }
        for (const edge of graph.edges) {
          if (!simpleGraph.hasEdge(edge.fromId, edge.toId)) {
            simpleGraph.addDirectedEdge(edge.fromId, edge.toId);
          }
        }

        const graphForRank = simpleGraph;
        const ranksData = pagerank(graphForRank);
        const ranks = new Map<string, number>();
        for (const node in ranksData) {
          ranks.set(node, ranksData[node] ?? 0);
        }
        return { ...graph, ranks };
      };
    };


    /**
     * Creates a ranker based on Git commit history. Files changed more frequently are considered
     * more important. Requires Git to be installed.
     * @returns A Ranker function.
     */
    export const createGitRanker = (options: { maxCommits?: number } = {}):
    Ranker => {
      return async (graph: CodeGraph): Promise<RankedCodeGraph> => {
        const { maxCommits = 500 } = options;
        const ranks = new Map<string, number>();

        try {
          const command = `git log --max-count=${maxCommits} --name-only --pretty=format:`;
          const output = execSync(command, { encoding: 'utf-8' });
          const files = output.split('\n').filter(Boolean);

          const changeCounts: Record<string, number> = {};
          for (const file of files) {
            changeCounts[file] = (changeCounts[file] || 0) + 1;
          }

          const maxChanges = Math.max(...Object.values(changeCounts), 1);

          for (const [nodeId, attributes] of graph.nodes) {
            // We only rank file nodes with this strategy
            if (attributes.type === 'file') {
              const count = changeCounts[attributes.filePath] || 0;
              ranks.set(nodeId, count / maxChanges); // Normalize score
            } else {
              ranks.set(nodeId, 0);
            }
          }
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : String(e);
          // Provide a clear error message if git fails. This is a fatal error for this strategy.
          throw new Error(`Failed to use 'git' for ranking. Is git installed and is this a git repository?\n  Original error: ${errorMessage}`);
        }

        return { ...graph, ranks };
      };
    };
  src/pipeline/analyze.ts: >-
    import path from 'node:path';

    import { createParserForLanguage } from '../tree-sitter/languages.js';

    import { getLanguageConfigForFile, type LanguageConfig } from
    '../tree-sitter/language-config.js';

    import type { Analyzer, CodeNode, CodeNodeType, FileContent, CodeEdge } from
    '../types.js';

    import type { Node as TSNode, QueryCapture as TSMatch } from
    'web-tree-sitter';


    // --- UTILITY FUNCTIONS ---


    const getNodeText = (node: TSNode, content: string): string =>
    content.slice(node.startIndex, node.endIndex);

    const getLineFromIndex = (content: string, index: number): number =>
    content.substring(0, index).split('\n').length;


    // --- LANGUAGE-SPECIFIC LOGIC ---


    type LanguageHandler = {
      preProcessFile?: (file: FileContent, captures: TSMatch[]) => Record<string, any>;
      shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName: string) => boolean;
      getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) => TSNode | null;
      processComplexSymbol?: (context: ProcessSymbolContext) => boolean;
      resolveImport: (fromFile: string, importIdentifier: string, allFiles: string[]) => string | null;
    };


    type ProcessSymbolContext = {
      nodes: Map<string, CodeNode>;
      file: FileContent;
      node: TSNode;
      symbolType: CodeNodeType;
      processedSymbols: Set<string>;
      fileState: Record<string, any>;
    };


    const goLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        const nodeType = declarationNode.type;
        if (['type_declaration', 'const_declaration', 'var_declaration'].includes(nodeType)) {
          const spec = declarationNode.namedChild(0);
          if (spec && ['type_spec', 'const_spec', 'var_spec'].includes(spec.type)) {
            return spec.childForFieldName('name');
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const cLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'type_definition') {
          const lastChild = declarationNode.namedChild(declarationNode.namedChildCount - 1);
          if (lastChild?.type === 'type_identifier') return lastChild;
        }
        if (declarationNode.type === 'function_definition') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            const nameNode = declarator.childForFieldName('declarator');
            if (nameNode?.type === 'identifier') return nameNode;
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const tsLangHandler: Partial<LanguageHandler> = {
      preProcessFile: (_file, captures) => {
        const classNames = new Map<string, number>();
        const duplicateClassNames = new Set<string>();
        const seenClassNodes = new Set<number>();

        for (const { name, node } of captures) {
          if (name === 'class.definition') {
            let classNode = node.type === 'export_statement' ? (node.namedChildren[0] ?? node) : node;
            if (classNode.type === 'class_declaration' && !seenClassNodes.has(classNode.startIndex)) {
              seenClassNodes.add(classNode.startIndex);
              const nameNode = classNode.childForFieldName('name');
              if (nameNode) {
                const className = nameNode.text;
                const count = classNames.get(className) || 0;
                classNames.set(className, count + 1);
                if (count + 1 > 1) duplicateClassNames.add(className);
              }
            }
          }
        }
        return { duplicateClassNames };
      },
      shouldSkipSymbol: (node, symbolType, langName) => {
        if (langName !== 'typescript') return false;
        const valueNode = node.childForFieldName('value');
        if (valueNode?.type !== 'arrow_function') return false;
        return (symbolType === 'field' && node.type === 'public_field_definition') ||
          (symbolType === 'variable' && node.type === 'variable_declarator');
      },
      getSymbolNameNode: (declarationNode, originalNode) => {
        if (originalNode.type === 'variable_declarator' || originalNode.type === 'public_field_definition') { // Arrow function
          return originalNode.childForFieldName('name');
        }
        if (declarationNode.type === 'export_statement') {
          const lexicalDecl = declarationNode.namedChildren[0];
          if (lexicalDecl?.type === 'lexical_declaration') {
            const varDeclarator = lexicalDecl.namedChildren[0];
            if (varDeclarator?.type === 'variable_declarator') {
              return varDeclarator.childForFieldName('name');
            }
          }
        }
        return declarationNode.childForFieldName('name');
      },
      processComplexSymbol: ({ nodes, file, node, symbolType, processedSymbols, fileState }) => {
        if (symbolType !== 'method' && symbolType !== 'field') return false;
        const classParent = node.parent?.parent; // class_body -> class_declaration
        if (classParent?.type === 'class_declaration') {
          const classNameNode = classParent.childForFieldName('name');
          if (classNameNode) {
            const className = classNameNode.text;
            const nameNode = node.childForFieldName('name');
            // The check for duplicateClassNames is important to avoid ambiguity.
            // We remove the dependency on checking if the class has been processed first,
            // because the order of captures from tree-sitter is not guaranteed to be in source order.
            // This makes the analysis more robust.
            if (nameNode && !fileState['duplicateClassNames']?.has(className)) {
              const methodName = nameNode.text;
              const symbolName = `${className}.${methodName}`;
              const symbolId = `${file.path}#${symbolName}`;
              if (!processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
                processedSymbols.add(symbolId);
                nodes.set(symbolId, {
                  id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
                  startLine: getLineFromIndex(file.content, node.startIndex),
                  endLine: getLineFromIndex(file.content, node.endIndex),
                  codeSnippet: node.text?.split('{')[0]?.trim() || '',
                });
              }
            }
          }
        }
        return true;
      },
    };


    const resolveImportFactory = (endings: string[], packageStyle: boolean =
    false) => (fromFile: string, sourcePath: string, allFiles: string[]): string
    | null => {
      const basedir = path.dirname(fromFile);
      const resolvedPathAsIs = path.normalize(path.join(basedir, sourcePath));
      if (allFiles.includes(resolvedPathAsIs)) return resolvedPathAsIs;

      const parsedSourcePath = path.parse(sourcePath);
      const basePath = path.normalize(path.join(basedir, parsedSourcePath.dir, parsedSourcePath.name));
      for (const end of endings) {
        const potentialPath = basePath + end;
        if (allFiles.includes(potentialPath)) return potentialPath;
      }
      
      if (packageStyle && sourcePath.includes('.')) {
        const packagePath = sourcePath.replace(/\./g, '/');
        for (const end of endings) {
          const fileFromRoot = packagePath + end;
          if (allFiles.includes(fileFromRoot)) return fileFromRoot;
        }
      }
      return null;
    }


    const languageHandlers: Record<string, Partial<LanguageHandler>> = {
      default: {
        shouldSkipSymbol: () => false,
        getSymbolNameNode: (declarationNode) => declarationNode.childForFieldName('name'),
        resolveImport: (fromFile, sourcePath, allFiles) => {
          const resolvedPathAsIs = path.normalize(path.join(path.dirname(fromFile), sourcePath));
          return allFiles.includes(resolvedPathAsIs) ? resolvedPathAsIs : null;
        }
      },
      typescript: {
        ...tsLangHandler,
        resolveImport: resolveImportFactory(['.ts', '.tsx', '/index.ts', '/index.tsx', '.js', '.jsx', '.mjs', '.cjs']),
      },
      javascript: {
        resolveImport: resolveImportFactory(['.js', '.jsx', '/index.js', '/index.jsx', '.mjs', '.cjs']),
      },
      python: { resolveImport: resolveImportFactory(['.py', '/__init__.py']) },
      java: { resolveImport: resolveImportFactory(['.java'], true) },
      csharp: { resolveImport: resolveImportFactory(['.cs'], true) },
      go: goLangHandler,
      rust: { resolveImport: resolveImportFactory(['.rs', '/mod.rs']) },
      c: cLangHandler,
      cpp: cLangHandler,
    };


    const getLangHandler = (langName: string): LanguageHandler => ({
      ...languageHandlers['default'],
      ...languageHandlers[langName],
    } as LanguageHandler);


    /**
     * Creates the default Tree-sitter based analyzer. It parses files to find
     * symbols (nodes) and their relationships (edges), constructing a CodeGraph.
     * Supports multiple programming languages.
     * @returns An Analyzer function.
     */
    export const createTreeSitterAnalyzer = (): Analyzer => {
      return async (files: readonly FileContent[]) => {
        const nodes = new Map<string, CodeNode>();
        const edges: CodeEdge[] = [];
        const allFilePaths = files.map(f => f.path);

        // Phase 1: Add all files as nodes
        for (const file of files) {
          const langConfig = getLanguageConfigForFile(file.path);
          nodes.set(file.path, {
            id: file.path, type: 'file', name: path.basename(file.path),
            filePath: file.path, startLine: 1, endLine: file.content.split('\n').length,
            language: langConfig?.name,
          });
        }

        // Phase 2: Group files by language
        const filesByLanguage = files.reduce((acc, file) => {
          const langConfig = getLanguageConfigForFile(file.path);
          if (langConfig) {
            if (!acc.has(langConfig.name)) acc.set(langConfig.name, []);
            acc.get(langConfig.name)!.push(file);
          }
          return acc;
        }, new Map<string, FileContent[]>());

        // Phase 3: Parse all files once
        const fileParseData = new Map<string, { file: FileContent; captures: TSMatch[]; langConfig: LanguageConfig }>();
        for (const [langName, langFiles] of filesByLanguage.entries()) {
          const langConfig = getLanguageConfigForFile(langFiles[0]!.path);
          if (!langConfig) continue;
          try {
            const parser = await createParserForLanguage(langConfig);
            if (!parser.language) continue;
            const query = new (await import('web-tree-sitter')).Query(parser.language, langConfig.query);
            for (const file of langFiles) {
              const tree = parser.parse(file.content);
              if (tree) fileParseData.set(file.path, { file, captures: query.captures(tree.rootNode), langConfig });
            }
          } catch (error) {
            console.warn(`Failed to process ${langName} files:`, error);
          }
        }

        // Phase 4: Process definitions for all files
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileDefinitions({ nodes }, file, captures, langConfig);
        }
        
        // Phase 5: Process relationships for all files
        const resolver = new SymbolResolver(nodes, edges);
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileRelationships({ nodes, edges }, file, captures, langConfig, resolver, allFilePaths);
        }

        return { nodes: Object.freeze(nodes), edges: Object.freeze(edges) };
      };
    };


    /**
     * Process symbol definitions for a single file.
     */
    function processFileDefinitions(
      graph: { nodes: Map<string, CodeNode> },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig
    ): void {
      const handler = getLangHandler(langConfig.name);
      const fileState = handler.preProcessFile?.(file, captures) || {};
      const processedSymbols = new Set<string>();

      for (const { name, node } of captures) {
        const parts = name.split('.');
        if (parts[parts.length - 1] !== 'definition') continue;

        const type = parts.slice(0, -1).join('.');
        const symbolType = getSymbolTypeFromCapture(name, type);
        if (!symbolType) continue;

        processSymbol(
          { ...graph, file, node, symbolType, processedSymbols, fileState },
          langConfig
        );
      }
    }


    /**
     * Process a single symbol definition.
     */
    function processSymbol(context: ProcessSymbolContext, langConfig:
    LanguageConfig): void {
      const { nodes, file, node, symbolType, processedSymbols, fileState } = context;
      const handler = getLangHandler(langConfig.name);

      if (handler.shouldSkipSymbol(node, symbolType, langConfig.name)) return;
      if (handler.processComplexSymbol?.(context)) return;

      let declarationNode = node;
      if (node.type === 'export_statement') {
        declarationNode = node.namedChildren[0] ?? node;
      }
      
      const nameNode = handler.getSymbolNameNode(declarationNode, node);
      if (!nameNode) return;

      const symbolName = nameNode.text;
      const symbolId = `${file.path}#${symbolName}`;

      if (symbolName && !processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
        processedSymbols.add(symbolId);
        nodes.set(symbolId, {
          id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
          startLine: getLineFromIndex(file.content, node.startIndex),
          endLine: getLineFromIndex(file.content, node.endIndex),
          codeSnippet: node.text?.split('{')[0]?.trim() || '',
        });
      }
    }


    /**
     * Process relationships (imports, calls, inheritance) for a single file.
     */
    function processFileRelationships(
      graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig,
      resolver: SymbolResolver,
      allFilePaths: string[]
    ): void {
      const handler = getLangHandler(langConfig.name);
      for (const { name, node } of captures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const subtype = parts[parts.length - 1];

        if (type === 'import' && subtype === 'source') {
          const importIdentifier = getNodeText(node, file.content).replace(/['"`]/g, '');
          const importedFilePath = handler.resolveImport(file.path, importIdentifier, allFilePaths);
          if (importedFilePath && graph.nodes.has(importedFilePath)) {
            const edge: CodeEdge = { fromId: file.path, toId: importedFilePath, type: 'imports' };
            if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
              graph.edges.push(edge);
            }
          }
          continue;
        }

        if (subtype && ['inheritance', 'implementation', 'call'].includes(subtype)) {
          const fromId = findEnclosingSymbolId(node, file, graph.nodes);
          if (!fromId) continue;
          const toName = getNodeText(node, file.content).replace(/<.*>$/, '');
          const toNode = resolver.resolve(toName, file.path);
          if (!toNode) continue;
          
          const edgeType = subtype === 'inheritance' ? 'inherits' : subtype === 'implementation' ? 'implements' : 'calls';
          const edge: CodeEdge = { fromId, toId: toNode.id, type: edgeType };
          if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
            graph.edges.push(edge);
          }
        }
      }
    }


    /**
     * Get symbol type from capture name and language.
     */
    function getSymbolTypeFromCapture(captureName: string, type: string):
    CodeNodeType | null {
      const baseMap = new Map<string, CodeNodeType>([
        ['class', 'class'],
        ['function', 'function'],
        ['function.arrow', 'arrow_function'],
        ['interface', 'interface'],
        ['type', 'type'],
        ['method', 'method'],
        ['field', 'field'],
        ['struct', 'struct'],
        ['enum', 'enum'],
        ['namespace', 'namespace'],
        ['trait', 'trait'],
        ['impl', 'impl'],
        ['constructor', 'constructor'],
        ['property', 'property'],
        ['variable', 'variable'],
        ['constant', 'constant'],
        ['static', 'static'],
        ['union', 'union'],
        ['template', 'template'],
      ]);
      return baseMap.get(captureName) ?? baseMap.get(type) ?? null;
    }


    /**
     * A best-effort symbol resolver to find the ID of a referenced symbol.
     */
    class SymbolResolver {
      constructor(
        private nodes: ReadonlyMap<string, CodeNode>,
        private edges: readonly CodeEdge[],
      ) {}

      resolve(symbolName: string, contextFile: string): CodeNode | null {
        const sameFileId = `${contextFile}#${symbolName}`;
        if (this.nodes.has(sameFileId)) return this.nodes.get(sameFileId)!;

        const importedFiles = this.edges.filter(e => e.fromId === contextFile && e.type === 'imports').map(e => e.toId);
        for (const file of importedFiles) {
          const importedId = `${file}#${symbolName}`;
          if (this.nodes.has(importedId)) return this.nodes.get(importedId)!;
        }

        for (const node of this.nodes.values()) {
          if (node.name === symbolName && ['class', 'function', 'interface', 'struct', 'type', 'enum'].includes(node.type)) {
            return node;
          }
        }
        return null;
      }
    }


    /**
     * Traverses up the AST from a start node to find the enclosing symbol definition
     * and returns its unique ID.
     */
    function findEnclosingSymbolId(startNode: TSNode, file: FileContent, nodes:
    ReadonlyMap<string, CodeNode>): string | null {
      let current: TSNode | null = startNode.parent;
      while (current) {
        const nameNode = current.childForFieldName('name');
        if (nameNode) {
          let symbolName = nameNode.text;
          if (current.type === 'method_definition' || (current.type === 'public_field_definition' && !current.text.includes('=>'))) {
            const classNode = current.parent?.parent; // class_body -> class_declaration
            if (classNode?.type === 'class_declaration') {
              symbolName = `${classNode.childForFieldName('name')?.text}.${symbolName}`;
            }
          }
          const symbolId = `${file.path}#${symbolName}`;
          if (nodes.has(symbolId)) return symbolId;
        }
        current = current.parent;
      }
      return file.path; // Fallback to file node
    }
  src/tree-sitter/languages.ts: >-
    import * as Parser from 'web-tree-sitter';

    import path from 'node:path';

    import { fileURLToPath } from 'node:url';

    import { LANGUAGE_CONFIGS, type LanguageConfig, type LoadedLanguage } from
    './language-config.js';


    // Helper to get the correct path in different environments

    const getDirname = () => path.dirname(fileURLToPath(import.meta.url));


    let isInitialized = false;

    const loadedLanguages = new Map<string, LoadedLanguage>();


    /**
     * Initializes the Tree-sitter parser system.
     * This function is idempotent.
     */
    export const initializeParser = async (): Promise<void> => {
      if (isInitialized) {
        return;
      }

      await Parser.Parser.init();
      isInitialized = true;
    };


    /**
     * Loads a specific language grammar.
     * @param config The language configuration to load
     * @returns A LoadedLanguage object containing the config and language
     */
    export const loadLanguage = async (config: LanguageConfig):
    Promise<LoadedLanguage> => {
      if (loadedLanguages.has(config.name)) {
        return loadedLanguages.get(config.name)!;
      }

      await initializeParser();

      try {
        const wasmPath = path.resolve(getDirname(), '..', '..', 'node_modules', config.wasmPath);
        const language = await Parser.Language.load(wasmPath);
        
        const loadedLanguage: LoadedLanguage = {
          config,
          language
        };
        
        loadedLanguages.set(config.name, loadedLanguage);
        return loadedLanguage;
      } catch (error) {
        console.error(`Failed to load Tree-sitter WASM file for ${config.name}:`, error);
        console.error(`Please ensure '${config.wasmPath.split('/')[0]}' is installed in node_modules.`);
        throw new Error(`Could not load ${config.name} parser.`);
      }
    };


    /**
     * Creates a parser instance for a specific language.
     * @param config The language configuration
     * @returns A parser instance configured for the specified language
     */
    export const createParserForLanguage = async (config: LanguageConfig):
    Promise<Parser.Parser> => {
      const loadedLanguage = await loadLanguage(config);
      const parser = new Parser.Parser();
      parser.setLanguage(loadedLanguage.language);
      return parser;
    };


    /**
     * Gets all loaded languages.
     * @returns A map of language names to LoadedLanguage objects
     */
    export const getLoadedLanguages = (): Map<string, LoadedLanguage> => {
      return new Map(loadedLanguages);
    };


    /**
     * Preloads all supported languages.
     * This can be called to eagerly load all language parsers.
     */
    export const preloadAllLanguages = async (): Promise<void> => {
      await Promise.all(LANGUAGE_CONFIGS.map(config => loadLanguage(config)));
    };


    // Legacy function for backward compatibility

    export const getParser = async (): Promise<Parser.Parser> => {
      const tsConfig = LANGUAGE_CONFIGS.find(config => config.name === 'typescript');
      if (!tsConfig) {
        throw new Error('TypeScript configuration not found');
      }
      return createParserForLanguage(tsConfig);
    };
approved: true
