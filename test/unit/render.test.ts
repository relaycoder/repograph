import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
import { createMarkdownRenderer } from '../../src/pipeline/render.js';
import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
import { createPageRanker } from '../../src/pipeline/rank.js';
import type { CodeNode, CodeEdge, FileContent, RankedCodeGraph, RendererOptions } from '../../src/types.js';
import {
  createTempDir,
  cleanupTempDir,
  isValidMarkdown,
  containsValidMermaid,
  extractFilePathsFromMarkdown,
  createTestNode,
  createTestGraph
} from '../test.util.js';

describe('Markdown Rendering', () => {
  let tempDir: string;
  let renderer: ReturnType<typeof createMarkdownRenderer>;

  beforeEach(async () => {
    tempDir = await createTempDir();
    renderer = createMarkdownRenderer();
  });

  afterEach(async () => {
    await cleanupTempDir(tempDir);
  });

  describe('createMarkdownRenderer()', () => {
    it('should return a Renderer function', () => {
      expect(typeof renderer).toBe('function');
    });

    it('should generate valid markdown from empty graph', () => {
      const rankedGraph: RankedCodeGraph = {
        nodes: new Map(),
        edges: [],
        ranks: new Map()
      };

      const markdown = renderer(rankedGraph);

      expect(isValidMarkdown(markdown)).toBe(true);
      expect(markdown).toContain('# RepoGraph');
      expect(markdown).toContain('This repository contains 0 nodes (0 files)');
    });

    it('should include project overview section', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/index.ts', createTestNode('src/index.ts'));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/index.ts', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('## ðŸš€ Project Overview');
      expect(markdown).toContain('This repository contains 1 nodes (1 files)');
      expect(markdown).toContain('_Generated by RepoGraph on');
    });

    it('should include Mermaid graph by default', () => {
      const nodes = new Map<string, CodeNode>();
      const edges: CodeEdge[] = [];

      nodes.set('src/a.ts', createTestNode('src/a.ts', { name: 'a.ts' }));
      nodes.set('src/b.ts', createTestNode('src/b.ts', { name: 'b.ts' }));
      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges,
        ranks: new Map([
          ['src/a.ts', 0.3],
          ['src/b.ts', 0.7]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('### Module Dependency Graph');
      expect(containsValidMermaid(markdown)).toBe(true);
      expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
    });

    it('should exclude Mermaid graph when option is false', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/index.ts', createTestNode('src/index.ts'));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/index.ts', 0.5]])
      };

      const options: RendererOptions = {
        includeMermaidGraph: false
      };

      const markdown = renderer(rankedGraph, options);

      expect(markdown).not.toContain('### Module Dependency Graph');
      expect(markdown).not.toContain('```mermaid');
    });

    it('should include top 10 most important files', () => {
      const nodes = new Map<string, CodeNode>();
      const ranks = new Map<string, number>();

      // Create 15 files with different ranks
      for (let i = 1; i <= 15; i++) {
        const nodeId = `src/file${i}.ts`;
        nodes.set(nodeId, createTestNode(nodeId, { name: `file${i}.ts` }));
        ranks.set(nodeId, i / 15); // Higher numbers get higher ranks
      }

      const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
      const markdown = renderer(rankedGraph);

      const topFilesSection = markdown.split('## ðŸ“‚ File & Symbol Breakdown')[0]!;

      expect(topFilesSection).toContain('### Top 10 Most Important Files');
      expect(topFilesSection).toContain('| Rank | File | Description |');
      
      // Should contain the top 10 files (file15 to file6)
      expect(topFilesSection).toContain('`src/file15.ts`');
      expect(topFilesSection).toContain('`src/file6.ts`');
      
      // Should not contain the lower ranked files
      expect(topFilesSection).not.toContain('`src/file1.ts`');
      expect(topFilesSection).not.toContain('`src/file5.ts`');
    });

    it('should include symbol details by default', () => {
      const nodes = new Map<string, CodeNode>();

      nodes.set('src/test.ts', createTestNode('src/test.ts', { endLine: 20 }));
      nodes.set('src/test.ts#TestClass', createTestNode('src/test.ts#TestClass', { type: 'class', name: 'TestClass', startLine: 5, endLine: 15, codeSnippet: 'export class TestClass {' }));
      nodes.set('src/test.ts#testFunction', createTestNode('src/test.ts#testFunction', { type: 'function', name: 'testFunction', startLine: 17, endLine: 19, codeSnippet: 'export function testFunction(): void' }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.8],
          ['src/test.ts#TestClass', 0.5],
          ['src/test.ts#testFunction', 0.3]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('## ðŸ“‚ File & Symbol Breakdown');
      expect(markdown).toContain('### [`src/test.ts`](./src/test.ts)');
      expect(markdown).toContain('**`class TestClass`** - _L5_');
      expect(markdown).toContain('**`function testFunction`** - _L17_');
      expect(markdown).toContain('export class TestClass {');
      expect(markdown).toContain('export function testFunction(): void');
    });

    it('should exclude symbol details when option is false', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', createTestNode('src/test.ts'));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/test.ts', 0.5]])
      };

      const options: RendererOptions = {
        includeSymbolDetails: false
      };

      const markdown = renderer(rankedGraph, options);

      expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
    });

    describe('Renderer Customization Options', () => {
      let rankedGraph: RankedCodeGraph;

      beforeEach(() => {
        const nodes = new Map<string, CodeNode>();
        const edges: CodeEdge[] = [];

        nodes.set('src/main.ts', createTestNode('src/main.ts', { name: 'main.ts', language: 'typescript' }));
        nodes.set('src/utils.ts', createTestNode('src/utils.ts', { name: 'utils.ts', language: 'typescript' }));
        nodes.set('src/main.ts#main', createTestNode('src/main.ts#main', { type: 'function', name: 'main', startLine: 2, endLine: 5, codeSnippet: 'function main() {}' }));
        nodes.set('src/utils.ts#helper', createTestNode('src/utils.ts#helper', { type: 'function', name: 'helper', startLine: 2, endLine: 5, codeSnippet: 'function helper() {}' }));
        nodes.set('src/utils.ts#another', createTestNode('src/utils.ts#another', { type: 'function', name: 'another', startLine: 6, endLine: 8 }));
        nodes.set('src/utils.ts#onemore', createTestNode('src/utils.ts#onemore', { type: 'function', name: 'onemore', startLine: 9, endLine: 10 }));

        edges.push({ fromId: 'src/main.ts', toId: 'src/utils.ts', type: 'imports' });
        edges.push({ fromId: 'src/main.ts#main', toId: 'src/utils.ts#helper', type: 'calls' });
        edges.push({ fromId: 'src/main.ts#main', toId: 'src/utils.ts#another', type: 'calls' });
        edges.push({ fromId: 'src/main.ts#main', toId: 'src/utils.ts#onemore', type: 'calls' });

        const ranks = new Map([
          ['src/main.ts', 0.8],
          ['src/utils.ts', 0.6],
          ['src/main.ts#main', 0.5],
          ['src/utils.ts#helper', 0.4],
          ['src/utils.ts#another', 0.3],
          ['src/utils.ts#onemore', 0.2]
        ]);
        
        rankedGraph = { nodes, edges, ranks };
      });
      
      it('should exclude header when option is false', () => {
        const markdown = renderer(rankedGraph, { includeHeader: false });
        expect(markdown).not.toContain('# RepoGraph');
        expect(markdown).not.toContain('_Generated by RepoGraph on');
      });

      it('should exclude project overview when option is false', () => {
        const markdown = renderer(rankedGraph, { includeOverview: false });
        expect(markdown).not.toContain('## ðŸš€ Project Overview');
      });

      it('should exclude file list when option is false', () => {
        const markdown = renderer(rankedGraph, { includeFileList: false });
        expect(markdown).not.toContain('### Top 10 Most Important Files');
      });

      it('should respect topFileCount option', () => {
        const markdown = renderer(rankedGraph, { topFileCount: 1 });
        const topFilesSection = markdown.split('## ðŸ“‚ File & Symbol Breakdown')[0]!;

        expect(topFilesSection).toContain('### Top 1 Most Important Files');
        expect(topFilesSection).toContain('`src/main.ts`');
        expect(topFilesSection).not.toContain('`src/utils.ts`');
      });

      it('should use custom file section separator', () => {
        const markdown = renderer(rankedGraph, { fileSectionSeparator: '***' });
        expect(markdown).toContain('\n***\n\n');
        expect(markdown).not.toContain('\n---\n\n');
      });
      
      it('should not include relations when symbolDetailOptions.includeRelations is false', () => {
        const markdown = renderer(rankedGraph, { symbolDetailOptions: { includeRelations: false } });
        expect(markdown).not.toContain('(calls');
        expect(markdown).toContain('**`function main`** - _L2_');
      });
      
      it('should not include line numbers when symbolDetailOptions.includeLineNumber is false', () => {
        const markdown = renderer(rankedGraph, { symbolDetailOptions: { includeLineNumber: false } });
        expect(markdown).not.toContain('- _L2_');
        expect(markdown).toContain('**`function main`** (calls `helper`, `another`, `onemore`)');
      });
      
      it('should not include code snippets when symbolDetailOptions.includeCodeSnippet is false', () => {
        const markdown = renderer(rankedGraph, {
          symbolDetailOptions: { includeCodeSnippet: false },
          includeMermaidGraph: false,
        });
        expect(markdown).not.toContain('```');
        expect(markdown).not.toContain('function main() {}');
        expect(markdown).toContain('**`function main`**');
      });
      
      it('should respect maxRelationsToShow option', () => {
        const markdown = renderer(rankedGraph, { symbolDetailOptions: { maxRelationsToShow: 1 } });
        expect(markdown).toContain('(calls `helper`...)');
        expect(markdown).not.toContain('`another`');
        expect(markdown).not.toContain('`onemore`');
      });

      it('should render an empty string if all sections are disabled', () => {
        const markdown = renderer(rankedGraph, {
          includeHeader: false,
          includeOverview: false,
          includeMermaidGraph: false,
          includeFileList: false,
          includeSymbolDetails: false,
        });
        expect(markdown).toBe('');
      });
    });

    it('should include custom header when provided', () => {
      const rankedGraph: RankedCodeGraph = {
        nodes: new Map(),
        edges: [],
        ranks: new Map()
      };

      const customHeader = '# My Custom Project\n\nThis is a custom description.';
      const options: RendererOptions = {
        customHeader
      };

      const markdown = renderer(rankedGraph, options);

      expect(markdown).toStartWith(customHeader);
      expect(markdown).not.toContain('# RepoGraph');
    });

    it('should handle files with no symbols', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('README.md', createTestNode('README.md', { name: 'README.md', endLine: 5 }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['README.md', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('### [`README.md`](./README.md)');
      expect(markdown).toContain('_No symbols identified in this file._');
    });

    it('should sort symbols by line number', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', createTestNode('src/test.ts', { endLine: 30 }));

      // Add symbols in non-sequential order
      nodes.set('src/test.ts#lastFunction', createTestNode('src/test.ts#lastFunction', { type: 'function', name: 'lastFunction', startLine: 25, endLine: 28 }));
      nodes.set('src/test.ts#firstFunction', createTestNode('src/test.ts#firstFunction', { type: 'function', name: 'firstFunction', startLine: 5, endLine: 10 }));
      nodes.set('src/test.ts#middleClass', createTestNode('src/test.ts#middleClass', { type: 'class', name: 'middleClass', startLine: 15, endLine: 20 }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.8],
          ['src/test.ts#lastFunction', 0.3],
          ['src/test.ts#firstFunction', 0.5],
          ['src/test.ts#middleClass', 0.4]
        ])
      };

      const markdown = renderer(rankedGraph);

      // Check that symbols appear in line number order
      const firstFunctionIndex = markdown.indexOf('firstFunction');
      const middleClassIndex = markdown.indexOf('middleClass');
      const lastFunctionIndex = markdown.indexOf('lastFunction');

      expect(firstFunctionIndex).toBeLessThan(middleClassIndex);
      expect(middleClassIndex).toBeLessThan(lastFunctionIndex);
    });

    it('should sort files by rank (highest first)', () => {
      const nodes = new Map<string, CodeNode>();
      const files = [
        { id: 'src/low.ts', rank: 0.2 },
        { id: 'src/high.ts', rank: 0.8 },
        { id: 'src/medium.ts', rank: 0.5 }
      ];

      const ranks = new Map<string, number>();

      for (const file of files) {
        nodes.set(file.id, createTestNode(file.id, { name: file.id.split('/').pop()! }));
        ranks.set(file.id, file.rank);
      }

      const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
      const markdown = renderer(rankedGraph);

      // Check order in the file breakdown section
      const highIndex = markdown.indexOf('[`src/high.ts`]');
      const mediumIndex = markdown.indexOf('[`src/medium.ts`]');
      const lowIndex = markdown.indexOf('[`src/low.ts`]');

      expect(highIndex).toBeLessThan(mediumIndex);
      expect(mediumIndex).toBeLessThan(lowIndex);
    });

    it('should handle symbols without code snippets', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', createTestNode('src/test.ts'));

      nodes.set('src/test.ts#noSnippet', createTestNode('src/test.ts#noSnippet', { type: 'function', name: 'noSnippet', startLine: 5, endLine: 8 }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.5],
          ['src/test.ts#noSnippet', 0.3]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('**`function noSnippet`** - _L5_');
      // Should not include empty code block
      expect(markdown).not.toContain('```typescript\n  \n  ```');
    });

    it('should generate proper markdown links for files', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/nested/deep/file.ts', {
        id: 'src/nested/deep/file.ts', type: 'file', name: 'file.ts', filePath: 'src/nested/deep/file.ts', startLine: 1, endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/nested/deep/file.ts', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('### [`src/nested/deep/file.ts`](./src/nested/deep/file.ts)');
    });
  });

  describe('Mermaid Graph Generation', () => {
    it('should only include file nodes in Mermaid graph', () => {
      const nodes = new Map<string, CodeNode>();
      const edges: CodeEdge[] = [];

      nodes.set('src/a.ts', createTestNode('src/a.ts', { name: 'a.ts' }));
      nodes.set('src/a.ts#Class', createTestNode('src/a.ts#Class', { type: 'class', name: 'Class', startLine: 2, endLine: 8 }));
      nodes.set('src/b.ts', createTestNode('src/b.ts', { name: 'b.ts' }));
      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges,
        ranks: new Map([
          ['src/a.ts', 0.5],
          ['src/a.ts#Class', 0.3],
          ['src/b.ts', 0.7]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
      expect(markdown).not.toContain('src/a.ts#Class');
    });

    it('should handle graphs with no file-to-file edges', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/isolated.ts', createTestNode('src/isolated.ts', { name: 'isolated.ts' }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/isolated.ts', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('```mermaid');
      expect(markdown).toContain('graph TD');
      expect(markdown).toContain('```');
    });

    it('should deduplicate edges in Mermaid graph', () => {
      const nodes = new Map<string, CodeNode>();
      const edges: CodeEdge[] = [];
      nodes.set('src/a.ts', createTestNode('src/a.ts', { name: 'a.ts' }));

      nodes.set('src/b.ts', createTestNode('src/b.ts', { name: 'b.ts' }));

      // Add multiple edges between the same files (multi-graph)
      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });
      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges,
        ranks: new Map([
          ['src/a.ts', 0.5],
          ['src/b.ts', 0.7]
        ])
      };

      const markdown = renderer(rankedGraph);

      // Should only appear once in the Mermaid graph
      const edgePattern = /src\/a\.ts\["a\.ts"\] --> src\/b\.ts\["b\.ts"\]/g;
      const matches = markdown.match(edgePattern);
      expect(matches).toHaveLength(1);
    });
  });

  describe('Integration with Real Analysis', () => {
    it('should render analyzed TypeScript code correctly', async () => {
      const analyzer = createTreeSitterAnalyzer();
      const ranker = createPageRanker();

      const files: FileContent[] = [
        {
          path: 'src/index.ts',
          content: `import { Calculator } from './calculator.js';

export { Calculator };

export function main(): void {
  const calc = new Calculator();
  console.log(calc.add(1, 2));
}`
        },
        {
          path: 'src/calculator.ts',
          content: `export class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }
  
  subtract = (a: number, b: number): number => {
    return a - b;
  };
}`
        }
      ];

      const graph = await analyzer(files);
      const rankedGraph = await ranker(graph);
      const markdown = renderer(rankedGraph);

      expect(isValidMarkdown(markdown)).toBe(true);
      expect(markdown).toContain('Calculator');
      expect(markdown).toContain('**`class Calculator`**');
      expect(markdown).toContain('**`function main`**');
      expect(markdown).toContain('**`arrow_function subtract`**');
      expect(containsValidMermaid(markdown)).toBe(true);
    });
  });

  describe('Edge Cases', () => {
    it('should handle very long file paths', () => {
      const nodes = new Map<string, CodeNode>();
      const longPath = 'src/very/deeply/nested/directory/structure/with/many/levels/file.ts';
      nodes.set(longPath, createTestNode(longPath, { name: 'file.ts' }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([[longPath, 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain(`[\`${longPath}\`](./${longPath})`);
    });

    it('should handle special characters in file names', () => {
      const nodes = new Map<string, CodeNode>();
      const specialPath = 'src/file-with-dashes_and_underscores.spec.ts';
      nodes.set(specialPath, createTestNode(specialPath, { name: 'file-with-dashes_and_underscores.spec.ts' }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([[specialPath, 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain(`\`${specialPath}\``);
    });

    it('should handle empty code snippets gracefully', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', createTestNode('src/test.ts'));

      nodes.set('src/test.ts#empty', createTestNode('src/test.ts#empty', { type: 'function', name: 'empty', startLine: 5, endLine: 6, codeSnippet: '' }));

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.5],
          ['src/test.ts#empty', 0.3]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('**`function empty`** - _L5_');
      expect(markdown).not.toContain('```typescript\n  \n  ```');
    });
  });
});