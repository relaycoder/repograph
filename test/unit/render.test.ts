import { describe, it, beforeEach, afterEach, expect } from 'bun:test';
import { createMarkdownRenderer } from '../../src/pipeline/render.js';
import { createTreeSitterAnalyzer } from '../../src/pipeline/analyze.js';
import { createPageRanker } from '../../src/pipeline/rank.js';
import type { CodeNode, CodeEdge, FileContent, RankedCodeGraph, RendererOptions } from '../../src/types.js';
import {
  createTempDir,
  cleanupTempDir,
  isValidMarkdown,
  containsValidMermaid,
  extractFilePathsFromMarkdown,
  loadFixture,
  createProjectFromFixture
} from '../test.util.js';

describe('Markdown Rendering', () => {
  let tempDir: string;
  let renderer: ReturnType<typeof createMarkdownRenderer>;

  beforeEach(async () => {
    tempDir = await createTempDir();
    renderer = createMarkdownRenderer();
  });

  afterEach(async () => {
    await cleanupTempDir(tempDir);
  });

  describe('createMarkdownRenderer()', () => {
    it('should return a Renderer function', () => {
      expect(typeof renderer).toBe('function');
    });

    it('should generate valid markdown from empty graph', () => {
      const rankedGraph: RankedCodeGraph = {
        nodes: new Map(),
        edges: [],
        ranks: new Map()
      };

      const markdown = renderer(rankedGraph);

      expect(isValidMarkdown(markdown)).toBe(true);
      expect(markdown).toContain('# RepoGraph');
      expect(markdown).toContain('This repository contains 0 nodes (0 files)');
    });

    it('should include project overview section', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/index.ts', {
        id: 'src/index.ts',
        type: 'file',
        name: 'index.ts',
        filePath: 'src/index.ts',
        startLine: 1,
        endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/index.ts', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('## ðŸš€ Project Overview');
      expect(markdown).toContain('This repository contains 1 nodes (1 files)');
      expect(markdown).toContain('_Generated by RepoGraph on');
    });

    it('should include Mermaid graph by default', () => {
      const nodes = new Map<string, CodeNode>();
      const edges: CodeEdge[] = [];

      nodes.set('src/a.ts', {
        id: 'src/a.ts',
        type: 'file',
        name: 'a.ts',
        filePath: 'src/a.ts',
        startLine: 1,
        endLine: 10
      });

      nodes.set('src/b.ts', {
        id: 'src/b.ts',
        type: 'file',
        name: 'b.ts',
        filePath: 'src/b.ts',
        startLine: 1,
        endLine: 10
      });

      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges,
        ranks: new Map([
          ['src/a.ts', 0.3],
          ['src/b.ts', 0.7]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('### Module Dependency Graph');
      expect(containsValidMermaid(markdown)).toBe(true);
      expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
    });

    it('should exclude Mermaid graph when option is false', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/index.ts', {
        id: 'src/index.ts',
        type: 'file',
        name: 'index.ts',
        filePath: 'src/index.ts',
        startLine: 1,
        endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/index.ts', 0.5]])
      };

      const options: RendererOptions = {
        includeMermaidGraph: false
      };

      const markdown = renderer(rankedGraph, options);

      expect(markdown).not.toContain('### Module Dependency Graph');
      expect(markdown).not.toContain('```mermaid');
    });

    it('should include top 10 most important files', () => {
      const nodes = new Map<string, CodeNode>();
      const ranks = new Map<string, number>();

      // Create 15 files with different ranks
      for (let i = 1; i <= 15; i++) {
        const nodeId = `src/file${i}.ts`;
        nodes.set(nodeId, {
          id: nodeId,
          type: 'file',
          name: `file${i}.ts`,
          filePath: nodeId,
          startLine: 1,
          endLine: 10
        });
        ranks.set(nodeId, i / 15); // Higher numbers get higher ranks
      }

      const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
      const markdown = renderer(rankedGraph);

      const topFilesSection = markdown.split('## ðŸ“‚ File & Symbol Breakdown')[0]!;

      expect(topFilesSection).toContain('### Top 10 Most Important Files');
      expect(topFilesSection).toContain('| Rank | File | Description |');
      
      // Should contain the top 10 files (file15 to file6)
      expect(topFilesSection).toContain('`src/file15.ts`');
      expect(topFilesSection).toContain('`src/file6.ts`');
      
      // Should not contain the lower ranked files
      expect(topFilesSection).not.toContain('`src/file1.ts`');
      expect(topFilesSection).not.toContain('`src/file5.ts`');
    });

    it('should include symbol details by default', () => {
      const nodes = new Map<string, CodeNode>();

      nodes.set('src/test.ts', {
        id: 'src/test.ts',
        type: 'file',
        name: 'test.ts',
        filePath: 'src/test.ts',
        startLine: 1,
        endLine: 20
      });

      nodes.set('src/test.ts#TestClass', {
        id: 'src/test.ts#TestClass',
        type: 'class',
        name: 'TestClass',
        filePath: 'src/test.ts',
        startLine: 5,
        endLine: 15,
        codeSnippet: 'export class TestClass {'
      });

      nodes.set('src/test.ts#testFunction', {
        id: 'src/test.ts#testFunction',
        type: 'function',
        name: 'testFunction',
        filePath: 'src/test.ts',
        startLine: 17,
        endLine: 19,
        codeSnippet: 'export function testFunction(): void'
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.8],
          ['src/test.ts#TestClass', 0.5],
          ['src/test.ts#testFunction', 0.3]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('## ðŸ“‚ File & Symbol Breakdown');
      expect(markdown).toContain('### [`src/test.ts`](./src/test.ts)');
      expect(markdown).toContain('**`class TestClass`** - _L5_');
      expect(markdown).toContain('**`function testFunction`** - _L17_');
      expect(markdown).toContain('export class TestClass {');
      expect(markdown).toContain('export function testFunction(): void');
    });

    it('should exclude symbol details when option is false', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', {
        id: 'src/test.ts',
        type: 'file',
        name: 'test.ts',
        filePath: 'src/test.ts',
        startLine: 1,
        endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/test.ts', 0.5]])
      };

      const options: RendererOptions = {
        includeSymbolDetails: false
      };

      const markdown = renderer(rankedGraph, options);

      expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
    });

    it('should include custom header when provided', () => {
      const rankedGraph: RankedCodeGraph = {
        nodes: new Map(),
        edges: [],
        ranks: new Map()
      };

      const customHeader = '# My Custom Project\n\nThis is a custom description.';
      const options: RendererOptions = {
        customHeader
      };

      const markdown = renderer(rankedGraph, options);

      expect(markdown).toStartWith(customHeader);
      expect(markdown).not.toContain('# RepoGraph');
    });

    it('should handle files with no symbols', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('README.md', {
        id: 'README.md',
        type: 'file',
        name: 'README.md',
        filePath: 'README.md',
        startLine: 1,
        endLine: 5
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['README.md', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('### [`README.md`](./README.md)');
      expect(markdown).toContain('_No symbols identified in this file._');
    });

    it('should sort symbols by line number', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', {
        id: 'src/test.ts',
        type: 'file',
        name: 'test.ts',
        filePath: 'src/test.ts',
        startLine: 1,
        endLine: 30
      });

      // Add symbols in non-sequential order
      nodes.set('src/test.ts#lastFunction', {
        id: 'src/test.ts#lastFunction',
        type: 'function',
        name: 'lastFunction',
        filePath: 'src/test.ts',
        startLine: 25,
        endLine: 28
      });

      nodes.set('src/test.ts#firstFunction', {
        id: 'src/test.ts#firstFunction',
        type: 'function',
        name: 'firstFunction',
        filePath: 'src/test.ts',
        startLine: 5,
        endLine: 10
      });

      nodes.set('src/test.ts#middleClass', {
        id: 'src/test.ts#middleClass',
        type: 'class',
        name: 'middleClass',
        filePath: 'src/test.ts',
        startLine: 15,
        endLine: 20
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.8],
          ['src/test.ts#lastFunction', 0.3],
          ['src/test.ts#firstFunction', 0.5],
          ['src/test.ts#middleClass', 0.4]
        ])
      };

      const markdown = renderer(rankedGraph);

      // Check that symbols appear in line number order
      const firstFunctionIndex = markdown.indexOf('firstFunction');
      const middleClassIndex = markdown.indexOf('middleClass');
      const lastFunctionIndex = markdown.indexOf('lastFunction');

      expect(firstFunctionIndex).toBeLessThan(middleClassIndex);
      expect(middleClassIndex).toBeLessThan(lastFunctionIndex);
    });

    it('should sort files by rank (highest first)', () => {
      const nodes = new Map<string, CodeNode>();
      const files = [
        { id: 'src/low.ts', rank: 0.2 },
        { id: 'src/high.ts', rank: 0.8 },
        { id: 'src/medium.ts', rank: 0.5 }
      ];

      const ranks = new Map<string, number>();

      for (const file of files) {
        nodes.set(file.id, {
          id: file.id,
          type: 'file',
          name: file.id.split('/').pop()!,
          filePath: file.id,
          startLine: 1,
          endLine: 10
        });
        ranks.set(file.id, file.rank);
      }

      const rankedGraph: RankedCodeGraph = { nodes, edges: [], ranks };
      const markdown = renderer(rankedGraph);

      // Check order in the file breakdown section
      const highIndex = markdown.indexOf('[`src/high.ts`]');
      const mediumIndex = markdown.indexOf('[`src/medium.ts`]');
      const lowIndex = markdown.indexOf('[`src/low.ts`]');

      expect(highIndex).toBeLessThan(mediumIndex);
      expect(mediumIndex).toBeLessThan(lowIndex);
    });

    it('should handle symbols without code snippets', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', {
        id: 'src/test.ts',
        type: 'file',
        name: 'test.ts',
        filePath: 'src/test.ts',
        startLine: 1,
        endLine: 10
      });

      nodes.set('src/test.ts#noSnippet', {
        id: 'src/test.ts#noSnippet',
        type: 'function',
        name: 'noSnippet',
        filePath: 'src/test.ts',
        startLine: 5,
        endLine: 8
        // No codeSnippet property
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.5],
          ['src/test.ts#noSnippet', 0.3]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('**`function noSnippet`** - _L5_');
      // Should not include empty code block
      expect(markdown).not.toContain('```typescript\n  \n  ```');
    });

    it('should generate proper markdown links for files', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/nested/deep/file.ts', {
        id: 'src/nested/deep/file.ts',
        type: 'file',
        name: 'file.ts',
        filePath: 'src/nested/deep/file.ts',
        startLine: 1,
        endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/nested/deep/file.ts', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('### [`src/nested/deep/file.ts`](./src/nested/deep/file.ts)');
    });
  });

  describe('Mermaid Graph Generation', () => {
    it('should only include file nodes in Mermaid graph', () => {
      const nodes = new Map<string, CodeNode>();
      const edges: CodeEdge[] = [];

      nodes.set('src/a.ts', {
        id: 'src/a.ts',
        type: 'file',
        name: 'a.ts',
        filePath: 'src/a.ts',
        startLine: 1,
        endLine: 10
      });

      nodes.set('src/a.ts#Class', {
        id: 'src/a.ts#Class',
        type: 'class',
        name: 'Class',
        filePath: 'src/a.ts',
        startLine: 2,
        endLine: 8
      });

      nodes.set('src/b.ts', {
        id: 'src/b.ts',
        type: 'file',
        name: 'b.ts',
        filePath: 'src/b.ts',
        startLine: 1,
        endLine: 10
      });

      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges,
        ranks: new Map([
          ['src/a.ts', 0.5],
          ['src/a.ts#Class', 0.3],
          ['src/b.ts', 0.7]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('src/a.ts["a.ts"] --> src/b.ts["b.ts"]');
      expect(markdown).not.toContain('src/a.ts#Class');
    });

    it('should handle graphs with no file-to-file edges', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/isolated.ts', {
        id: 'src/isolated.ts',
        type: 'file',
        name: 'isolated.ts',
        filePath: 'src/isolated.ts',
        startLine: 1,
        endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([['src/isolated.ts', 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('```mermaid');
      expect(markdown).toContain('graph TD');
      expect(markdown).toContain('```');
    });

    it('should deduplicate edges in Mermaid graph', () => {
      const nodes = new Map<string, CodeNode>();
      const edges: CodeEdge[] = [];
      nodes.set('src/a.ts', {
        id: 'src/a.ts',
        type: 'file',
        name: 'a.ts',
        filePath: 'src/a.ts',
        startLine: 1,
        endLine: 10
      });

      nodes.set('src/b.ts', {
        id: 'src/b.ts',
        type: 'file',
        name: 'b.ts',
        filePath: 'src/b.ts',
        startLine: 1,
        endLine: 10
      });

      // Add multiple edges between the same files (multi-graph)
      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });
      edges.push({ fromId: 'src/a.ts', toId: 'src/b.ts', type: 'imports' });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges,
        ranks: new Map([
          ['src/a.ts', 0.5],
          ['src/b.ts', 0.7]
        ])
      };

      const markdown = renderer(rankedGraph);

      // Should only appear once in the Mermaid graph
      const edgePattern = /src\/a\.ts\["a\.ts"\] --> src\/b\.ts\["b\.ts"\]/g;
      const matches = markdown.match(edgePattern);
      expect(matches).toHaveLength(1);
    });
  });

  describe('Integration with Real Analysis', () => {
    it('should render analyzed TypeScript code correctly', async () => {
      const analyzer = createTreeSitterAnalyzer();
      const ranker = createPageRanker();

      const files: FileContent[] = [
        {
          path: 'src/index.ts',
          content: `import { Calculator } from './calculator.js';

export { Calculator };

export function main(): void {
  const calc = new Calculator();
  console.log(calc.add(1, 2));
}`
        },
        {
          path: 'src/calculator.ts',
          content: `export class Calculator {
  add(a: number, b: number): number {
    return a + b;
  }
  
  subtract = (a: number, b: number): number => {
    return a - b;
  };
}`
        }
      ];

      const graph = await analyzer(files);
      const rankedGraph = await ranker(graph);
      const markdown = renderer(rankedGraph);

      expect(isValidMarkdown(markdown)).toBe(true);
      expect(markdown).toContain('Calculator');
      expect(markdown).toContain('**`class Calculator`**');
      expect(markdown).toContain('**`function main`**');
      expect(markdown).toContain('**`arrow_function subtract`**');
      expect(containsValidMermaid(markdown)).toBe(true);
    });
  });

  describe('Integration with Fixtures', () => {
    it('should render sample-project fixture correctly', async () => {
      const fixture = await loadFixture('sample-project');
      await createProjectFromFixture(tempDir, fixture);

      const analyzer = createTreeSitterAnalyzer();
      const ranker = createPageRanker();

      const files: FileContent[] = [];
      for (const file of fixture.files) {
        if (file.path.endsWith('.ts')) {
          files.push({
            path: file.path,
            content: file.content
          });
        }
      }

      const graph = await analyzer(files);
      const rankedGraph = await ranker(graph);
      const markdown = renderer(rankedGraph);

      expect(isValidMarkdown(markdown)).toBe(true);
      expect(markdown).toContain('Calculator');
      expect(markdown).toContain('Logger');
      expect(markdown).toContain('Config');
      
      const filePaths = extractFilePathsFromMarkdown(markdown);
      expect(filePaths.length).toBeGreaterThan(0);
      expect(filePaths).toContain('src/calculator.ts');
      expect(filePaths).toContain('src/utils/logger.ts');
    });

    it('should render complex-project fixture correctly', async () => {
      const fixture = await loadFixture('complex-project');
      await createProjectFromFixture(tempDir, fixture);

      const analyzer = createTreeSitterAnalyzer();
      const ranker = createPageRanker();

      const files: FileContent[] = [];
      for (const file of fixture.files) {
        if (file.path.endsWith('.ts') && !file.path.includes('test')) {
          files.push({
            path: file.path,
            content: file.content
          });
        }
      }

      const graph = await analyzer(files);
      const rankedGraph = await ranker(graph);
      const markdown = renderer(rankedGraph);

      expect(isValidMarkdown(markdown)).toBe(true);
      expect(markdown).toContain('Database');
      expect(markdown).toContain('ApiServer');
      expect(markdown).toContain('UserService');
      expect(containsValidMermaid(markdown)).toBe(true);
    });

    it('should handle all renderer options with fixtures', async () => {
      const fixture = await loadFixture('minimal-project');
      await createProjectFromFixture(tempDir, fixture);

      const analyzer = createTreeSitterAnalyzer();
      const ranker = createPageRanker();

      const files: FileContent[] = [
        {
          path: 'src/main.ts',
          content: fixture.files[0]!.content
        }
      ];

      const graph = await analyzer(files);
      const rankedGraph = await ranker(graph);

      const options: RendererOptions = {
        customHeader: '# My Minimal Project\n\nCustom description here.',
        includeMermaidGraph: false,
        includeSymbolDetails: false
      };

      const markdown = renderer(rankedGraph, options);

      expect(markdown).toStartWith('# My Minimal Project');
      expect(markdown).not.toContain('```mermaid');
      expect(markdown).not.toContain('## ðŸ“‚ File & Symbol Breakdown');
      expect(markdown).toContain('### Top 10 Most Important Files');
    });
  });

  describe('Edge Cases', () => {
    it('should handle very long file paths', () => {
      const nodes = new Map<string, CodeNode>();
      const longPath = 'src/very/deeply/nested/directory/structure/with/many/levels/file.ts';
      nodes.set(longPath, {
        id: longPath,
        type: 'file',
        name: 'file.ts',
        filePath: longPath,
        startLine: 1,
        endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([[longPath, 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain(`[\`${longPath}\`](./${longPath})`);
    });

    it('should handle special characters in file names', () => {
      const nodes = new Map<string, CodeNode>();
      const specialPath = 'src/file-with-dashes_and_underscores.spec.ts';
      nodes.set(specialPath, {
        id: specialPath,
        type: 'file',
        name: 'file-with-dashes_and_underscores.spec.ts',
        filePath: specialPath,
        startLine: 1,
        endLine: 10
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([[specialPath, 0.5]])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain(`\`${specialPath}\``);
    });

    it('should handle empty code snippets gracefully', () => {
      const nodes = new Map<string, CodeNode>();
      nodes.set('src/test.ts', {
        id: 'src/test.ts',
        type: 'file',
        name: 'test.ts',
        filePath: 'src/test.ts',
        startLine: 1,
        endLine: 10
      });

      nodes.set('src/test.ts#empty', {
        id: 'src/test.ts#empty',
        type: 'function',
        name: 'empty',
        filePath: 'src/test.ts',
        startLine: 5,
        endLine: 6,
        codeSnippet: ''
      });

      const rankedGraph: RankedCodeGraph = {
        nodes,
        edges: [],
        ranks: new Map([
          ['src/test.ts', 0.5],
          ['src/test.ts#empty', 0.3]
        ])
      };

      const markdown = renderer(rankedGraph);

      expect(markdown).toContain('**`function empty`** - _L5_');
      expect(markdown).not.toContain('```typescript\n  \n  ```');
    });
  });
});