import type { Renderer, RankedCodeGraph, RendererOptions } from '../types.js';

const generateMermaidGraph = (rankedGraph: RankedCodeGraph): string => {
  const { graph } = rankedGraph;
  const nodes = graph.filterNodes((_, attrs) => attrs.type === 'file');
  if (nodes.length === 0) return '';

  let mermaidString = '```mermaid\n';
  mermaidString += 'graph TD\n';
  
  const edges = new Set<string>();
  graph.forEachEdge((_edge, _attrs, source, target) => {
      const sourceNode = graph.getNodeAttributes(source);
      const targetNode = graph.getNodeAttributes(target);
      if(sourceNode.type === 'file' && targetNode.type === 'file'){
        const edgeStr = `    ${source}["${sourceNode.name}"] --> ${target}["${targetNode.name}"]`;
        if(!edges.has(edgeStr)) {
            edges.add(edgeStr);
        }
      }
  });

  mermaidString += Array.from(edges).join('\n');
  mermaidString += '\n```\n';
  return mermaidString;
};

const getRank = (id: string, ranks: ReadonlyMap<string, number>): number => ranks.get(id) || 0;

/**
 * Creates the default Markdown renderer. It generates a summary, an optional
 * Mermaid diagram, and a detailed breakdown of files and symbols.
 * @returns A Renderer function.
 */
export const createMarkdownRenderer = (): Renderer => {
  return (rankedGraph: RankedCodeGraph, options: RendererOptions = {}) => {
    const { graph, ranks } = rankedGraph;
    const {
      customHeader,
      includeMermaidGraph = true,
      includeSymbolDetails = true,
    } = options;

    const fileNodes = graph.filterNodes((_, attrs) => attrs.type === 'file');
    const sortedFiles = fileNodes
      .map(id => graph.getNodeAttributes(id))
      .sort((a, b) => getRank(b.id, ranks) - getRank(a.id, ranks));

    let md = customHeader ? `${customHeader}\n\n` : `# RepoGraph\n\n`;
    md += `_Generated by RepoGraph on ${new Date().toISOString()}_\n\n`;
    md += `## ðŸš€ Project Overview\n\n`;
    md += `This repository contains ${graph.order} nodes (${sortedFiles.length} files).\n\n`;

    if (includeMermaidGraph) {
      md += `### Module Dependency Graph\n\n`;
      md += generateMermaidGraph(rankedGraph);
    }
    
    md += `### Top 10 Most Important Files\n\n`;
    md += `| Rank | File | Description |\n`;
    md += `| :--- | :--- | :--- |\n`;
    sortedFiles.slice(0, 10).forEach((file, i) => {
      md += `| ${i + 1} | \`${file.filePath}\` | Key module in the architecture. |\n`;
    });
    md += `\n---\n\n`;

    if (includeSymbolDetails) {
      md += `## ðŸ“‚ File & Symbol Breakdown\n\n`;
      for (const fileNode of sortedFiles) {
        md += `### [\`${fileNode.filePath}\`](./${fileNode.filePath})\n\n`;
        
        const symbolNodes = graph.outNeighbors(fileNode.id)
          .map(id => graph.getNodeAttributes(id))
          .sort((a, b) => a.startLine - b.startLine);

        if (symbolNodes.length > 0) {
          for (const symbol of symbolNodes) {
            md += `- **\`${symbol.type} ${symbol.name}\`** - _L${symbol.startLine}_\n`;
            if (symbol.codeSnippet) {
              md += `  \`\`\`typescript\n  ${symbol.codeSnippet}\n  \`\`\`\n`;
            }
          }
        } else {
            md += `_No symbols identified in this file._\n`
        }
        md += `\n---\n\n`;
      }
    }

    return md;
  };
};