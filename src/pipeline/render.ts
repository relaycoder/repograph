import type { Renderer, RankedCodeGraph, RendererOptions } from '../types.js';

const generateMermaidGraph = (rankedGraph: RankedCodeGraph): string => {
  const fileNodes = [...rankedGraph.nodes.values()].filter(node => node.type === 'file');
  if (fileNodes.length === 0) return '';

  let mermaidString = '```mermaid\n';
  mermaidString += 'graph TD\n';
  
  const edges = new Set<string>();
  for (const edge of rankedGraph.edges) {
      const sourceNode = rankedGraph.nodes.get(edge.fromId);
      const targetNode = rankedGraph.nodes.get(edge.toId);

      if(sourceNode?.type === 'file' && targetNode?.type === 'file' && edge.type === 'imports'){
        const edgeStr = `    ${edge.fromId}["${sourceNode.name}"] --> ${edge.toId}["${targetNode.name}"]`;
        if(!edges.has(edgeStr)) {
            edges.add(edgeStr);
        }
      }
  }

  mermaidString += Array.from(edges).join('\n');
  mermaidString += '\n```\n';
  return mermaidString;
};

const getRank = (id: string, ranks: ReadonlyMap<string, number>): number => ranks.get(id) || 0;

/**
 * Creates the default Markdown renderer. It generates a summary, an optional
 * Mermaid diagram, and a detailed breakdown of files and symbols.
 * @returns A Renderer function.
 */
export const createMarkdownRenderer = (): Renderer => {
  return (rankedGraph: RankedCodeGraph, options: RendererOptions = {}) => {
    const { nodes, ranks } = rankedGraph;
    const {
      customHeader,
      includeMermaidGraph = true,
      includeSymbolDetails = true,
    } = options;

    const fileNodes = [...nodes.values()].filter(attrs => attrs.type === 'file');
    const sortedFiles = fileNodes
      .sort((a, b) => getRank(b.id, ranks) - getRank(a.id, ranks));

    let md = customHeader ? `${customHeader}\n\n` : `# RepoGraph\n\n`;
    md += `_Generated by RepoGraph on ${new Date().toISOString()}_\n\n`;
    md += `## ðŸš€ Project Overview\n\n`;
    md += `This repository contains ${nodes.size} nodes (${sortedFiles.length} files).\n\n`;

    if (includeMermaidGraph) {
      md += `### Module Dependency Graph\n\n`;
      md += generateMermaidGraph(rankedGraph);
    }
    
    md += `### Top 10 Most Important Files\n\n`;
    md += `| Rank | File | Description |\n`;
    md += `| :--- | :--- | :--- |\n`;
    sortedFiles.slice(0, 10).forEach((file, i) => {
      md += `| ${i + 1} | \`${file.filePath}\` | Key module in the architecture. |\n`;
    });
    md += `\n---\n\n`;

    if (includeSymbolDetails) {
      md += `## ðŸ“‚ File & Symbol Breakdown\n\n`;
      for (const fileNode of sortedFiles) {
        md += `### [\`${fileNode.filePath}\`](./${fileNode.filePath})\n\n`;
        
        const symbolNodes = [...nodes.values()]
          .filter(node => node.filePath === fileNode.filePath && node.type !== 'file')
          .sort((a, b) => a.startLine - b.startLine);

        if (symbolNodes.length > 0) {
          for (const symbol of symbolNodes) {
            const outgoingEdges = rankedGraph.edges.filter(e => e.fromId === symbol.id);
            let relations = '';
            if (outgoingEdges.length > 0) {
              const relationParts: string[] = [];
              const inherits = outgoingEdges.filter(e => e.type === 'inherits').map(e => `\`${rankedGraph.nodes.get(e.toId)?.name}\``).join(', ');
              const implements = outgoingEdges.filter(e => e.type === 'implements').map(e => `\`${rankedGraph.nodes.get(e.toId)?.name}\``).join(', ');
              const calls = outgoingEdges.filter(e => e.type === 'calls').map(e => `\`${rankedGraph.nodes.get(e.toId)?.name}\``);
              
              if (inherits) relationParts.push(`inherits ${inherits}`);
              if (implements) relationParts.push(`implements ${implements}`);
              if (calls.length > 0) {
                const displayCalls = calls.slice(0, 3).join(', ');
                relationParts.push(`calls ${displayCalls}${calls.length > 3 ? '...' : ''}`);
              }
              if(relationParts.length > 0) relations = ` (${relationParts.join('; ')})`;
            }
            md += `- **\`${symbol.type} ${symbol.name}\`**${relations} - _L${symbol.startLine}_\n`;
            if (symbol.codeSnippet) {
              // Use language from file extension for syntax highlighting if possible
              const lang = fileNode.filePath.split('.').pop() || 'typescript';
              md += `  \`\`\`${lang}\n  ${symbol.codeSnippet}\n  \`\`\`\n`;
            }
          }
        } else {
            md += `_No symbols identified in this file._\n`
        }
        md += `\n---\n\n`;
      }
    }

    return md;
  };
};