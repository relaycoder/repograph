uuid: bf3a1e9e-a0e0-47b7-b003-85f858882ca1
projectId: repograph
createdAt: '2025-07-23T10:39:49.030Z'
linesAdded: 21
linesRemoved: 9
gitCommitMsg: 'fix: resolve typescript compilation errors'
promptSummary: >-
  The user is reporting multiple TypeScript compilation errors after the
  browser-compatibility changes. The errors are related to `window` not being
  defined, a missing type import, and unsafe array access from `string.split()`.
  The fix involves updating `tsconfig.json`, adding a missing import, and adding
  checks to ensure path segments from `split()` are not undefined.
reasoning:
  - >-
    I apologize for the compilation errors. My previous changes didn't fully
    account for TypeScript's strictness regarding browser and Node.js
    environments. I've identified all the issues and will now apply the fixes.
  - '### Step 1: Update `tsconfig.json`'
  - >-
    The `Cannot find name 'window'` errors occur because the TypeScript compiler
    isn't configured to recognize browser-specific global variables. I will add
    `"DOM"` to the `lib` option in `tsconfig.json` to resolve this.
  - '### Step 2: Fix Missing Import in `high-level.ts`'
  - >-
    The `Cannot find name 'FileContent'` error is a simple missing import. I'll
    add it.
  - '### Step 3: Add Robustness to WASM Path Handling'
  - >-
    The `Argument of type 'string | undefined'` errors in
    `tree-sitter/languages.ts` and `tsup.config.ts` are due to `split('/')`
    potentially returning an array with only one element. I will add checks to
    ensure the filename exists before using it, making the code more robust.
  - 'First, in the language loader:'
  - 'Next, in the build script `tsup.config.ts`:'
  - >-
    These changes should resolve all the reported TypeScript errors and make the
    library more robust.
operations:
  - type: write
    path: tsconfig.json
    content: |-
      --- tsconfig.json
      +++ tsconfig.json
      @@ -1,6 +1,6 @@
       {
         "compilerOptions": {
           // Environment setup & latest features
      -    "lib": ["ESNext"],
      +    "lib": ["ESNext", "DOM"],
           "target": "ESNext",
           "module": "Preserve",
           "moduleDetection": "force",
    patchStrategy: new-unified
  - type: write
    path: src/high-level.ts
    content: >-
      --- src/high-level.ts

      +++ src/high-level.ts

      @@ -2,7 +2,7 @@
       import { createTreeSitterAnalyzer } from './pipeline/analyze';
       import { createPageRanker, createGitRanker } from './pipeline/rank';
       import { createMarkdownRenderer } from './pipeline/render';
      -import type { RepoGraphOptions, Ranker, RankedCodeGraph } from './types';

      +import type { RepoGraphOptions, Ranker, RankedCodeGraph, FileContent }
      from './types';
       import path from 'node:path';
       import { logger } from './utils/logger.util';
       import { writeFile } from './utils/fs.util';
    patchStrategy: new-unified
  - type: write
    path: src/tree-sitter/languages.ts
    content: >-
      --- src/tree-sitter/languages.ts

      +++ src/tree-sitter/languages.ts

      @@ -58,27 +58,34 @@
                 config.name
               );
             }
      -      const wasmFileName = config.wasmPath.split('/')[1];

      +      const wasmFileName = config.wasmPath.split('/')[1];

      +      if (!wasmFileName) {

      +        throw new ParserError(`Invalid wasmPath for ${config.name}:
      ${config.wasmPath}`, config.name);

      +      }
             const baseUrl = wasmBaseUrl.endsWith('/') ? wasmBaseUrl : `${wasmBaseUrl}/`;
             finalWasmPath = new URL(baseUrl + wasmFileName, window.location.href).href;
           } else {
             // Node.js logic
      -      const distWasmPath = path.resolve(getDirname(), '..', 'wasm',
      config.wasmPath.split('/')[1]);

      +      const wasmFileName = config.wasmPath.split('/')[1];

      +      if (!wasmFileName) {

      +        throw new ParserError(`Invalid wasmPath format for
      ${config.name}: ${config.wasmPath}. Expected 'package/file.wasm'.`,
      config.name);

      +      }

      +      const distWasmPath = path.resolve(getDirname(), '..', 'wasm',
      wasmFileName);
             const nodeModulesWasmPath = path.resolve(getDirname(), '..', '..', 'node_modules', config.wasmPath);
      -      

      +
             logger.debug(`Trying WASM paths: dist=${distWasmPath}, nodeModules=${nodeModulesWasmPath}`);
      -      

      +
             const fs = await import('node:fs');
             if (fs.existsSync(distWasmPath)) {
               finalWasmPath = distWasmPath;
             } else if (fs.existsSync(nodeModulesWasmPath)) {
               finalWasmPath = nodeModulesWasmPath;
             } else {
      -        throw new Error(`WASM file not found at either ${distWasmPath} or
      ${nodeModulesWasmPath}`);

      +        throw new Error(`WASM file not found at either ${distWasmPath} or
      ${nodeModulesWasmPath}`);
             }
           }
      -    

      +
           logger.debug(`Loading WASM from: ${finalWasmPath}`);
           const language = await Parser.Language.load(finalWasmPath);
      -    

      +
           const loadedLanguage: LoadedLanguage = {
             config,
             language
    patchStrategy: new-unified
  - type: write
    path: tsup.config.ts
    content: |-
      --- tsup.config.ts
      +++ tsup.config.ts
      @@ -38,12 +38,17 @@
       
           for (const wasmFile of wasmFiles) {
             const srcPath = join('node_modules', wasmFile);
      -      const destPath = join('dist', 'wasm', wasmFile.split('/')[1]);
      +      const wasmFileName = wasmFile.split('/')[1];
      +      if (!wasmFileName) {
      +        console.warn(`Skipping invalid wasmFile path: ${wasmFile}`);
      +        continue;
      +      }
      +      const destPath = join('dist', 'wasm', wasmFileName);
             
             if (existsSync(srcPath)) {
               copyFileSync(srcPath, destPath);
      -        console.log(`Copied ${wasmFile} to dist/wasm/`);
      +        console.log(`Copied ${wasmFileName} to dist/wasm/`);
             }
           }
         },
    patchStrategy: new-unified
snapshot:
  tsconfig.json: |
    {
      "compilerOptions": {
        // Environment setup & latest features
        "lib": ["ESNext"],
        "target": "ESNext",
        "module": "Preserve",
        "moduleDetection": "force",
        "jsx": "react-jsx",
        "allowJs": true,

        // Bundler mode
        "moduleResolution": "bundler",
        "verbatimModuleSyntax": true,
        "noEmit": true,

        // Best practices
        "strict": true,
        "skipLibCheck": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedIndexedAccess": true,
        "noImplicitOverride": true,

        // Some stricter flags (disabled by default)
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noImplicitAny": true,
        "noPropertyAccessFromIndexSignature": true,

        // Type roots
        "typeRoots": ["./node_modules/@types", "./src/types", "./test/**/*"]
      }
    }
  src/high-level.ts: >-
    import { createDefaultDiscoverer } from './pipeline/discover';

    import { createTreeSitterAnalyzer } from './pipeline/analyze';

    import { createPageRanker, createGitRanker } from './pipeline/rank';

    import { createMarkdownRenderer } from './pipeline/render';

    import type { RepoGraphOptions, Ranker, RankedCodeGraph } from './types';

    import path from 'node:path';

    import { logger } from './utils/logger.util';

    import { writeFile } from './utils/fs.util';

    import { RepoGraphError } from './utils/error.util';


    const selectRanker = (rankingStrategy: RepoGraphOptions['rankingStrategy'] =
    'pagerank'): Ranker => {
      if (rankingStrategy === 'git-changes') {
        return createGitRanker();
      }
      if (rankingStrategy === 'pagerank') {
        return createPageRanker();
      }
      throw new Error(`Invalid ranking strategy: '${rankingStrategy}'. Available options are 'pagerank', 'git-changes'.`);
    };


    /**
     * A mid-level API for programmatically generating and receiving the code graph
     * without rendering it to a file. Ideal for integration with other tools.
     *
     * @param options The configuration object for generating the map.
     * @returns The generated `RankedCodeGraph`.
     */
    export const analyzeProject = async (options: RepoGraphOptions = {}):
    Promise<RankedCodeGraph> => {
      const { root, logLevel, include, ignore, noGitignore, maxWorkers, files: inputFiles } = options;
      const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

      if (logLevel) {
        logger.setLevel(logLevel);
      }

      // Validate options before entering the main try...catch block to provide clear errors.
      const ranker = selectRanker(options.rankingStrategy);

      try {
        let files: readonly FileContent[];
        if (inputFiles && inputFiles.length > 0) {
          logger.info('1/3 Using provided files...');
          files = inputFiles;
        } else {
          if (isBrowser) {
            throw new RepoGraphError('File discovery is not supported in the browser. Please provide the `files` option with file content.');
          }
          const effectiveRoot = root || process.cwd();
          logger.info(`1/3 Discovering files in "${effectiveRoot}"...`);
          const discoverer = createDefaultDiscoverer();
          files = await discoverer({ root: path.resolve(effectiveRoot), include, ignore, noGitignore });
        }
        logger.debug(`  -> Found ${files.length} files to analyze.`);

        logger.info('2/3 Analyzing code and building graph...');
        const analyzer = createTreeSitterAnalyzer({ maxWorkers });
        const graph = await analyzer(files);
        logger.debug(`  -> Built graph with ${graph.nodes.size} nodes and ${graph.edges.length} edges.`);

        logger.info('3/3 Ranking graph nodes...');
        const rankedGraph = await ranker(graph);
        logger.debug('  -> Ranking complete.');

        return rankedGraph;
      } catch (error) {
        throw new RepoGraphError(`Failed to analyze project`, error);
      }
    };


    /**
     * The primary, easy-to-use entry point for RepoGraph. It orchestrates the
     * default pipeline based on a configuration object to generate a codemap.
     *
     * @param options The configuration object for generating the map.
     */
    export const generateMap = async (options: RepoGraphOptions = {}):
    Promise<void> => {
      const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
      if (isBrowser) {
        throw new RepoGraphError('`generateMap` is not supported in the browser because it cannot write to the file system. Use `analyzeProject` and a `Renderer` instead.');
      }

      const finalOptions = { ...options, logLevel: options.logLevel ?? 'info' };

      const {
        root = process.cwd(),
        output = './repograph.md',
      } = finalOptions;

      try {
        // We get the full ranked graph first
        const rankedGraph = await analyzeProject(finalOptions);

        logger.info('4/4 Rendering output...');
        const renderer = createMarkdownRenderer();
        const markdown = renderer(rankedGraph, finalOptions.rendererOptions);
        logger.debug('  -> Rendering complete.');

        const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);

        logger.info(`Writing report to ${path.relative(process.cwd(), outputPath)}...`);
        await writeFile(outputPath, markdown);
        logger.info('  -> Report saved.');
      } catch (error) {
        // The underlying `analyzeProject` already wraps the error, so we just re-throw.
        throw error;
      }
    };
  src/tree-sitter/languages.ts: >-
    import * as Parser from 'web-tree-sitter';

    import path from 'node:path';

    import { fileURLToPath } from 'node:url';

    import { LANGUAGE_CONFIGS, type LanguageConfig, type LoadedLanguage } from
    './language-config';

    import { logger } from '../utils/logger.util';

    import { ParserError } from '../utils/error.util';


    // Helper to get the correct path in different environments

    const getDirname = () => path.dirname(fileURLToPath(import.meta.url));


    const isBrowser = typeof window !== 'undefined' && typeof window.document
    !== 'undefined';


    export interface ParserInitializationOptions {
      /**
       * For browser environments, sets the base URL from which to load Tree-sitter WASM files.
       * For example, if your WASM files are in `public/wasm`, you would set this to `/wasm/`.
       * This option is ignored in Node.js environments.
       */
      wasmBaseUrl?: string;
    }


    let wasmBaseUrl: string | null = null;

    let isInitialized = false;

    const loadedLanguages = new Map<string, LoadedLanguage>();


    /**
     * Initializes the Tree-sitter parser system.
     * This must be called before any other parser functions.
     * This function is idempotent.
     */
    export const initializeParser = async (options: ParserInitializationOptions
    = {}): Promise<void> => {
      if (isInitialized) {
        return;
      }
      if (isBrowser && options.wasmBaseUrl) wasmBaseUrl = options.wasmBaseUrl;

      await Parser.Parser.init();
      isInitialized = true;
    };


    /**
     * Loads a specific language grammar.
     * @param config The language configuration to load
     * @returns A LoadedLanguage object containing the config and language
     */
    export const loadLanguage = async (config: LanguageConfig):
    Promise<LoadedLanguage> => {
      if (loadedLanguages.has(config.name)) {
        return loadedLanguages.get(config.name)!;
      }

      await initializeParser();

      try {
        let finalWasmPath: string;

        if (isBrowser) {
          if (!wasmBaseUrl) {
            throw new ParserError(
              'In a browser environment, you must call initializeParser({ wasmBaseUrl: "..." }) before loading languages.',
              config.name
            );
          }
          const wasmFileName = config.wasmPath.split('/')[1];
          const baseUrl = wasmBaseUrl.endsWith('/') ? wasmBaseUrl : `${wasmBaseUrl}/`;
          finalWasmPath = new URL(baseUrl + wasmFileName, window.location.href).href;
        } else {
          // Node.js logic
          const distWasmPath = path.resolve(getDirname(), '..', 'wasm', config.wasmPath.split('/')[1]);
          const nodeModulesWasmPath = path.resolve(getDirname(), '..', '..', 'node_modules', config.wasmPath);
          
          logger.debug(`Trying WASM paths: dist=${distWasmPath}, nodeModules=${nodeModulesWasmPath}`);
          
          const fs = await import('node:fs');
          if (fs.existsSync(distWasmPath)) {
            finalWasmPath = distWasmPath;
          } else if (fs.existsSync(nodeModulesWasmPath)) {
            finalWasmPath = nodeModulesWasmPath;
          } else {
            throw new Error(`WASM file not found at either ${distWasmPath} or ${nodeModulesWasmPath}`);
          }
        }
        
        logger.debug(`Loading WASM from: ${finalWasmPath}`);
        const language = await Parser.Language.load(finalWasmPath);
        
        const loadedLanguage: LoadedLanguage = {
          config,
          language
        };
        
        loadedLanguages.set(config.name, loadedLanguage);
        return loadedLanguage;
      } catch (error) {
        const message = `Failed to load Tree-sitter WASM file for ${config.name}. Please ensure '${config.wasmPath.split('/')[0]}' is installed.`;
        logger.error(message, error);
        throw new ParserError(message, config.name, error);
      }
    };


    /**
     * Creates a parser instance for a specific language.
     * @param config The language configuration
     * @returns A parser instance configured for the specified language
     */
    export const createParserForLanguage = async (config: LanguageConfig):
    Promise<Parser.Parser> => {
      const loadedLanguage = await loadLanguage(config);
      const parser = new Parser.Parser();
      parser.setLanguage(loadedLanguage.language);
      return parser;
    };


    /**
     * Gets all loaded languages.
     * @returns A map of language names to LoadedLanguage objects
     */
    export const getLoadedLanguages = (): Map<string, LoadedLanguage> => {
      return new Map(loadedLanguages);
    };


    /**
     * Preloads all supported languages.
     * This can be called to eagerly load all language parsers.
     */
    export const preloadAllLanguages = async (): Promise<void> => {
      await Promise.all(LANGUAGE_CONFIGS.map(config => loadLanguage(config)));
    };



    // Legacy function for backward compatibility

    export const getParser = async (): Promise<Parser.Parser> => {
      const tsConfig = LANGUAGE_CONFIGS.find(config => config.name === 'typescript');
      if (!tsConfig) {
        throw new Error('TypeScript configuration not found');
      }
      return createParserForLanguage(tsConfig);
    };
  tsup.config.ts: |-
    import { defineConfig } from 'tsup';
    import { copyFileSync, mkdirSync, existsSync } from 'fs';
    import { join } from 'path';

    export default defineConfig({
      entry: ['src/index.ts', 'src/pipeline/analyzer.worker.ts'],
      format: ['esm'],
      target: 'es2022',
      dts: true,
      sourcemap: true,
      clean: true,
      splitting: true,
      treeshake: true,
      minify: false,
      outDir: 'dist',
      onSuccess: async () => {
        // Copy WASM files to dist folder
        const wasmDir = join('dist', 'wasm');
        if (!existsSync(wasmDir)) {
          mkdirSync(wasmDir, { recursive: true });
        }

        const wasmFiles = [
          'tree-sitter-typescript/tree-sitter-typescript.wasm',
          'tree-sitter-typescript/tree-sitter-tsx.wasm',
          'tree-sitter-javascript/tree-sitter-javascript.wasm',
          'tree-sitter-python/tree-sitter-python.wasm',
          'tree-sitter-java/tree-sitter-java.wasm',
          'tree-sitter-c/tree-sitter-c.wasm',
          'tree-sitter-cpp/tree-sitter-cpp.wasm',
          'tree-sitter-c-sharp/tree-sitter-c-sharp.wasm',
          'tree-sitter-css/tree-sitter-css.wasm',
          'tree-sitter-go/tree-sitter-go.wasm',
          'tree-sitter-php/tree-sitter-php.wasm',
          'tree-sitter-ruby/tree-sitter-ruby.wasm',
          'tree-sitter-rust/tree-sitter-rust.wasm',
          'tree-sitter-solidity/tree-sitter-solidity.wasm',
          'tree-sitter-swift/tree-sitter-swift.wasm',
          'tree-sitter-vue/tree-sitter-vue.wasm',
        ];

        for (const wasmFile of wasmFiles) {
          const srcPath = join('node_modules', wasmFile);
          const destPath = join('dist', 'wasm', wasmFile.split('/')[1]);
          
          if (existsSync(srcPath)) {
            copyFileSync(srcPath, destPath);
            console.log(`Copied ${wasmFile} to dist/wasm/`);
          }
        }
      },
    });
approved: true
