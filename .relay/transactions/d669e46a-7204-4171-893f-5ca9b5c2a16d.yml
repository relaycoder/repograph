uuid: d669e46a-7204-4171-893f-5ca9b5c2a16d
projectId: repograph
createdAt: '2025-07-20T06:45:47.272Z'
linesAdded: 150
linesRemoved: 64
gitCommitMsg: 'feat(analysis): enrich data model for scn-ts integration'
promptSummary: >-
  Implement the changes described in the 'Analysis Report: Preparing repograph
  for scn-ts Integration' to enrich the data model and expand language support
  for UI constructs.
reasoning:
  - >-
    Here are the comprehensive changes to prepare `repograph` for `scn-ts`
    integration, as outlined in the analysis report.
  - '### Step 1: Enrich Core Data Types'
  - >-
    First, I'll update `src/types.ts` to enrich the `CodeNode` model. This
    involves adding fields for deeper semantics (`canThrow`, `isPure`) and new
    types and fields to support UI constructs (`html_element`, `css_rule`,
    etc.), as specified in the report.
  - '### Step 2: Update `package.json` for UI Parsing'
  - >-
    To support CSS parsing as required by the report, I'll add the necessary
    Tree-sitter dependency to `package.json`. This makes the project ready to
    handle `.css` files.
  - '### Step 3: Enhance Language Configurations and Queries'
  - >-
    This is a significant update to `src/tree-sitter/language-config.ts`. I am
    replacing the entire file as requested to ensure correctness and avoid
    escaping issues.
  - 'The key changes are:'
  - >-
    1.  **Adding "Throws" Qualifiers**: I've added captures for `throw`
    statements (e.g., `(throw_statement) @qualifier.throws`) to the queries for
    TypeScript, TSX, Java, C#, C++, and Python (`raise_statement`).
  - '2.  **Enhancing UI Language Queries**:'
  - >-
    *   The **TSX** query is now a proper superset of the TypeScript query,
    ensuring no detail is lost, and adds captures for JSX elements
    (`(jsx_opening_element ... ) @html.element.definition`).
  - >-
    *   The **Vue** query is enhanced to parse basic elements from the
    `<template>` block.
  - >-
    3.  **Adding CSS Language Support**: A new configuration block for CSS is
    added to parse `.css` files, capturing rule sets and their selectors.
  - >-
    4.  **Improving Consistency**: Generally making queries more robust and
    consistent across languages.
  - '### Step 4: Update the Analyzer to Process New Information'
  - >-
    Finally, I'll modify the core analyzer logic in `src/pipeline/analyze.ts`.
    These changes enable it to understand the new query captures and populate
    the enriched `CodeNode` fields.
  - >-
    1.  **Recognize New Symbol Types**: The analyzer now knows about
    `html_element` and `css_rule`.
  - >-
    2.  **Process New Qualifiers**: It checks for `qualifier.throws` captures to
    set the `canThrow` flag on nodes.
  - >-
    3.  **Handle UI Symbols**: It includes special logic to correctly name and
    identify UI symbols (HTML tags and CSS selectors) and populate their
    specific fields (`htmlTag`, `cssSelector`). I've also adjusted the ID
    generation for HTML elements to ensure they are unique within a file.
  - >-
    These changes successfully prepare `repograph` to serve as a powerful engine
    for `scn-ts` by enriching its data model and analytical capabilities,
    directly addressing the requirements from your report.
operations:
  - type: write
    path: src/types.ts
    content: |-
      --- src/types.ts
      +++ src/types.ts
      @@ -19,7 +19,9 @@
         | 'constructor'
         | 'property'
         | 'constant'
         | 'static'
         | 'union'
      -  | 'template';
      +  | 'template'
      +  | 'html_element'
      +  | 'css_rule';
       
       /** New type for access modifiers. */
       export type CodeNodeVisibility = 'public' | 'private' | 'protected' | 'internal' | 'default';
      @@ -40,6 +42,16 @@
         readonly returnType?: string;
         /** An array of parameters for functions/methods. */
         readonly parameters?: { name: string; type?: string }[];
      +  /** Whether a function is known to throw exceptions. Maps to SCN '!' */
      +  readonly canThrow?: boolean;
      +  /** Whether a function is believed to be pure. Maps to SCN 'o' */
      +  readonly isPure?: boolean;
      +  /** For UI nodes, the HTML tag name (e.g., 'div'). */
      +  readonly htmlTag?: string;
      +  /** For UI nodes, a map of attributes. */
      +  readonly attributes?: ReadonlyMap<string, string>;
      +  /** For CSS nodes, the full selector. */
      +  readonly cssSelector?: string;
       };
       
       /** Represents a directed relationship between two CodeNodes. Immutable. */
    patchStrategy: new-unified
  - type: write
    path: package.json
    content: |-
      <<<<<<< SEARCH
          "tree-sitter-c": "^0.24.1",
          "tree-sitter-c-sharp": "^0.23.1",
          "tree-sitter-cpp": "^0.23.4",
      =======
          "tree-sitter-c": "^0.24.1",
          "tree-sitter-c-sharp": "^0.23.1",
          "tree-sitter-css": "^0.20.0",
          "tree-sitter-cpp": "^0.23.4",
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/tree-sitter/language-config.ts
    content: >-
      import type { Language } from 'web-tree-sitter';


      export interface LanguageConfig {
        name: string;
        extensions: string[];
        wasmPath: string;
        query: string;
      }


      export interface LoadedLanguage {
        config: LanguageConfig;
        language: Language;
      }


      export const LANGUAGE_CONFIGS: LanguageConfig[] = [
        {
          name: 'typescript',
          extensions: ['.ts', '.js', '.mjs', '.cjs'],
          wasmPath: 'tree-sitter-typescript/tree-sitter-typescript.wasm',
          query: `
      (import_statement
        source: (string) @import.source) @import.statement

      (class_declaration) @class.definition

      (export_statement declaration: (class_declaration)) @class.definition


      (function_declaration
        ("async")? @qualifier.async
        parameters: (formal_parameters) @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      ) @function.definition

      (export_statement
        declaration: (function_declaration
          ("async")? @qualifier.async
          parameters: (formal_parameters) @symbol.parameters
          return_type: (type_annotation)? @symbol.returnType
        )
      ) @function.definition


      (variable_declarator
        value: (arrow_function
          ("async")? @qualifier.async
          parameters: (formal_parameters)? @symbol.parameters
          return_type: (type_annotation)? @symbol.returnType
        )
      ) @function.arrow.definition

      (public_field_definition
        value: (arrow_function
          ("async")? @qualifier.async
          parameters: (formal_parameters)? @symbol.parameters
          return_type: (type_annotation)? @symbol.returnType
        )
      ) @function.arrow.definition

      (export_statement
        declaration: (lexical_declaration
          (variable_declarator
            value: (arrow_function
              ("async")? @qualifier.async
              parameters: (formal_parameters)? @symbol.parameters
              return_type: (type_annotation)? @symbol.returnType
            )
          )
        )
      ) @function.arrow.definition


      (interface_declaration) @interface.definition

      (export_statement declaration: (interface_declaration))
      @interface.definition


      (type_alias_declaration) @type.definition

      (export_statement declaration: (type_alias_declaration)) @type.definition


      (enum_declaration) @enum.definition

      (export_statement declaration: (enum_declaration)) @enum.definition


      (method_definition
        (accessibility_modifier)? @qualifier.visibility
        ("static")? @qualifier.static
        ("async")? @qualifier.async
        parameters: (formal_parameters) @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      ) @method.definition


      (public_field_definition
        (accessibility_modifier)? @qualifier.visibility
        ("static")? @qualifier.static
        type: (type_annotation)? @symbol.returnType
      ) @field.definition


      (variable_declarator) @variable.definition

      (export_statement declaration: (lexical_declaration
      (variable_declarator))) @variable.definition


      (call_expression
        function: (identifier) @function.call)

      (throw_statement) @qualifier.throws


      ; Class inheritance and implementation patterns

      (extends_clause (identifier) @class.inheritance)

      (implements_clause (type_identifier) @class.implementation)

      `
        },
        {
          name: 'tsx',
          extensions: ['.tsx', '.jsx'],
          wasmPath: 'tree-sitter-typescript/tree-sitter-tsx.wasm',
          query: `
      (import_statement
        source: (string) @import.source) @import.statement

      (class_declaration) @class.definition

      (export_statement declaration: (class_declaration)) @class.definition


      (function_declaration
        ("async")? @qualifier.async
        parameters: (formal_parameters) @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      ) @function.definition

      (export_statement
        declaration: (function_declaration
          ("async")? @qualifier.async
          parameters: (formal_parameters) @symbol.parameters
          return_type: (type_annotation)? @symbol.returnType
        )
      ) @function.definition


      (variable_declarator
        value: (arrow_function
          ("async")? @qualifier.async
          parameters: (formal_parameters)? @symbol.parameters
          return_type: (type_annotation)? @symbol.returnType
        )
      ) @function.arrow.definition

      (public_field_definition
        value: (arrow_function
          ("async")? @qualifier.async
          parameters: (formal_parameters)? @symbol.parameters
          return_type: (type_annotation)? @symbol.returnType
        )
      ) @function.arrow.definition

      (export_statement
        declaration: (lexical_declaration
          (variable_declarator
            value: (arrow_function
              ("async")? @qualifier.async
              parameters: (formal_parameters)? @symbol.parameters
              return_type: (type_annotation)? @symbol.returnType
            )
          )
        )
      ) @function.arrow.definition


      (interface_declaration) @interface.definition

      (export_statement declaration: (interface_declaration))
      @interface.definition


      (type_alias_declaration) @type.definition

      (export_statement declaration: (type_alias_declaration)) @type.definition


      (enum_declaration) @enum.definition

      (export_statement declaration: (enum_declaration)) @enum.definition


      (method_definition
        (accessibility_modifier)? @qualifier.visibility
        ("static")? @qualifier.static
        ("async")? @qualifier.async
        parameters: (formal_parameters) @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      ) @method.definition


      (public_field_definition
        (accessibility_modifier)? @qualifier.visibility
        ("static")? @qualifier.static
        type: (type_annotation)? @symbol.returnType
      ) @field.definition


      (variable_declarator) @variable.definition

      (export_statement declaration: (lexical_declaration
      (variable_declarator))) @variable.definition


      (call_expression
        function: (identifier) @function.call)

      (throw_statement) @qualifier.throws


      ; Class inheritance and implementation patterns

      (extends_clause (identifier) @class.inheritance)

      (implements_clause (type_identifier) @class.implementation)


      ; JSX/TSX specific

      (jsx_opening_element
        name: (_) @html.tag
      ) @html.element.definition

      `
        },
        {
          name: 'python',
          extensions: ['.py', '.pyw'],
          wasmPath: 'tree-sitter-python/tree-sitter-python.wasm',
          query: `
      (import_statement) @import.statement

      (import_from_statement
        module_name: (relative_import) @import.source) @import.statement
      (import_from_statement
        module_name: (dotted_name) @import.source) @import.statement

      (class_definition) @class.definition


      (function_definition) @function.definition


      (decorated_definition
        (function_definition)) @function.definition

      (decorated_definition
        (class_definition)) @class.definition

      (class_definition
        body: (block (function_definition) @method.definition))

      (expression_statement
        (assignment)) @variable.definition

      (raise_statement) @qualifier.throws


      ; Python inheritance patterns

      (class_definition
        superclasses: (argument_list (identifier) @class.inheritance))
      `
        },
        {
          name: 'java',
          extensions: ['.java'],
          wasmPath: 'tree-sitter-java/tree-sitter-java.wasm',
          query: `
      (import_declaration
        (scoped_identifier) @import.source) @import.statement

      (class_declaration) @class.definition

      (interface_declaration) @interface.definition

      (enum_declaration) @enum.definition


      (method_declaration
        (modifiers (modifier "static")?) @qualifier.static
      ) @method.definition


      (constructor_declaration) @constructor.definition


      (field_declaration) @field.definition


      (throw_statement) @qualifier.throws


      ; Java inheritance and implementation patterns

      (superclass (type_identifier) @class.inheritance)

      (super_interfaces (type_list (type_identifier) @class.implementation))


      `
        },
        {
          name: 'cpp',
          extensions: ['.cpp', '.cc', '.cxx', '.h', '.hpp', '.hh', '.hxx'],
          wasmPath: 'tree-sitter-cpp/tree-sitter-cpp.wasm',
          query: `
      (preproc_include) @import.statement


      (function_definition) @function.definition

      (declaration
        declarator: (function_declarator)) @function.declaration

      (class_specifier) @class.definition

      (struct_specifier) @struct.definition

      (union_specifier) @union.definition

      (enum_specifier) @enum.definition


      (namespace_definition) @namespace.definition


      (template_declaration) @template.definition


      (function_definition declarator: (qualified_identifier))
      @method.definition

      (field_declaration declarator: (function_declarator)) @method.definition

      (field_declaration) @field.definition


      (throw_expression) @qualifier.throws

      `
        },
        {
          name: 'c',
          extensions: ['.c'],
          wasmPath: 'tree-sitter-c/tree-sitter-c.wasm',
          query: `
      (preproc_include) @import.statement


      (function_definition) @function.definition

      (declaration declarator: (function_declarator)) @function.declaration

      (struct_specifier) @struct.definition

      (union_specifier) @union.definition

      (enum_specifier) @enum.definition

      (type_definition) @type.definition

      `
        },
        {
          name: 'go',
          extensions: ['.go'],
          wasmPath: 'tree-sitter-go/tree-sitter-go.wasm',
          query: `
      (import_declaration) @import.statement


      (function_declaration) @function.definition

      (method_declaration) @method.definition


      (type_declaration) @type.definition


      (var_declaration) @variable.definition

      (const_declaration) @constant.definition

      `
        },
        {
          name: 'rust',
          extensions: ['.rs'],
          wasmPath: 'tree-sitter-rust/tree-sitter-rust.wasm',
          query: `
      (mod_item
        name: (identifier) @import.source) @import.statement

      (function_item) @function.definition

      (impl_item) @impl.definition


      (struct_item) @struct.definition

      (enum_item) @enum.definition

      (trait_item) @trait.definition

      (function_signature_item) @method.definition


      (type_item) @type.definition

      (const_item) @constant.definition

      (static_item) @static.definition


      (function_signature_item) @function.declaration

      `
        },
        {
          name: 'csharp',
          extensions: ['.cs'],
          wasmPath: 'tree-sitter-c-sharp/tree-sitter-c_sharp.wasm',
          query: `
      (using_directive) @import.statement


      (class_declaration) @class.definition

      (interface_declaration) @interface.definition

      (struct_declaration) @struct.definition

      (enum_declaration) @enum.definition


      (method_declaration) @method.definition

      (constructor_declaration) @constructor.definition


      (field_declaration) @field.definition

      (property_declaration) @property.definition


      (namespace_declaration) @namespace.definition


      (throw_statement) @qualifier.throws

      `
        },
        {
          name: 'php',
          extensions: ['.php'],
          wasmPath: 'tree-sitter-php/tree-sitter-php.wasm',
          query: `
            (namespace_definition) @namespace.definition
            (class_declaration) @class.definition
            (function_definition) @function.definition
            (method_declaration) @method.definition
          `
        },
        {
          name: 'ruby',
          extensions: ['.rb'],
          wasmPath: 'tree-sitter-ruby/tree-sitter-ruby.wasm',
          query: `
            (module) @module.definition
            (class) @class.definition
            (method) @method.definition
            (singleton_method) @method.definition
          `
        },
        {
          name: 'solidity',
          extensions: ['.sol'],
          wasmPath: 'tree-sitter-solidity/tree-sitter-solidity.wasm',
          query: `
            (contract_declaration) @class.definition
            (function_definition) @function.definition
            (event_definition) @enum.definition
          `
        },
        {
          name: 'swift',
          extensions: ['.swift'],
          wasmPath: 'tree-sitter-swift/tree-sitter-swift.wasm',
          query: `
            (class_declaration) @class.definition
            (protocol_declaration) @trait.definition
            (function_declaration) @function.definition
            (protocol_function_declaration) @function.definition
            (property_declaration) @field.definition
          `
        },
        {
          name: 'vue',
          extensions: ['.vue'],
          wasmPath: 'tree-sitter-vue/tree-sitter-vue.wasm',
          query: `
            (script_element .
              [
                (lexical_declaration (variable_declarator)) @variable.definition
                (function_declaration) @function.definition
              ])

            (element
              (start_tag
                (tag_name) @html.tag
              )
            ) @html.element.definition
      `
        },
        {
          name: 'css',
          extensions: ['.css'],
          wasmPath: 'tree-sitter-css/tree-sitter-css.wasm',
          query: `
            (rule_set
              selectors: (selectors) @css.selector
            ) @css.rule.definition
          `
        }
      ];


      /**
       * Get the language configuration for a given file extension
       */
      export function getLanguageConfigForFile(filePath: string): LanguageConfig
      | null {
        const extension = filePath.substring(filePath.lastIndexOf('.'));
        
        for (const config of LANGUAGE_CONFIGS) {
          if (config.extensions.includes(extension)) {
            return config;
          }
        }
        
        return null;
      }


      /**
       * Get all supported file extensions
       */
      export function getSupportedExtensions(): string[] {
        return LANGUAGE_CONFIGS.flatMap(config => config.extensions);
      }
    patchStrategy: replace
  - type: write
    path: src/pipeline/analyze.ts
    content: >-
      --- src/pipeline/analyze.ts

      +++ src/pipeline/analyze.ts

      @@ -3,7 +3,7 @@
       import path from 'node:path';
       import { createParserForLanguage } from '../tree-sitter/languages.js';
       import { getLanguageConfigForFile, type LanguageConfig } from '../tree-sitter/language-config.js';
      -import type { Analyzer, CodeNode, CodeNodeType, CodeNodeVisibility,
      FileContent, CodeEdge } from '../types.js';

      +import type { Analyzer, CodeNode, CodeNodeType, CodeNodeVisibility,
      FileContent, CodeEdge, RepoGraphMap } from '../types.js';
       import type { Node as TSNode, QueryCapture as TSMatch } from 'web-tree-sitter';
       import { logger } from '../utils/logger.util.js';
       import { ParserError } from '../utils/error.util.js';
      @@ -536,25 +536,37 @@
           declarationNode = node.namedChildren[0] ?? node;
         }
         
      -  const nameNode = handler.getSymbolNameNode(declarationNode, node);

      +  // --- NEW LOGIC TO EXTRACT QUALIFIERS & UI identifiers ---

      +  const qualifiers: { [key: string]: TSNode } = {};

      +  for (const capture of childCaptures) {

      +    qualifiers[capture.name] = capture.node;

      +  }

      +

      +  const nameNode = handler.getSymbolNameNode(declarationNode, node) 

      +    || qualifiers['html.tag'] 

      +    || qualifiers['css.selector'];

      +
         if (!nameNode) return;
       
      -  const symbolName = nameNode.text;

      -  const symbolId = `${file.path}#${symbolName}`;

      +  let symbolName = nameNode.text;

      +  let symbolId = `${file.path}#${symbolName}`;

      +

      +  // HTML elements of the same type aren't unique, so we add a line
      number to the ID.

      +  if (symbolType === 'html_element') {

      +    symbolId = `${file.path}#${symbolName}:${nameNode.startPosition.row +
      1}`;

      +  }
       
         if (symbolName && !processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
           processedSymbols.add(symbolId);
       
      -    // --- NEW LOGIC TO EXTRACT QUALIFIERS ---

      -    const qualifiers: { [key: string]: TSNode } = {};

      -    for (const capture of childCaptures) {

      -      qualifiers[capture.name] = capture.node;

      -    }

      -
           const visibilityNode = qualifiers['qualifier.visibility'];
           const visibility = visibilityNode
             ? (getNodeText(visibilityNode, file.content) as CodeNodeVisibility)
             : undefined;
      +    

      +    const canThrow = childCaptures.some(c => c.name ===
      'qualifier.throws');

      +    const isHtmlElement = symbolType === 'html_element';

      +    const isCssRule = symbolType === 'css_rule';
       
           const parametersNode = qualifiers['symbol.parameters'];
           const parameters =
      @@ -572,6 +584,10 @@
             ...(visibility && { visibility }),
             ...(returnType && { returnType }),
             ...(parameters && { parameters }),
      +      ...(canThrow && { canThrow: true }),

      +      ...(isHtmlElement && { htmlTag: symbolName }),

      +      ...(isCssRule && { cssSelector: symbolName }),
           });
         }
       }
      @@ -628,6 +644,8 @@
           ['impl', 'impl'],
           ['constructor', 'constructor'],
           ['property', 'property'],
      +    ['html.element', 'html_element'],

      +    ['css.rule', 'css_rule'],
           ['variable', 'variable'],
           ['constant', 'constant'],
           ['static', 'static'],
    patchStrategy: new-unified
snapshot:
  src/types.ts: >-
    // Core Data Structures


    /** Represents a single file read from disk. Immutable. */

    export type FileContent = {
      readonly path: string;
      readonly content: string;
    };


    /** The type of a symbol identified in the code. */

    export type CodeNodeType =
      | 'file'
      | 'class'
      | 'function'
      | 'interface'
      | 'variable'
      | 'type'
      | 'arrow_function'
      | 'method'
      | 'field'
      | 'struct'
      | 'enum'
      | 'namespace'
      | 'trait'
      | 'impl'
      | 'constructor'
      | 'property'
      | 'constant'
      | 'static'
      | 'union'
      | 'template';

    /** New type for access modifiers. */

    export type CodeNodeVisibility = 'public' | 'private' | 'protected' |
    'internal' | 'default';


    /** Represents a single, identifiable symbol (or a file) in the code.
    Immutable. */

    export type CodeNode = {
      readonly id: string; // Unique identifier (e.g., 'src/api.ts#MyClass')
      readonly type: CodeNodeType;
      readonly name: string; // e.g., 'MyClass'
      readonly filePath: string;
      readonly startLine: number;
      readonly endLine: number;
      readonly language?: string; // For file nodes, the detected language
      readonly codeSnippet?: string; // e.g., function signature

      // --- NEW FIELDS from scn-ts report ---
      /** The access modifier of the symbol (e.g., public, private). Maps to SCN '+' or '-'. */
      readonly visibility?: CodeNodeVisibility;
      /** Whether the symbol (e.g., a function or method) is asynchronous. Maps to SCN '...'. */
      readonly isAsync?: boolean;
      /** Whether the symbol is a static member of a class/struct. */
      readonly isStatic?: boolean;
      /** The return type of a function/method, as a string. Maps to SCN '#(type)'. */
      readonly returnType?: string;
      /** An array of parameters for functions/methods. */
      readonly parameters?: { name: string; type?: string }[];
    };


    /** Represents a directed relationship between two CodeNodes. Immutable. */

    export type CodeEdge = {
      readonly fromId: string; // ID of the source CodeNode
      readonly toId: string;   // ID of the target CodeNode
      readonly type: 'imports' | 'calls' | 'inherits' | 'implements';
    };


    /** The complete, raw model of the repository's structure. Immutable. */

    export type CodeGraph = {
      readonly nodes: ReadonlyMap<string, CodeNode>;
      readonly edges: readonly CodeEdge[];
    };


    /** A CodeGraph with an added 'rank' score for each node. Immutable. */

    export type RankedCodeGraph = CodeGraph & {
      readonly ranks: ReadonlyMap<string, number>; // Key is CodeNode ID
    };


    /** The output of a map generation process, containing the graph and
    rendered output. */

    export type RepoGraphMap = {
      readonly graph: RankedCodeGraph;
      readonly markdown: string;
    };


    // High-Level API Options


    /** Configuration for the final Markdown output. */

    export type RendererOptions = {
      /** Custom text to appear at the top of the Markdown file. Overrides `includeHeader`. */
      readonly customHeader?: string;
      /** Include the default `RepoGraph` header. @default true */
      readonly includeHeader?: boolean;
      /** Include the project overview section. @default true */
      readonly includeOverview?: boolean;
      /** Include a Mermaid.js dependency graph. @default true */
      readonly includeMermaidGraph?: boolean;
      /** Include the list of top-ranked files. @default true */
      readonly includeFileList?: boolean;
      /** Number of files to show in the top list. @default 10 */
      readonly topFileCount?: number;
      /** Include detailed breakdowns for each symbol. @default true */
      readonly includeSymbolDetails?: boolean;
      /** String to use as a separator between file sections. @default '---' */
      readonly fileSectionSeparator?: string;

      /** Options for how individual symbols are rendered */
      readonly symbolDetailOptions?: {
        /** Include relationships (calls, inherits, etc.) in the symbol line. @default true */
        readonly includeRelations?: boolean;
        /** Include the starting line number. @default true */
        readonly includeLineNumber?: boolean;
        /** Include the code snippet for the symbol. @default true */
        readonly includeCodeSnippet?: boolean;
        /** Max number of relations to show per type (e.g., 'calls'). @default 3 */
        readonly maxRelationsToShow?: number;
      };
    };


    /** Configuration options for the main `generateMap` function. */

    export type RepoGraphOptions = {
      /** Root directory to analyze. @default process.cwd() */
      readonly root?: string;
      /** Output path for the Markdown file. @default './repograph.md' */
      readonly output?: string;
      /** Glob patterns for files to include. */
      readonly include?: readonly string[];
      /** Glob patterns for files to exclude. */
      readonly ignore?: readonly string[];
      /** Disables the use of .gitignore. @default false */
      readonly noGitignore?: boolean;
      /** The ranking strategy to use. @default 'pagerank' */
      readonly rankingStrategy?: 'pagerank' | 'git-changes';
      /** Configuration for the final Markdown output. */
      readonly rendererOptions?: RendererOptions;
      /** Logging level. @default 'info' */
      readonly logLevel?: 'silent' | 'error' | 'warn' | 'info' | 'debug';
    };


    // Low-Level Functional Pipeline Contracts


    /** Discovers files and returns their content. */

    export type FileDiscoverer = (config: {
      readonly root: string;
      readonly include?: readonly string[];
      readonly ignore?: readonly string[];
      readonly noGitignore?: boolean;
    }) => Promise<readonly FileContent[]>;


    /** Analyzes file content and builds the dependency graph. */

    export type Analyzer = (files: readonly FileContent[]) =>
    Promise<CodeGraph>;


    /** Ranks the nodes in a graph. */

    export type Ranker = (graph: CodeGraph) => Promise<RankedCodeGraph>;


    /** Renders a ranked graph into a string format. */

    export type Renderer = (rankedGraph: RankedCodeGraph, options?:
    RendererOptions) => string;
  package.json: |
    {
      "name": "repograph",
      "version": "0.1.2",
      "description": "Your Codebase, Visualized. Generate rich, semantic, and interactive codemaps with a functional, composable API.",
      "type": "module",
      "main": "./dist/index.js",
      "module": "./dist/index.js",
      "types": "./dist/index.d.ts",
      "bin": {
        "repograph": "./dist/index.js"
      },
      "exports": {
        ".": {
          "import": "./dist/index.js",
          "types": "./dist/index.d.ts"
        }
      },
      "files": [
        "dist"
      ],
      "scripts": {
        "clean": "rimraf dist",
        "build": "npm run clean && tsc -p tsconfig.build.json",
        "prepublishOnly": "npm run build",
        "dev": "tsc -w",
        "test": "bun run test/run-tests.ts",
        "test:unit": "bun run test/run-tests.ts unit",
        "test:integration": "bun run test/run-tests.ts integration",
        "test:e2e": "bun run test/run-tests.ts e2e",
        "test:watch": "bun test --watch test/**/*.test.ts",
        "test:coverage": "bun test --coverage test/**/*.test.ts",
        "test:basic": "bun test test-basic.js",
        "lint": "eslint . --ext .ts",
        "format": "prettier --write \"src/**/*.ts\""
      },
      "dependencies": {
        "@types/js-yaml": "^4.0.9",
        "globby": "^14.1.0",
        "graphology": "^0.26.0",
        "graphology-pagerank": "^1.1.0",
        "ignore": "^7.0.5",
        "js-yaml": "^4.1.0",
        "tree-sitter-c": "^0.24.1",
        "tree-sitter-c-sharp": "^0.23.1",
        "tree-sitter-cpp": "^0.23.4",
        "tree-sitter-go": "^0.23.4",
        "tree-sitter-java": "^0.23.5",
        "tree-sitter-php": "^0.23.12",
        "tree-sitter-python": "^0.23.6",
        "tree-sitter-ruby": "^0.23.1",
        "tree-sitter-rust": "^0.24.0",
        "tree-sitter-solidity": "^1.2.11",
        "tree-sitter-swift": "^0.7.1",
        "tree-sitter-typescript": "^0.23.2",
        "tree-sitter-vue": "^0.2.1",
        "web-tree-sitter": "^0.25.6"
      },
      "devDependencies": {
        "@types/node": "^20.12.12",
        "bun-types": "^1.1.12",
        "eslint": "^8.57.0",
        "prettier": "^3.2.5",
        "rimraf": "^5.0.7",
        "typescript": "^5.4.5"
      },
      "keywords": [
        "codemap",
        "graph",
        "visualization",
        "code-analysis",
        "tree-sitter",
        "repo-analysis",
        "ai-context",
        "bun",
        "functional-programming"
      ],
      "author": "RelayCoder <you@example.com>",
      "license": "MIT",
      "repository": {
        "type": "git",
        "url": "https://github.com/relaycoder/repograph.git"
      },
      "homepage": "https://github.com/relaycoder/repograph#readme",
      "bugs": {
        "url": "https://github.com/relaycoder/repograph/issues"
      },
      "engines": {
        "node": ">=18.0.0",
        "bun": ">=1.0.0"
      }
    }
  src/tree-sitter/language-config.ts: >
    import type { Language } from 'web-tree-sitter';


    export interface LanguageConfig {
      name: string;
      extensions: string[];
      wasmPath: string;
      query: string;
    }


    export interface LoadedLanguage {
      config: LanguageConfig;
      language: Language;
    }


    export const LANGUAGE_CONFIGS: LanguageConfig[] = [
      {
        name: 'typescript',
        extensions: ['.ts', '.js', '.mjs', '.cjs'],
        wasmPath: 'tree-sitter-typescript/tree-sitter-typescript.wasm',
        query: `
    (import_statement
      source: (string) @import.source) @import.statement

    (class_declaration) @class.definition

    (export_statement declaration: (class_declaration)) @class.definition


    (function_declaration
      ("async")? @qualifier.async
      parameters: (formal_parameters) @symbol.parameters
      return_type: (type_annotation)? @symbol.returnType
    ) @function.definition

    (export_statement
      declaration: (function_declaration
        ("async")? @qualifier.async
        parameters: (formal_parameters) @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.definition


    (variable_declarator
      value: (arrow_function
        ("async")? @qualifier.async
        parameters: (formal_parameters)? @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.arrow.definition

    (public_field_definition
      value: (arrow_function
        ("async")? @qualifier.async
        parameters: (formal_parameters)? @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.arrow.definition

    (export_statement
      declaration: (lexical_declaration
        (variable_declarator
          value: (arrow_function
            ("async")? @qualifier.async
            parameters: (formal_parameters)? @symbol.parameters
            return_type: (type_annotation)? @symbol.returnType
          )
        )
      )
    ) @function.arrow.definition


    (interface_declaration) @interface.definition

    (export_statement declaration: (interface_declaration))
    @interface.definition


    (type_alias_declaration) @type.definition

    (export_statement declaration: (type_alias_declaration)) @type.definition


    (enum_declaration) @enum.definition

    (export_statement declaration: (enum_declaration)) @enum.definition


    (method_definition
      (accessibility_modifier)? @qualifier.visibility
      ("static")? @qualifier.static
      ("async")? @qualifier.async
      parameters: (formal_parameters) @symbol.parameters
      return_type: (type_annotation)? @symbol.returnType
    ) @method.definition


    (public_field_definition
      (accessibility_modifier)? @qualifier.visibility
      ("static")? @qualifier.static
      type: (type_annotation)? @symbol.returnType
    ) @field.definition


    (variable_declarator) @variable.definition

    (export_statement declaration: (lexical_declaration (variable_declarator)))
    @variable.definition


    (call_expression
      function: (identifier) @function.call)

    ; Class inheritance and implementation patterns

    (extends_clause (identifier) @class.inheritance)

    (implements_clause (type_identifier) @class.implementation)

    `
      },
      {
        name: 'tsx',
        extensions: ['.tsx', '.jsx'],
        wasmPath: 'tree-sitter-typescript/tree-sitter-tsx.wasm',
        query: `
          (import_statement source: (string) @import.source) @import.statement
          (class_declaration) @class.definition
          (export_statement declaration: (class_declaration)) @class.definition
          
          (function_declaration
            ("async")? @qualifier.async
            parameters: (formal_parameters) @symbol.parameters
            return_type: (type_annotation)? @symbol.returnType
          ) @function.definition
          (export_statement
            declaration: (function_declaration
              ("async")? @qualifier.async
              parameters: (formal_parameters) @symbol.parameters
              return_type: (type_annotation)? @symbol.returnType
            )
          ) @function.definition

          (variable_declarator
            value: (arrow_function
              ("async")? @qualifier.async
              parameters: (formal_parameters)? @symbol.parameters
              return_type: (type_annotation)? @symbol.returnType
            )
          ) @function.arrow.definition
          (public_field_definition
            value: (arrow_function
              ("async")? @qualifier.async
              parameters: (formal_parameters)? @symbol.parameters
              return_type: (type_annotation)? @symbol.returnType
            )
          ) @function.arrow.definition

          (interface_declaration) @interface.definition
          (export_statement declaration: (interface_declaration)) @interface.definition
          (type_alias_declaration) @type.definition
          (export_statement declaration: (type_alias_declaration)) @type.definition
          (enum_declaration) @enum.definition
          (export_statement declaration: (enum_declaration)) @enum.definition

          (method_definition
            (accessibility_modifier)? @qualifier.visibility
            ("static")? @qualifier.static
            ("async")? @qualifier.async
            parameters: (formal_parameters) @symbol.parameters
            return_type: (type_annotation)? @symbol.returnType
          ) @method.definition

          (public_field_definition
            (accessibility_modifier)? @qualifier.visibility
            ("static")? @qualifier.static
            type: (type_annotation)? @symbol.returnType
          ) @field.definition
          
          ; Class inheritance and implementation patterns
          (extends_clause (identifier) @class.inheritance)
          (implements_clause (type_identifier) @class.implementation)
        `
      },
      {
        name: 'python',
        extensions: ['.py', '.pyw'],
        wasmPath: 'tree-sitter-python/tree-sitter-python.wasm',
        query: `
    (import_statement) @import.statement

    (import_from_statement
      module_name: (relative_import) @import.source) @import.statement
    (import_from_statement
      module_name: (dotted_name) @import.source) @import.statement

    (class_definition) @class.definition


    (function_definition) @function.definition


    (decorated_definition
      (function_definition)) @function.definition

    (decorated_definition
      (class_definition)) @class.definition

    (class_definition
      body: (block (function_definition) @method.definition))

    (expression_statement
      (assignment)) @variable.definition

    ; Python inheritance patterns

    (class_definition
      superclasses: (argument_list (identifier) @class.inheritance))
    `
      },
      {
        name: 'java',
        extensions: ['.java'],
        wasmPath: 'tree-sitter-java/tree-sitter-java.wasm',
        query: `
    (import_declaration
      (scoped_identifier) @import.source) @import.statement

    (class_declaration) @class.definition

    (interface_declaration) @interface.definition

    (enum_declaration) @enum.definition


    (method_declaration) @method.definition

    (constructor_declaration) @constructor.definition


    (field_declaration) @field.definition


    ; Java inheritance and implementation patterns

    (superclass (type_identifier) @class.inheritance)

    (super_interfaces (type_list (type_identifier) @class.implementation))


    `
      },
      {
        name: 'cpp',
        extensions: ['.cpp', '.cc', '.cxx', '.h', '.hpp', '.hh', '.hxx'],
        wasmPath: 'tree-sitter-cpp/tree-sitter-cpp.wasm',
        query: `
    (preproc_include) @import.statement


    (function_definition) @function.definition

    (declaration
      declarator: (function_declarator)) @function.declaration

    (class_specifier) @class.definition

    (struct_specifier) @struct.definition

    (union_specifier) @union.definition

    (enum_specifier) @enum.definition


    (namespace_definition) @namespace.definition


    (template_declaration) @template.definition


    (function_definition declarator: (qualified_identifier)) @method.definition

    (field_declaration declarator: (function_declarator)) @method.definition

    (field_declaration) @field.definition

    `
      },
      {
        name: 'c',
        extensions: ['.c'],
        wasmPath: 'tree-sitter-c/tree-sitter-c.wasm',
        query: `
    (preproc_include) @import.statement


    (function_definition) @function.definition

    (declaration declarator: (function_declarator)) @function.declaration

    (struct_specifier) @struct.definition

    (union_specifier) @union.definition

    (enum_specifier) @enum.definition

    (type_definition) @type.definition

    `
      },
      {
        name: 'go',
        extensions: ['.go'],
        wasmPath: 'tree-sitter-go/tree-sitter-go.wasm',
        query: `
    (import_declaration) @import.statement


    (function_declaration) @function.definition

    (method_declaration) @method.definition


    (type_declaration) @type.definition


    (var_declaration) @variable.definition

    (const_declaration) @constant.definition

    `
      },
      {
        name: 'rust',
        extensions: ['.rs'],
        wasmPath: 'tree-sitter-rust/tree-sitter-rust.wasm',
        query: `
    (mod_item
      name: (identifier) @import.source) @import.statement

    (function_item) @function.definition

    (impl_item) @impl.definition


    (struct_item) @struct.definition

    (enum_item) @enum.definition

    (trait_item) @trait.definition

    (function_signature_item) @method.definition


    (type_item) @type.definition

    (const_item) @constant.definition

    (static_item) @static.definition


    (function_signature_item) @function.declaration

    `
      },
      {
        name: 'csharp',
        extensions: ['.cs'],
        wasmPath: 'tree-sitter-c-sharp/tree-sitter-c_sharp.wasm',
        query: `
    (using_directive) @import.statement


    (class_declaration) @class.definition

    (interface_declaration) @interface.definition

    (struct_declaration) @struct.definition

    (enum_declaration) @enum.definition


    (method_declaration) @method.definition

    (constructor_declaration) @constructor.definition


    (field_declaration) @field.definition

    (property_declaration) @property.definition


    (namespace_declaration) @namespace.definition

    `
      },
      {
        name: 'php',
        extensions: ['.php'],
        wasmPath: 'tree-sitter-php/tree-sitter-php.wasm',
        query: `
          (namespace_definition) @namespace.definition
          (class_declaration) @class.definition
          (function_definition) @function.definition
          (method_declaration) @method.definition
        `
      },
      {
        name: 'ruby',
        extensions: ['.rb'],
        wasmPath: 'tree-sitter-ruby/tree-sitter-ruby.wasm',
        query: `
          (module) @module.definition
          (class) @class.definition
          (method) @method.definition
          (singleton_method) @method.definition
        `
      },
      {
        name: 'solidity',
        extensions: ['.sol'],
        wasmPath: 'tree-sitter-solidity/tree-sitter-solidity.wasm',
        query: `
          (contract_declaration) @class.definition
          (function_definition) @function.definition
          (event_definition) @enum.definition
        `
      },
      {
        name: 'swift',
        extensions: ['.swift'],
        wasmPath: 'tree-sitter-swift/tree-sitter-swift.wasm',
        query: `
          (class_declaration) @class.definition
          (protocol_declaration) @trait.definition
          (function_declaration) @function.definition
          (protocol_function_declaration) @function.definition
          (property_declaration) @field.definition
        `
      },
      {
        name: 'vue',
        extensions: ['.vue'],
        wasmPath: 'tree-sitter-vue/tree-sitter-vue.wasm',
        query: `
          (script_element .
            [
              (lexical_declaration (variable_declarator)) @variable.definition
              (function_declaration) @function.definition
            ])
    `
      }
    ];


    /**
     * Get the language configuration for a given file extension
     */
    export function getLanguageConfigForFile(filePath: string): LanguageConfig |
    null {
      const extension = filePath.substring(filePath.lastIndexOf('.'));
      
      for (const config of LANGUAGE_CONFIGS) {
        if (config.extensions.includes(extension)) {
          return config;
        }
      }
      
      return null;
    }


    /**
     * Get all supported file extensions
     */
    export function getSupportedExtensions(): string[] {
      return LANGUAGE_CONFIGS.flatMap(config => config.extensions);
    }
  src/pipeline/analyze.ts: >-
    import path from 'node:path';

    import { createParserForLanguage } from '../tree-sitter/languages.js';

    import { getLanguageConfigForFile, type LanguageConfig } from
    '../tree-sitter/language-config.js';

    import type { Analyzer, CodeNode, CodeNodeType, CodeNodeVisibility,
    FileContent, CodeEdge } from '../types.js';

    import type { Node as TSNode, QueryCapture as TSMatch } from
    'web-tree-sitter';

    import { logger } from '../utils/logger.util.js';

    import { ParserError } from '../utils/error.util.js';


    // --- UTILITY FUNCTIONS ---


    const getNodeText = (node: TSNode, content: string): string =>
    content.slice(node.startIndex, node.endIndex);

    const getLineFromIndex = (content: string, index: number): number =>
    content.substring(0, index).split('\n').length;

    const normalizePath = (p: string): string => p.replace(/\\/g, '/');


    // --- LANGUAGE-SPECIFIC LOGIC ---


    type LanguageHandler = {
      preProcessFile?: (file: FileContent, captures: TSMatch[]) => Record<string, any>;
      shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName: string) => boolean;
      getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) => TSNode | null;
      processComplexSymbol?: (context: ProcessSymbolContext) => boolean;
      parseParameters?: (paramsNode: TSNode, content: string) => { name: string; type?: string }[];
      resolveImport: (fromFile: string, importIdentifier: string, allFiles: string[]) => string | null;
    };


    type ProcessSymbolContext = {
      nodes: Map<string, CodeNode>;
      file: FileContent;
      node: TSNode;
      symbolType: CodeNodeType;
      processedSymbols: Set<string>;
      fileState: Record<string, any>;
    };


    const pythonHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'expression_statement') {
          const assignmentNode = declarationNode.namedChild(0);
          if (assignmentNode?.type === 'assignment') {
            return assignmentNode.childForFieldName('left');
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const goLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        const nodeType = declarationNode.type;
        if (['type_declaration', 'const_declaration', 'var_declaration'].includes(nodeType)) {
          const spec = declarationNode.namedChild(0);
          if (spec && ['type_spec', 'const_spec', 'var_spec'].includes(spec.type)) {
            return spec.childForFieldName('name');
          }
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const cLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'type_definition') {
          const lastChild = declarationNode.namedChild(declarationNode.namedChildCount - 1);
          if (lastChild?.type === 'type_identifier') return lastChild;
        }
        if (declarationNode.type === 'function_definition') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            const nameNode = declarator.childForFieldName('declarator');
            if (nameNode?.type === 'identifier') return nameNode;
          }
        }
        if (declarationNode.type === 'field_declaration') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            return declarator.childForFieldName('declarator');
          }
          return declarator;
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const tsLangHandler: Partial<LanguageHandler> = {
      preProcessFile: (_file, captures) => {
        const classNames = new Map<string, number>();
        const duplicateClassNames = new Set<string>();
        const seenClassNodes = new Set<number>();

        for (const { name, node } of captures) {
          if (name === 'class.definition') {
            let classNode = node.type === 'export_statement' ? (node.namedChildren[0] ?? node) : node;
            if (classNode.type === 'class_declaration' && !seenClassNodes.has(classNode.startIndex)) {
              seenClassNodes.add(classNode.startIndex);
              const nameNode = classNode.childForFieldName('name');
              if (nameNode) {
                const className = nameNode.text;
                const count = classNames.get(className) || 0;
                classNames.set(className, count + 1);
                if (count + 1 > 1) duplicateClassNames.add(className);
              }
            }
          }
        }
        return { duplicateClassNames };
      },
      shouldSkipSymbol: (node, symbolType, langName) => {
        if (langName !== 'typescript') return false;
        const valueNode = node.childForFieldName('value');
        if (valueNode?.type !== 'arrow_function') return false;
        return (symbolType === 'field' && node.type === 'public_field_definition') ||
          (symbolType === 'variable' && node.type === 'variable_declarator');
      },
      getSymbolNameNode: (declarationNode, originalNode) => {
        if (originalNode.type === 'variable_declarator' || originalNode.type === 'public_field_definition') { // Arrow function
          return originalNode.childForFieldName('name');
        }
        if (declarationNode.type === 'export_statement') {
          const lexicalDecl = declarationNode.namedChildren[0];
          if (lexicalDecl?.type === 'lexical_declaration') {
            const varDeclarator = lexicalDecl.namedChildren[0];
            if (varDeclarator?.type === 'variable_declarator') {
              return varDeclarator.childForFieldName('name');
            }
          }
        }
        return declarationNode.childForFieldName('name');
      },
      processComplexSymbol: ({ nodes, file, node, symbolType, processedSymbols, fileState }) => {
        if (symbolType !== 'method' && symbolType !== 'field') return false;
        const classParent = node.parent?.parent; // class_body -> class_declaration
        if (classParent?.type === 'class_declaration') {
          const classNameNode = classParent.childForFieldName('name');
          if (classNameNode) {
            const className = classNameNode.text;
            const nameNode = node.childForFieldName('name');
            // The check for duplicateClassNames is important to avoid ambiguity.
            // We remove the dependency on checking if the class has been processed first,
            // because the order of captures from tree-sitter is not guaranteed to be in source order.
            // This makes the analysis more robust.
            if (nameNode && !fileState['duplicateClassNames']?.has(className)) {
              const methodName = nameNode.text;
              const symbolName = `${className}.${methodName}`;
              const symbolId = `${file.path}#${symbolName}`;
              if (!processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
                processedSymbols.add(symbolId);
                nodes.set(symbolId, {
                  id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
                  startLine: getLineFromIndex(file.content, node.startIndex),
                  endLine: getLineFromIndex(file.content, node.endIndex),
                  codeSnippet: node.text?.split('{')[0]?.trim() || '',
                });
              }
            }
          }
        }
        return false;
      },
      parseParameters: (paramsNode: TSNode, content: string): { name: string; type?: string }[] => {
        const params: { name: string; type?: string }[] = [];
        // For TS, formal_parameters has required_parameter, optional_parameter children.
        for (const child of paramsNode.namedChildren) {
          if (child && (child.type === 'required_parameter' || child.type === 'optional_parameter')) {
            const nameNode = child.childForFieldName('pattern');
            const typeNode = child.childForFieldName('type');
            if (nameNode) {
              params.push({
                name: getNodeText(nameNode, content),
                type: typeNode ? getNodeText(typeNode, content).replace(/^:\s*/, '') : undefined,
              });
            }
          }
        }
        return params;
      },
    };


    const createModuleResolver = (extensions: string[]) => (fromFile: string,
    sourcePath: string, allFiles: string[]): string | null => {
      const basedir = normalizePath(path.dirname(fromFile));
      const importPath = normalizePath(path.join(basedir, sourcePath));

      // Case 1: Path needs an extension or has the wrong one (e.g., .js for .ts)
      const parsedPath = path.parse(importPath);
      const basePath = normalizePath(path.join(parsedPath.dir, parsedPath.name));
      for (const ext of extensions) {
          const potentialFile = basePath + ext;
          if (allFiles.includes(potentialFile)) {
              return potentialFile;
          }
      }
      
      // Case 2: Path is a directory with an index file
      for (const ext of extensions) {
          const potentialIndexFile = normalizePath(path.join(importPath, 'index' + ext));
          if (allFiles.includes(potentialIndexFile)) {
              return potentialIndexFile;
          }
      }

      if (allFiles.includes(importPath)) return importPath;

      return null;      
    };


    const resolveImportFactory = (endings: string[], packageStyle: boolean =
    false) => (fromFile: string, sourcePath: string, allFiles: string[]): string
    | null => {
      const basedir = normalizePath(path.dirname(fromFile));
      const resolvedPathAsIs = normalizePath(path.join(basedir, sourcePath));
      if (allFiles.includes(resolvedPathAsIs)) return resolvedPathAsIs;

      const parsedSourcePath = path.parse(sourcePath);
      const basePath = normalizePath(path.join(basedir, parsedSourcePath.dir, parsedSourcePath.name));
      for (const end of endings) {
        const potentialPath = basePath + end;
        if (allFiles.includes(potentialPath)) return potentialPath;
      }
      
      if (packageStyle && sourcePath.includes('.')) {
        const packagePath = normalizePath(sourcePath.replace(/\./g, '/'));
        for (const end of endings) {
          const fileFromRoot = packagePath + end;
          if (allFiles.includes(fileFromRoot)) return fileFromRoot;
        }
      }
      return null;
    };


    const phpHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'namespace_definition') {
          // For namespace definitions, get the namespace name node
          const nameNode = declarationNode.childForFieldName('name');
          return nameNode;
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const languageHandlers: Record<string, Partial<LanguageHandler>> = {
      default: {
        shouldSkipSymbol: () => false,
        getSymbolNameNode: (declarationNode) => declarationNode.childForFieldName('name'),
        resolveImport: (fromFile, sourcePath, allFiles) => {
          const resolvedPathAsIs = path.normalize(path.join(path.dirname(fromFile), sourcePath));
          return allFiles.includes(resolvedPathAsIs) ? resolvedPathAsIs : null;
        }
      },
      typescript: {
        ...tsLangHandler,
        resolveImport: createModuleResolver(['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs']),
      },
      javascript: {
        resolveImport: createModuleResolver(['.js', '.jsx', '.mjs', '.cjs']),
      },
      tsx: {
        ...tsLangHandler,
        resolveImport: createModuleResolver(['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs']),
      },
      python: { 
        ...pythonHandler, 
        resolveImport: (fromFile: string, sourcePath: string, allFiles: string[]): string | null => {
          const basedir = normalizePath(path.dirname(fromFile));

          // Handle relative imports (starting with .)
          if (sourcePath.startsWith('.')) {
            const dots = sourcePath.match(/^\.+/)?.[0] ?? '';
            const level = dots.length;
            const modulePath = sourcePath.substring(level).replace(/\./g, '/');

            let currentDir = basedir;
            for (let i = 1; i < level; i++) {
              currentDir = path.dirname(currentDir);
            }

            const targetPyFile = normalizePath(path.join(currentDir, modulePath) + '.py');
            if (allFiles.includes(targetPyFile)) return targetPyFile;
            
            const resolvedPath = normalizePath(path.join(currentDir, modulePath, '__init__.py'));
            if (allFiles.includes(resolvedPath)) return resolvedPath;
          }
          
          // Handle absolute imports
          return resolveImportFactory(['.py', '/__init__.py'])(fromFile, sourcePath, allFiles);
        }
      },
      java: { resolveImport: resolveImportFactory(['.java'], true) },
      csharp: { resolveImport: resolveImportFactory(['.cs'], true) },
      php: { ...phpHandler, resolveImport: resolveImportFactory(['.php']) },
      go: goLangHandler,
      rust: {
        ...goLangHandler,
        resolveImport: (fromFile: string, sourcePath: string, allFiles: string[]): string | null => {
          const basedir = normalizePath(path.dirname(fromFile));
          
          // Handle module paths like "utils" -> "utils.rs"
          const resolvedPath = normalizePath(path.join(basedir, sourcePath + '.rs'));
          if (allFiles.includes(resolvedPath)) return resolvedPath;
          
          // Handle mod.rs style imports
          return resolveImportFactory(['.rs', '/mod.rs'])(fromFile, sourcePath, allFiles);
        }
      },
      c: cLangHandler,
      cpp: cLangHandler,
    };


    const getLangHandler = (langName: string): LanguageHandler => ({
      ...languageHandlers['default'],
      ...languageHandlers[langName],
    } as LanguageHandler);



    /**
     * Creates the default Tree-sitter based analyzer. It parses files to find
     * symbols (nodes) and their relationships (edges), constructing a CodeGraph.
     * Supports multiple programming languages.
     * @returns An Analyzer function.
     */
    export const createTreeSitterAnalyzer = (): Analyzer => {
      return async (files: readonly FileContent[]) => {
        const nodes = new Map<string, CodeNode>();
        const edges: CodeEdge[] = [];
        const allFilePaths = files.map(f => normalizePath(f.path));

        // Phase 1: Add all files as nodes
        for (const file of files) {
          const langConfig = getLanguageConfigForFile(normalizePath(file.path));
          nodes.set(file.path, {
            id: file.path, type: 'file', name: path.basename(file.path),
            filePath: file.path, startLine: 1, endLine: file.content.split('\n').length,
            language: langConfig?.name,
          });
        }

        // Phase 2: Group files by language
        const filesByLanguage = files.reduce((acc, file) => {
          const langConfig = getLanguageConfigForFile(normalizePath(file.path));
          if (langConfig) {
            if (!acc.has(langConfig.name)) acc.set(langConfig.name, []);
            acc.get(langConfig.name)!.push(file);
          }
          return acc;
        }, new Map<string, FileContent[]>());

        // Phase 3: Parse all files once
        const fileParseData = new Map<string, { file: FileContent; captures: TSMatch[]; langConfig: LanguageConfig }>();
        for (const [langName, langFiles] of filesByLanguage.entries()) {
          const langConfig = getLanguageConfigForFile(normalizePath(langFiles[0]!.path));
          if (!langConfig) continue;
          try {
            const parser = await createParserForLanguage(langConfig);
            if (!parser.language) continue;
            const query = new (await import('web-tree-sitter')).Query(parser.language, langConfig.query);
            for (const file of langFiles) {
              const tree = parser.parse(file.content);
              if (tree) fileParseData.set(file.path, { file, captures: query.captures(tree.rootNode), langConfig });
            }
          } catch (error) {
            logger.warn(new ParserError(`Failed to process ${langName} files`, langName, error));
            // Continue processing other languages, don't let one language failure stop the entire analysis
            continue;
          }
        }

        // Phase 4: Process definitions for all files
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileDefinitions({ nodes }, { ...file, path: normalizePath(file.path) }, captures, langConfig);
        }
        
        // Phase 5: Process relationships for all files
        const resolver = new SymbolResolver(nodes, edges);
        for (const { file, captures, langConfig } of fileParseData.values()) {
          processFileRelationships({ nodes, edges }, { ...file, path: normalizePath(file.path) }, captures, langConfig, resolver, allFilePaths);
        }

        return { nodes: Object.freeze(nodes), edges: Object.freeze(edges) };
      };
    };


    /**
     * Process symbol definitions for a single file.
     */
    function processFileDefinitions(
      graph: { nodes: Map<string, CodeNode> },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig
    ): void {
      
      const handler = getLangHandler(langConfig.name);
      const fileState = handler.preProcessFile?.(file, captures) || {};
      const processedSymbols = new Set<string>();

      
      const definitionCaptures = captures.filter(({ name }) => name.endsWith('.definition'));
      const otherCaptures = captures.filter(({ name }) => !name.endsWith('.definition'));

      for (const { name, node } of definitionCaptures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const symbolType = getSymbolTypeFromCapture(name, type);
        if (!symbolType) continue;

        const childCaptures = otherCaptures.filter(
          (c) => c.node.startIndex >= node.startIndex && c.node.endIndex <= node.endIndex
        );

        processSymbol(
          { ...graph, file, node, symbolType, processedSymbols, fileState },
          langConfig
    ,
          childCaptures
        );
      }
    }


    /**
     * Process a single symbol definition.
     */
    function processSymbol(
      context: ProcessSymbolContext,
      langConfig: LanguageConfig,
      childCaptures: TSMatch[]
    ): void {
      const { nodes, file, node, symbolType, processedSymbols } = context;
      const handler = getLangHandler(langConfig.name);

      if (handler.shouldSkipSymbol(node, symbolType, langConfig.name)) return;
      if (handler.processComplexSymbol?.(context)) return;

      let declarationNode = node;
      if (node.type === 'export_statement' && node.namedChildCount > 0) {
        declarationNode = node.namedChildren[0] ?? node;
      }
      
      const nameNode = handler.getSymbolNameNode(declarationNode, node);
      if (!nameNode) return;

      const symbolName = nameNode.text;
      const symbolId = `${file.path}#${symbolName}`;

      if (symbolName && !processedSymbols.has(symbolId) && !nodes.has(symbolId)) {
        processedSymbols.add(symbolId);

        // --- NEW LOGIC TO EXTRACT QUALIFIERS ---
        const qualifiers: { [key: string]: TSNode } = {};
        for (const capture of childCaptures) {
          qualifiers[capture.name] = capture.node;
        }

        const visibilityNode = qualifiers['qualifier.visibility'];
        const visibility = visibilityNode
          ? (getNodeText(visibilityNode, file.content) as CodeNodeVisibility)
          : undefined;

        const parametersNode = qualifiers['symbol.parameters'];
        const parameters =
          parametersNode && handler.parseParameters
            ? handler.parseParameters(parametersNode, file.content)
            : undefined;

        const returnTypeNode = qualifiers['symbol.returnType'];
        const returnType = returnTypeNode ? getNodeText(returnTypeNode, file.content).replace(/^:\s*/, '') : undefined;

        nodes.set(symbolId, {
          id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
          startLine: getLineFromIndex(file.content, node.startIndex),
          endLine: getLineFromIndex(file.content, node.endIndex),
          codeSnippet: node.text?.split('{')[0]?.trim() || '',
          ...(qualifiers['qualifier.async'] && { isAsync: true }),
          ...(qualifiers['qualifier.static'] && { isStatic: true }),
          ...(visibility && { visibility }),
          ...(returnType && { returnType }),
          ...(parameters && { parameters }),
        });
      }
    }


    /**
     * Process relationships (imports, calls, inheritance) for a single file.
     */
    function processFileRelationships(
      graph: { nodes: Map<string, CodeNode>, edges: CodeEdge[] },
      file: FileContent,
      captures: TSMatch[],
      langConfig: LanguageConfig,
      resolver: SymbolResolver,
      allFilePaths: string[]
    ): void {
      const handler = getLangHandler(langConfig.name);
      for (const { name, node } of captures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const subtype = parts[parts.length - 1];

        if (type === 'import' && subtype === 'source') {
          const importIdentifier = getNodeText(node, file.content).replace(/['"`]/g, '');
          const importedFilePath = handler.resolveImport(file.path, importIdentifier, allFilePaths);
          if (importedFilePath && graph.nodes.has(importedFilePath)) {
            const edge: CodeEdge = { fromId: file.path, toId: importedFilePath, type: 'imports' };
            if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
              graph.edges.push(edge);
            }
          }
          continue;
        }

        if (subtype && ['inheritance', 'implementation', 'call'].includes(subtype)) {
          const fromId = findEnclosingSymbolId(node, file, graph.nodes);
          if (!fromId) continue;
          const toName = getNodeText(node, file.content).replace(/<.*>$/, '');
          const toNode = resolver.resolve(toName, file.path);
          if (!toNode) continue;
          
          const edgeType = subtype === 'inheritance' ? 'inherits' : subtype === 'implementation' ? 'implements' : 'calls';
          const edge: CodeEdge = { fromId, toId: toNode.id, type: edgeType };
          if (!graph.edges.some(e => e.fromId === edge.fromId && e.toId === edge.toId)) {
            graph.edges.push(edge);
          }
        }
      }
    }


    /**
     * Get symbol type from capture name and language.
     */
    function getSymbolTypeFromCapture(captureName: string, type: string):
    CodeNodeType | null {
      const baseMap = new Map<string, CodeNodeType>([
        ['class', 'class'],
        ['function', 'function'],
        ['function.arrow', 'arrow_function'],
        ['interface', 'interface'],
        ['type', 'type'],
        ['method', 'method'],
        ['field', 'field'],
        ['struct', 'struct'],
        ['enum', 'enum'],
        ['namespace', 'namespace'],
        ['trait', 'trait'],
        ['impl', 'impl'],
        ['constructor', 'constructor'],
        ['property', 'property'],
        ['variable', 'variable'],
        ['constant', 'constant'],
        ['static', 'static'],
        ['union', 'union'],
        ['template', 'template'],
      ]);
      return baseMap.get(captureName) ?? baseMap.get(type) ?? null;
    }


    /**
     * A best-effort symbol resolver to find the ID of a referenced symbol.
     */
    class SymbolResolver {
      constructor(
        private nodes: ReadonlyMap<string, CodeNode>,
        private edges: readonly CodeEdge[],
      ) {}

      resolve(symbolName: string, contextFile: string): CodeNode | null {
        const sameFileId = `${contextFile}#${symbolName}`;
        if (this.nodes.has(sameFileId)) return this.nodes.get(sameFileId)!;

        const importedFiles = this.edges.filter(e => e.fromId === contextFile && e.type === 'imports').map(e => e.toId);
        for (const file of importedFiles) {
          const importedId = `${file}#${symbolName}`;
          if (this.nodes.has(importedId)) return this.nodes.get(importedId)!;
        }

        for (const node of this.nodes.values()) {
          if (node.name === symbolName && ['class', 'function', 'interface', 'struct', 'type', 'enum'].includes(node.type)) {
            return node;
          }
        }
        return null;
      }
    }


    /**
     * Traverses up the AST from a start node to find the enclosing symbol definition
     * and returns its unique ID.
     */
    function findEnclosingSymbolId(startNode: TSNode, file: FileContent, nodes:
    ReadonlyMap<string, CodeNode>): string | null {
      let current: TSNode | null = startNode.parent;
      while (current) {
        const nameNode = current.childForFieldName('name');
        if (nameNode) {
          let symbolName = nameNode.text;
          if (current.type === 'method_definition' || (current.type === 'public_field_definition' && !current.text.includes('=>'))) {
            const classNode = current.parent?.parent; // class_body -> class_declaration
            if (classNode?.type === 'class_declaration') {
              symbolName = `${classNode.childForFieldName('name')?.text}.${symbolName}`;
            }
          }
          const symbolId = `${file.path}#${symbolName}`;
          if (nodes.has(symbolId)) return symbolId;
        }
        current = current.parent;
      }
      return file.path; // Fallback to file node
    }
approved: true
