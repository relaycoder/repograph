uuid: c22de63b-6e2b-4279-918d-ff543292ca9e
projectId: repograph
createdAt: '2025-07-24T14:05:06.744Z'
linesAdded: 521
linesRemoved: 580
gitCommitMsg: 'refactor: Radically DRY codebase across multiple modules'
promptSummary: >-
  The user requested a radical refactoring of the codebase to make it as DRY
  (Don't Repeat Yourself) as possible, without any feature regressions.
reasoning:
  - >-
    Here's my plan to make the codebase highly and radically DRY, as requested.
    I'll be focusing on eliminating repetition in logic, configuration, and
    control flow across the entire project.
  - >-
    1.  **Centralize Analysis Logic**: A large number of utility functions for
    parsing code are duplicated or mirrored between the main thread and the
    analysis worker. I will extract these into a single shared file,
    `src/pipeline/analyzer.util.ts`, which will be used by the worker.
  - >-
    2.  **Consolidate Language Configurations**: The Tree-sitter queries in
    `src/tree-sitter/language-config.ts` contain repeated patterns. I will
    create base query strings for related language families (like C/C++ and
    Java/C#) to build upon. I will also introduce a helper function to
    standardize the construction of WASM file paths, making the configuration
    more consistent and maintainable.
  - >-
    3.  **Unify Pipeline Orchestration**: The high-level `generateMap` function
    in `src/high-level.ts` re-implements parts of the pipeline orchestration
    found in `src/composer.ts`. I will refactor `generateMap` to use the
    `createMapGenerator` from the composer, making the composer the single
    source of truth for how the analysis pipeline is executed.
  - >-
    4.  **Declarative CLI Argument Parsing**: The command-line argument parser
    in `src/index.ts` uses a lengthy `switch` statement. I will refactor this to
    a more declarative, map-based approach, which is cleaner and easier to
    extend.
  - >-
    5.  **Fix WASM Path Inconsistency**: I noticed a small bug in
    `tsup.config.ts` where the C# WASM file was misnamed. I will correct this to
    ensure the build process works as expected.
  - >-
    These changes will significantly reduce redundancy and improve the overall
    structure and maintainability of the code.
  - '---'
  - >-
    First, I'll create a new utility file to house the shared logic for the code
    analyzer.
  - Next, I'll refactor the analyzer worker to use this new utility file.
  - >-
    I'll now update the language configurations to be more DRY and fix the
    inconsistent WASM paths.
  - Now, I will fix the C# WASM path in the `tsup` build configuration.
  - Next, I'll refactor the high-level API to remove redundant pipeline logic.
  - >-
    Finally, I will refactor the CLI argument parsing in `index.ts` to be more
    declarative and DRY.
  - >-
    I have completed the requested refactoring, focusing on making the codebase
    radically DRY and improving its overall structure.
operations:
  - type: write
    path: src/pipeline/analyzer.util.ts
    content: >-
      --- /dev/null

      +++ src/pipeline/analyzer.util.ts

      @@ -0,0 +1,385 @@

      +import type { Node as TSNode, QueryCapture as TSMatch } from
      'web-tree-sitter';

      +import type { LanguageConfig } from '../tree-sitter/language-config';

      +import type { CodeNode, CodeNodeType, CodeNodeVisibility, FileContent }
      from '../types';

      +

      +// --- UTILITY FUNCTIONS ---

      +

      +export const getNodeText = (node: TSNode, content: string): string =>
      content.slice(node.startIndex, node.endIndex);

      +export const getLineFromIndex = (content: string, index: number): number
      => content.substring(0, index).split('\n').length;

      +

      +export const extractCodeSnippet = (symbolType: CodeNodeType, node:
      TSNode): string => {

      +  const text = node.text;

      +  switch (symbolType) {

      +    case 'variable': case 'constant': case 'property': {

      +      const assignmentMatch = text.match(/=\s*(.+)$/s);

      +      return (assignmentMatch?.[1] ?? text).trim();

      +    }

      +    case 'field': {

      +      const colonIndex = text.indexOf(':');

      +      if (colonIndex !== -1) return text.substring(colonIndex).trim();

      +      const equalsIndex = text.indexOf('=');

      +      if (equalsIndex !== -1) return text.substring(equalsIndex).trim();

      +      return text.trim();

      +    }

      +    case 'function': case 'method': case 'constructor': {

      +      const bodyStart = text.indexOf('{');

      +      return (bodyStart > -1 ? text.slice(0, bodyStart) : text).trim();

      +    }

      +    case 'arrow_function': {

      +      const arrowIndex = text.indexOf('=>');

      +      return arrowIndex > -1 ? text.slice(0, arrowIndex).trim() :
      text.trim();

      +    }

      +    default: return text.trim();

      +  }

      +};

      +

      +export const extractQualifiers = (childCaptures: TSMatch[], fileContent:
      string, handler: Partial<LanguageHandler>) => {

      +  const qualifiers: { [key: string]: TSNode } = {};

      +  for (const capture of childCaptures) qualifiers[capture.name] =
      capture.node;

      +

      +  const visibility = (qualifiers['qualifier.visibility'] ?
      getNodeText(qualifiers['qualifier.visibility'], fileContent) : undefined)
      as CodeNodeVisibility | undefined;

      +  const returnType = qualifiers['symbol.returnType'] ?
      getNodeText(qualifiers['symbol.returnType'], fileContent).replace(/^:\s*/,
      '') : undefined;

      +  const parameters = qualifiers['symbol.parameters'] &&
      handler.parseParameters ?
      handler.parseParameters(qualifiers['symbol.parameters'], fileContent) :
      undefined;

      +  const canThrow = childCaptures.some(c => c.name ===
      'qualifier.throws');

      +

      +  return { qualifiers, visibility, returnType, parameters, canThrow,
      isAsync: !!qualifiers['qualifier.async'], isStatic:
      !!qualifiers['qualifier.static'] };

      +};

      +

      +export const getCssIntents = (ruleNode: TSNode, content: string):
      readonly ('layout' | 'typography' | 'appearance')[] => {

      +  const intents = new Set<'layout' | 'typography' | 'appearance'>();

      +  const layoutProps =
      /^(display|position|flex|grid|width|height|margin|padding|transform|align-|justify-)/;

      +  const typographyProps =
      /^(font|text-|line-height|letter-spacing|word-spacing)/;

      +  const appearanceProps =
      /^(background|border|box-shadow|opacity|color|fill|stroke|cursor)/;

      +  const block = ruleNode.childForFieldName('body') ??
      ruleNode.namedChildren.find(c => c && c.type === 'block');

      +

      +  if (block) {

      +    for (const declaration of block.namedChildren) {

      +      if (declaration && declaration.type === 'declaration') {

      +        const propNode = declaration.namedChildren.find(c => c && c.type
      === 'property_name');

      +        if (propNode) {

      +          const propName = getNodeText(propNode, content);

      +          if (layoutProps.test(propName)) intents.add('layout');

      +          if (typographyProps.test(propName)) intents.add('typography');

      +          if (appearanceProps.test(propName)) intents.add('appearance');

      +        }

      +      }

      +    }

      +  }

      +  return Array.from(intents).sort();

      +};

      +

      +// --- LANGUAGE-SPECIFIC LOGIC ---

      +

      +export type LanguageHandler = {

      +  preProcessFile?: (file: FileContent, captures: TSMatch[]) =>
      Record<string, any>;

      +  shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName:
      string) => boolean;

      +  getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) =>
      TSNode | null;

      +  processComplexSymbol?: (context: ProcessSymbolContext) => boolean;

      +  parseParameters?: (paramsNode: TSNode, content: string) => { name:
      string; type?: string }[];

      +};

      +

      +export type ProcessSymbolContext = {

      +  nodes: CodeNode[];

      +  file: FileContent;

      +  node: TSNode;

      +  symbolType: CodeNodeType;

      +  processedSymbols: Set<string>;

      +  fileState: Record<string, any>;

      +  childCaptures: TSMatch[];

      +};

      +

      +const pythonHandler: Partial<LanguageHandler> = {

      +  getSymbolNameNode: (declarationNode: TSNode) => {

      +    if (declarationNode.type === 'expression_statement') {

      +      const assignmentNode = declarationNode.namedChild(0);

      +      if (assignmentNode?.type === 'assignment') return
      assignmentNode.childForFieldName('left');

      +    }

      +    return declarationNode.childForFieldName('name');

      +  },

      +};

      +

      +const goLangHandler: Partial<LanguageHandler> = {

      +  getSymbolNameNode: (declarationNode: TSNode) => {

      +    const nodeType = declarationNode.type;

      +    if (['type_declaration', 'const_declaration',
      'var_declaration'].includes(nodeType)) {

      +      const spec = declarationNode.namedChild(0);

      +      if (spec && ['type_spec', 'const_spec',
      'var_spec'].includes(spec.type)) return spec.childForFieldName('name');

      +    }

      +    return declarationNode.childForFieldName('name');

      +  },

      +};

      +

      +const cLangHandler: Partial<LanguageHandler> = {

      +  getSymbolNameNode: (declarationNode: TSNode) => {

      +    if (declarationNode.type === 'type_definition') {

      +      const lastChild =
      declarationNode.namedChild(declarationNode.namedChildCount - 1);

      +      if (lastChild?.type === 'type_identifier') return lastChild;

      +    }

      +    if (declarationNode.type === 'function_definition') {

      +      const declarator = declarationNode.childForFieldName('declarator');

      +      if (declarator?.type === 'function_declarator') {

      +        const nameNode = declarator.childForFieldName('declarator');

      +        if (nameNode?.type === 'identifier') return nameNode;

      +      }

      +    }

      +    if (declarationNode.type === 'field_declaration') {

      +      const declarator = declarationNode.childForFieldName('declarator');

      +      if (declarator?.type === 'function_declarator') return
      declarator.childForFieldName('declarator');

      +      return declarator;

      +    }

      +    return declarationNode.childForFieldName('name');

      +  },

      +};

      +

      +const tsLangHandler: Partial<LanguageHandler> = {

      +  preProcessFile: (_file, captures) => {

      +    const classNames = new Map<string, number>(); const
      duplicateClassNames = new Set<string>(); const seenClassNodes = new
      Set<number>();

      +    for (const { name, node } of captures) {

      +      if (name === 'class.definition') {

      +        let classNode = node.type === 'export_statement' ?
      (node.namedChildren[0] ?? node) : node;

      +        if (classNode.type === 'class_declaration' &&
      !seenClassNodes.has(classNode.startIndex)) {

      +          seenClassNodes.add(classNode.startIndex);

      +          const nameNode = classNode.childForFieldName('name');

      +          if (nameNode) {

      +            const className = nameNode.text; const count =
      classNames.get(className) || 0;

      +            classNames.set(className, count + 1);

      +            if (count + 1 > 1) duplicateClassNames.add(className);

      +          }

      +        }

      +      }

      +    }

      +    return { duplicateClassNames };

      +  },

      +  shouldSkipSymbol: (node, symbolType, langName) => {

      +    if (langName !== 'typescript') return false;

      +    const valueNode = node.childForFieldName('value');

      +    if (valueNode?.type !== 'arrow_function') return false;

      +    return (symbolType === 'field' && node.type ===
      'public_field_definition') || (symbolType === 'variable' && node.type ===
      'variable_declarator');

      +  },

      +  getSymbolNameNode: (declarationNode, originalNode) => {

      +    if (originalNode.type === 'variable_declarator' || originalNode.type
      === 'public_field_definition') return
      originalNode.childForFieldName('name');

      +    if (declarationNode.type === 'export_statement') {

      +      const { firstNamedChild } = declarationNode;

      +      if (firstNamedChild?.type === 'arrow_function') {

      +        // For export default arrow functions, create a synthetic
      'default' name

      +        return null; // Will be handled by fallback logic below

      +      }

      +      // Handle `export default function() {}`

      +      if (firstNamedChild?.type === 'function_declaration' &&
      !firstNamedChild.childForFieldName('name')) {

      +        return null; // Will be handled by fallback logic below

      +      }

      +      const lexicalDecl = declarationNode.namedChildren[0];

      +      if (lexicalDecl?.type === 'lexical_declaration') {

      +        const varDeclarator = lexicalDecl.namedChildren[0];

      +        if (varDeclarator?.type === 'variable_declarator') return
      varDeclarator.childForFieldName('name');

      +      }

      +    }

      +    return declarationNode.childForFieldName('name');

      +  },

      +  processComplexSymbol: ({ nodes, file, node, symbolType,
      processedSymbols, fileState, childCaptures }) => {

      +    if (symbolType !== 'method' && symbolType !== 'field') return false;

      +    const classParent = node.parent?.parent;

      +    if (classParent?.type === 'class_declaration') {

      +      const classNameNode = classParent.childForFieldName('name');

      +      if (classNameNode) {

      +        const className = classNameNode.text;

      +        const nameNode = node.childForFieldName('name');

      +        if (nameNode &&
      !fileState['duplicateClassNames']?.has(className)) {

      +          const methodName = nameNode.text;

      +          const unqualifiedSymbolId = `${file.path}#${methodName}`;

      +          if (!processedSymbols.has(unqualifiedSymbolId) && !nodes.some(n
      => n.id === unqualifiedSymbolId)) {

      +            processedSymbols.add(unqualifiedSymbolId);

      +            const codeSnippet = extractCodeSnippet(symbolType, node);

      +            const q = extractQualifiers(childCaptures, file.content,
      tsLangHandler);

      +            nodes.push({

      +              id: unqualifiedSymbolId, type: symbolType, name:
      methodName, filePath: file.path,

      +              startLine: getLineFromIndex(file.content, node.startIndex),
      endLine: getLineFromIndex(file.content, node.endIndex),

      +              codeSnippet, ...(q.isAsync && { isAsync: true }),
      ...(q.isStatic && { isStatic: true }),

      +              ...(q.visibility && { visibility: q.visibility }),
      ...(q.returnType && { returnType: q.returnType }),

      +              ...(q.parameters && { parameters: q.parameters }),
      ...(q.canThrow && { canThrow: true }),

      +            });

      +          }

      +          processedSymbols.add(`${file.path}#${methodName}`);

      +        }

      +      }

      +    }

      +    return true;

      +  },

      +  parseParameters: (paramsNode: TSNode, content: string): { name: string;
      type?: string }[] => {

      +    const params: { name: string; type?: string }[] = [];

      +    // Handle object destructuring in props: `({ prop1, prop2 })`

      +    if (paramsNode.type === 'object_pattern') {

      +      for (const child of paramsNode.namedChildren) {

      +        if (child && (child.type === 'shorthand_property_identifier' ||
      child.type === 'property_identifier')) {

      +          params.push({ name: getNodeText(child, content), type: '#' });

      +        }

      +      }

      +      return params;

      +    }

      +

      +    for (const child of paramsNode.namedChildren) {

      +      if (child && (child.type === 'required_parameter' || child.type ===
      'optional_parameter')) {

      +        const nameNode = child.childForFieldName('pattern');

      +        const typeNode = child.childForFieldName('type');

      +        if (nameNode) params.push({ name: getNodeText(nameNode, content),
      type: typeNode ? getNodeText(typeNode, content).replace(/^:\s*/, '') :
      undefined });

      +      }

      +    }

      +    return params;

      +  },

      +};

      +

      +const phpHandler: Partial<LanguageHandler> = {

      +  getSymbolNameNode: (declarationNode: TSNode) => {

      +    if (declarationNode.type === 'namespace_definition') return
      declarationNode.childForFieldName('name');

      +    return declarationNode.childForFieldName('name');

      +  },

      +};

      +

      +const languageHandlers: Record<string, Partial<LanguageHandler>> = {

      +  default: { shouldSkipSymbol: () => false, getSymbolNameNode:
      (declarationNode) => declarationNode.childForFieldName('name') },

      +  typescript: tsLangHandler, tsx: tsLangHandler,

      +  python: pythonHandler, go: goLangHandler, rust: goLangHandler,

      +  c: cLangHandler, cpp: cLangHandler, php: phpHandler,

      +};

      +

      +export const getLangHandler = (langName: string): LanguageHandler => ({
      ...languageHandlers['default'], ...languageHandlers[langName] } as
      LanguageHandler);

      +

      +export function getSymbolTypeFromCapture(captureName: string, type:
      string): CodeNodeType | null {

      +  const baseMap = new Map<string, CodeNodeType>([

      +    ['class', 'class'], ['function', 'function'], ['function.arrow',
      'arrow_function'], ['interface', 'interface'],

      +    ['type', 'type'], ['method', 'method'], ['field', 'field'],
      ['struct', 'struct'], ['enum', 'enum'],

      +    ['namespace', 'namespace'], ['trait', 'trait'], ['impl', 'impl'],
      ['constructor', 'constructor'], ['property', 'property'],

      +    ['html.element', 'html_element'], ['css.rule', 'css_rule'],
      ['variable', 'variable'], ['constant', 'constant'],

      +    ['static', 'static'], ['union', 'union'], ['template', 'template'],

      +  ]);

      +  return baseMap.get(captureName) ?? baseMap.get(type) ?? null;

      +}

      +

      +export function findEnclosingSymbolId(startNode: TSNode, file:
      FileContent, nodes: readonly CodeNode[]): string | null {

      +  let current: TSNode | null = startNode.parent;

      +  while (current) {

      +    const nodeType = current.type;

      +    // Prioritize function-like parents for accurate call linking

      +    if (['function_declaration', 'method_definition', 'arrow_function',
      'function_definition'].includes(nodeType)) {

      +      const nameNode = current.childForFieldName('name');

      +      if (nameNode) {

      +        let symbolName = nameNode.text;

      +        // Handle class methods

      +        if (nodeType === 'method_definition') {

      +          const classNode = current.parent?.parent;

      +          if (classNode?.type === 'class_declaration') {

      +            const className = classNode.childForFieldName('name')?.text;

      +            if (className) symbolName = `${className}.${symbolName}`;

      +          }

      +        }

      +        const symbolId = `${file.path}#${symbolName}`;

      +        if (nodes.some(n => n.id === symbolId)) return symbolId;

      +      }

      +    }

      +    // Fallback for other symbol types

      +    if (current.type === 'jsx_opening_element') {

      +      const tagNameNode = current.childForFieldName('name');

      +      if (tagNameNode) {

      +        const tagName = tagNameNode.text, lineNumber =
      tagNameNode.startPosition.row + 1;

      +        const symbolId = `${file.path}#${tagName}:${lineNumber}`;

      +        if (nodes.some(n => n.id === symbolId)) return symbolId;

      +      }

      +    }

      +    const nameNode = current.childForFieldName('name');

      +    if (nameNode) {

      +      let symbolName = nameNode.text;

      +      if (current.type === 'method_definition' || (current.type ===
      'public_field_definition' && !current.text.includes('=>'))) {

      +        const classNode = current.parent?.parent;

      +        if (classNode?.type === 'class_declaration') symbolName =
      `${classNode.childForFieldName('name')?.text}.${symbolName}`;

      +      }

      +      const symbolId = `${file.path}#${symbolName}`;

      +      if (nodes.some(n => n.id === symbolId)) return symbolId;

      +    }

      +    current = current.parent;

      +  }

      +  return file.path;

      +}

      +

      +export function processSymbol(context: ProcessSymbolContext, langConfig:
      LanguageConfig): void {

      +  const { nodes, file, node, symbolType, processedSymbols, childCaptures
      } = context;

      +  const handler = getLangHandler(langConfig.name);

      +

      +  if (handler.shouldSkipSymbol(node, symbolType, langConfig.name))
      return;

      +  if (handler.processComplexSymbol?.(context)) return;

      +

      +  // Skip local variable declarations inside functions

      +  if (symbolType === 'variable') {

      +    let current = node.parent;

      +    while (current) {

      +      if (['function_declaration', 'arrow_function',
      'method_definition'].includes(current.type)) {

      +        return; // Skip this variable as it's inside a function

      +      }

      +      current = current.parent;

      +    }

      +  }

      +

      +  let declarationNode = node;

      +  if (node.type === 'export_statement' && node.namedChildCount > 0)
      declarationNode = node.namedChildren[0] ?? node;

      +

      +  const q = extractQualifiers(childCaptures, file.content, handler);

      +  let nameNode = handler.getSymbolNameNode(declarationNode, node) ||
      q.qualifiers['html.tag'] || q.qualifiers['css.selector'];

      +

      +  if (symbolType === 'css_rule' && !nameNode) {

      +    const selectorsNode = node.childForFieldName('selectors') ||
      node.namedChildren.find(c => c && c.type === 'selectors');

      +    if (selectorsNode) nameNode = selectorsNode.namedChildren[0] ??
      undefined;

      +  }

      +

      +  let symbolName: string;

      +  if (!nameNode) {

      +    // Handle export default anonymous functions

      +    if (node.type === 'export_statement') {

      +      const firstChild = node.firstNamedChild;

      +      if (firstChild?.type === 'arrow_function' ||

      +        (firstChild?.type === 'function_declaration' &&
      !firstChild.childForFieldName('name'))) {

      +        symbolName = 'default';

      +      } else {

      +        return;

      +      }

      +    } else {

      +      return;

      +    }

      +  } else {

      +    symbolName = nameNode.text;

      +  }

      +

      +  let symbolId = `${file.path}#${symbolName}`;

      +  if (symbolType === 'html_element' && nameNode) symbolId =
      `${file.path}#${symbolName}:${nameNode.startPosition.row + 1}`;

      +

      +  if (symbolName && !processedSymbols.has(symbolId) && !nodes.some(n =>
      n.id === symbolId)) {

      +    processedSymbols.add(symbolId);

      +    const isHtmlElement = symbolType === 'html_element', isCssRule =
      symbolType === 'css_rule';

      +    const cssIntents = isCssRule ? getCssIntents(node, file.content) :
      undefined;

      +    const codeSnippet = extractCodeSnippet(symbolType, node);

      +    nodes.push({

      +      id: symbolId, type: symbolType, name: symbolName, filePath:
      file.path,

      +      startLine: getLineFromIndex(file.content, node.startIndex),
      endLine: getLineFromIndex(file.content, node.endIndex),

      +      codeSnippet, ...(q.isAsync && { isAsync: true }), ...(q.isStatic &&
      { isStatic: true }),

      +      ...(q.visibility && { visibility: q.visibility }), ...(q.returnType
      && { returnType: q.returnType }),

      +      ...(q.parameters && { parameters: q.parameters }), ...(q.canThrow
      && { canThrow: true }),

      +      ...(isHtmlElement && { htmlTag: symbolName }), ...(isCssRule && {
      cssSelector: symbolName }),

      +      ...(cssIntents && { cssIntents }),

      +    });

      +  }

      +}
    patchStrategy: new-unified
  - type: write
    path: src/pipeline/analyzer.worker.ts
    content: >-
      --- src/pipeline/analyzer.worker.ts

      +++ src/pipeline/analyzer.worker.ts

      @@ -1,371 +1,15 @@

      -import type { Node as TSNode, QueryCapture as TSMatch } from
      'web-tree-sitter';
       import { createParserForLanguage } from '../tree-sitter/languages';
       import type { LanguageConfig } from '../tree-sitter/language-config';
      -import type { CodeNode, CodeNodeType, CodeNodeVisibility, FileContent,
      UnresolvedRelation } from '../types';

      -

      -// --- UTILITY FUNCTIONS (mirrored from original analyze.ts) ---

      -

      -const getNodeText = (node: TSNode, content: string): string =>
      content.slice(node.startIndex, node.endIndex);

      -const getLineFromIndex = (content: string, index: number): number =>
      content.substring(0, index).split('\n').length;

      -

      -const extractCodeSnippet = (symbolType: CodeNodeType, node: TSNode):
      string => {

      -  const text = node.text;

      -  switch (symbolType) {

      -    case 'variable': case 'constant': case 'property': {

      -      const assignmentMatch = text.match(/=\s*(.+)$/s);

      -      return (assignmentMatch?.[1] ?? text).trim();

      -    }

      -    case 'field': {

      -      const colonIndex = text.indexOf(':');

      -      if (colonIndex !== -1) return text.substring(colonIndex).trim();

      -      const equalsIndex = text.indexOf('=');

      -      if (equalsIndex !== -1) return text.substring(equalsIndex).trim();

      -      return text.trim();

      -    }

      -    case 'function': case 'method': case 'constructor': {

      -      const bodyStart = text.indexOf('{');

      -      return (bodyStart > -1 ? text.slice(0, bodyStart) : text).trim();

      -    }

      -    case 'arrow_function': {

      -      const arrowIndex = text.indexOf('=>');

      -      return arrowIndex > -1 ? text.slice(0, arrowIndex).trim() :
      text.trim();

      -    }

      -    default: return text.trim();

      -  }

      -};

      -

      -const extractQualifiers = (childCaptures: TSMatch[], fileContent: string,
      handler: Partial<LanguageHandler>) => {

      -  const qualifiers: { [key: string]: TSNode } = {};

      -  for (const capture of childCaptures) qualifiers[capture.name] =
      capture.node;

      -

      -  const visibility = (qualifiers['qualifier.visibility'] ?
      getNodeText(qualifiers['qualifier.visibility'], fileContent) : undefined)
      as CodeNodeVisibility | undefined;

      -  const returnType = qualifiers['symbol.returnType'] ?
      getNodeText(qualifiers['symbol.returnType'], fileContent).replace(/^:\s*/,
      '') : undefined;

      -  const parameters = qualifiers['symbol.parameters'] &&
      handler.parseParameters ?
      handler.parseParameters(qualifiers['symbol.parameters'], fileContent) :
      undefined;

      -  const canThrow = childCaptures.some(c => c.name ===
      'qualifier.throws');

      -

      -  return { qualifiers, visibility, returnType, parameters, canThrow,
      isAsync: !!qualifiers['qualifier.async'], isStatic:
      !!qualifiers['qualifier.static'] };

      -};

      -

      -const getCssIntents = (ruleNode: TSNode, content: string): readonly
      ('layout' | 'typography' | 'appearance')[] => {

      -  const intents = new Set<'layout' | 'typography' | 'appearance'>();

      -  const layoutProps =
      /^(display|position|flex|grid|width|height|margin|padding|transform|align-|justify-)/;

      -  const typographyProps =
      /^(font|text-|line-height|letter-spacing|word-spacing)/;

      -  const appearanceProps =
      /^(background|border|box-shadow|opacity|color|fill|stroke|cursor)/;

      -  const block = ruleNode.childForFieldName('body') ??
      ruleNode.namedChildren.find(c => c && c.type === 'block');

      -

      -  if (block) {

      -    for (const declaration of block.namedChildren) {

      -      if (declaration && declaration.type === 'declaration') {

      -        const propNode = declaration.namedChildren.find(c => c && c.type
      === 'property_name');

      -        if (propNode) {

      -          const propName = getNodeText(propNode, content);

      -          if (layoutProps.test(propName)) intents.add('layout');

      -          if (typographyProps.test(propName)) intents.add('typography');

      -          if (appearanceProps.test(propName)) intents.add('appearance');

      -        }

      -      }

      -    }

      -  }

      -  return Array.from(intents).sort();

      -};

      -

      -// --- LANGUAGE-SPECIFIC LOGIC ---

      -

      -type LanguageHandler = {

      -  preProcessFile?: (file: FileContent, captures: TSMatch[]) =>
      Record<string, any>;

      -  shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName:
      string) => boolean;

      -  getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) =>
      TSNode | null;

      -  processComplexSymbol?: (context: ProcessSymbolContext) => boolean;

      -  parseParameters?: (paramsNode: TSNode, content: string) => { name:
      string; type?: string }[];

      -};

      -

      -type ProcessSymbolContext = {

      -  nodes: CodeNode[];

      -  file: FileContent;

      -  node: TSNode;

      -  symbolType: CodeNodeType;

      -  processedSymbols: Set<string>;

      -  fileState: Record<string, any>;

      -  childCaptures: TSMatch[];

      -};

      -

      -const pythonHandler: Partial<LanguageHandler> = {

      -  getSymbolNameNode: (declarationNode: TSNode) => {

      -    if (declarationNode.type === 'expression_statement') {

      -      const assignmentNode = declarationNode.namedChild(0);

      -      if (assignmentNode?.type === 'assignment') return
      assignmentNode.childForFieldName('left');

      -    }

      -    return declarationNode.childForFieldName('name');

      -  },

      -};

      -

      -const goLangHandler: Partial<LanguageHandler> = {

      -  getSymbolNameNode: (declarationNode: TSNode) => {

      -    const nodeType = declarationNode.type;

      -    if (['type_declaration', 'const_declaration',
      'var_declaration'].includes(nodeType)) {

      -      const spec = declarationNode.namedChild(0);

      -      if (spec && ['type_spec', 'const_spec',
      'var_spec'].includes(spec.type)) return spec.childForFieldName('name');

      -    }

      -    return declarationNode.childForFieldName('name');

      -  },

      -};

      -

      -const cLangHandler: Partial<LanguageHandler> = {

      -  getSymbolNameNode: (declarationNode: TSNode) => {

      -    if (declarationNode.type === 'type_definition') {

      -      const lastChild =
      declarationNode.namedChild(declarationNode.namedChildCount - 1);

      -      if (lastChild?.type === 'type_identifier') return lastChild;

      -    }

      -    if (declarationNode.type === 'function_definition') {

      -      const declarator = declarationNode.childForFieldName('declarator');

      -      if (declarator?.type === 'function_declarator') {

      -        const nameNode = declarator.childForFieldName('declarator');

      -        if (nameNode?.type === 'identifier') return nameNode;

      -      }

      -    }

      -    if (declarationNode.type === 'field_declaration') {

      -      const declarator = declarationNode.childForFieldName('declarator');

      -      if (declarator?.type === 'function_declarator') return
      declarator.childForFieldName('declarator');

      -      return declarator;

      -    }

      -    return declarationNode.childForFieldName('name');

      -  },

      -};

      -

      -const tsLangHandler: Partial<LanguageHandler> = {

      -  preProcessFile: (_file, captures) => {

      -    const classNames = new Map<string, number>(); const
      duplicateClassNames = new Set<string>(); const seenClassNodes = new
      Set<number>();

      -    for (const { name, node } of captures) {

      -      if (name === 'class.definition') {

      -        let classNode = node.type === 'export_statement' ?
      (node.namedChildren[0] ?? node) : node;

      -        if (classNode.type === 'class_declaration' &&
      !seenClassNodes.has(classNode.startIndex)) {

      -          seenClassNodes.add(classNode.startIndex);

      -          const nameNode = classNode.childForFieldName('name');

      -          if (nameNode) {

      -            const className = nameNode.text; const count =
      classNames.get(className) || 0;

      -            classNames.set(className, count + 1);

      -            if (count + 1 > 1) duplicateClassNames.add(className);

      -          }

      -        }

      -      }

      -    }

      -    return { duplicateClassNames };

      -  },

      -  shouldSkipSymbol: (node, symbolType, langName) => {

      -    if (langName !== 'typescript') return false;

      -    const valueNode = node.childForFieldName('value');

      -    if (valueNode?.type !== 'arrow_function') return false;

      -    return (symbolType === 'field' && node.type ===
      'public_field_definition') || (symbolType === 'variable' && node.type ===
      'variable_declarator');

      -  },

      -  getSymbolNameNode: (declarationNode, originalNode) => {

      -    if (originalNode.type === 'variable_declarator' || originalNode.type
      === 'public_field_definition') return
      originalNode.childForFieldName('name');

      -    if (declarationNode.type === 'export_statement') {

      -      const { firstNamedChild } = declarationNode;

      -      if (firstNamedChild?.type === 'arrow_function') {

      -        // For export default arrow functions, create a synthetic
      'default' name

      -        return null; // Will be handled by fallback logic below

      -      }

      -      // Handle `export default function() {}`

      -      if (firstNamedChild?.type === 'function_declaration' &&
      !firstNamedChild.childForFieldName('name')) {

      -        return null; // Will be handled by fallback logic below

      -      }

      -      const lexicalDecl = declarationNode.namedChildren[0];

      -      if (lexicalDecl?.type === 'lexical_declaration') {

      -        const varDeclarator = lexicalDecl.namedChildren[0];

      -        if (varDeclarator?.type === 'variable_declarator') return
      varDeclarator.childForFieldName('name');

      -      }

      -    }

      -    return declarationNode.childForFieldName('name');

      -  },

      -  processComplexSymbol: ({ nodes, file, node, symbolType,
      processedSymbols, fileState, childCaptures }) => {

      -    if (symbolType !== 'method' && symbolType !== 'field') return false;

      -    const classParent = node.parent?.parent;

      -    if (classParent?.type === 'class_declaration') {

      -      const classNameNode = classParent.childForFieldName('name');

      -      if (classNameNode) {

      -        const className = classNameNode.text;

      -        const nameNode = node.childForFieldName('name');

      -        if (nameNode &&
      !fileState['duplicateClassNames']?.has(className)) {

      -          const methodName = nameNode.text;

      -          const unqualifiedSymbolId = `${file.path}#${methodName}`;

      -          if (!processedSymbols.has(unqualifiedSymbolId) && !nodes.some(n
      => n.id === unqualifiedSymbolId)) {

      -            processedSymbols.add(unqualifiedSymbolId);

      -            const codeSnippet = extractCodeSnippet(symbolType, node);

      -            const q = extractQualifiers(childCaptures, file.content,
      tsLangHandler);

      -            nodes.push({

      -              id: unqualifiedSymbolId, type: symbolType, name:
      methodName, filePath: file.path,

      -              startLine: getLineFromIndex(file.content, node.startIndex),
      endLine: getLineFromIndex(file.content, node.endIndex),

      -              codeSnippet, ...(q.isAsync && { isAsync: true }),
      ...(q.isStatic && { isStatic: true }),

      -              ...(q.visibility && { visibility: q.visibility }),
      ...(q.returnType && { returnType: q.returnType }),

      -              ...(q.parameters && { parameters: q.parameters }),
      ...(q.canThrow && { canThrow: true }),

      -            });

      -          }

      -          processedSymbols.add(`${file.path}#${methodName}`);

      -        }

      -      }

      -    }

      -    return true;

      -  },

      -  parseParameters: (paramsNode: TSNode, content: string): { name: string;
      type?: string }[] => {

      -    const params: { name: string; type?: string }[] = [];

      -    // Handle object destructuring in props: `({ prop1, prop2 })`

      -    if (paramsNode.type === 'object_pattern') {

      -      for (const child of paramsNode.namedChildren) {

      -        if (child && (child.type === 'shorthand_property_identifier' ||
      child.type === 'property_identifier')) {

      -          params.push({ name: getNodeText(child, content), type: '#' });

      -        }

      -      }

      -      return params;

      -    }

      -

      -    for (const child of paramsNode.namedChildren) {

      -      if (child && (child.type === 'required_parameter' || child.type ===
      'optional_parameter')) {

      -        const nameNode = child.childForFieldName('pattern');

      -        const typeNode = child.childForFieldName('type');

      -        if (nameNode) params.push({ name: getNodeText(nameNode, content),
      type: typeNode ? getNodeText(typeNode, content).replace(/^:\s*/, '') :
      undefined });

      -      }

      -    }

      -    return params;

      -  },

      -};

      -

      -const phpHandler: Partial<LanguageHandler> = {

      -  getSymbolNameNode: (declarationNode: TSNode) => {

      -    if (declarationNode.type === 'namespace_definition') return
      declarationNode.childForFieldName('name');

      -    return declarationNode.childForFieldName('name');

      -  },

      -};

      -

      -const languageHandlers: Record<string, Partial<LanguageHandler>> = {

      -  default: { shouldSkipSymbol: () => false, getSymbolNameNode:
      (declarationNode) => declarationNode.childForFieldName('name') },

      -  typescript: tsLangHandler, tsx: tsLangHandler,

      -  python: pythonHandler, go: goLangHandler, rust: goLangHandler,

      -  c: cLangHandler, cpp: cLangHandler, php: phpHandler,

      -};

      -

      -const getLangHandler = (langName: string): LanguageHandler => ({
      ...languageHandlers['default'], ...languageHandlers[langName] } as
      LanguageHandler);

      -

      -function getSymbolTypeFromCapture(captureName: string, type: string):
      CodeNodeType | null {

      -  const baseMap = new Map<string, CodeNodeType>([

      -    ['class', 'class'], ['function', 'function'], ['function.arrow',
      'arrow_function'], ['interface', 'interface'],

      -    ['type', 'type'], ['method', 'method'], ['field', 'field'],
      ['struct', 'struct'], ['enum', 'enum'],

      -    ['namespace', 'namespace'], ['trait', 'trait'], ['impl', 'impl'],
      ['constructor', 'constructor'], ['property', 'property'],

      -    ['html.element', 'html_element'], ['css.rule', 'css_rule'],
      ['variable', 'variable'], ['constant', 'constant'],

      -    ['static', 'static'], ['union', 'union'], ['template', 'template'],

      -  ]);

      -  return baseMap.get(captureName) ?? baseMap.get(type) ?? null;

      -}

      -

      -function findEnclosingSymbolId(startNode: TSNode, file: FileContent,
      nodes: readonly CodeNode[]): string | null {

      -  let current: TSNode | null = startNode.parent;

      -  while (current) {

      -    const nodeType = current.type;

      -    // Prioritize function-like parents for accurate call linking

      -    if (['function_declaration', 'method_definition', 'arrow_function',
      'function_definition'].includes(nodeType)) {

      -      const nameNode = current.childForFieldName('name');

      -      if (nameNode) {

      -        let symbolName = nameNode.text;

      -        // Handle class methods

      -        if (nodeType === 'method_definition') {

      -          const classNode = current.parent?.parent;

      -          if (classNode?.type === 'class_declaration') {

      -            const className = classNode.childForFieldName('name')?.text;

      -            if (className) symbolName = `${className}.${symbolName}`;

      -          }

      -        }

      -        const symbolId = `${file.path}#${symbolName}`;

      -        if (nodes.some(n => n.id === symbolId)) return symbolId;

      -      }

      -    }

      -    // Fallback for other symbol types

      -    if (current.type === 'jsx_opening_element') {

      -      const tagNameNode = current.childForFieldName('name');

      -      if (tagNameNode) {

      -        const tagName = tagNameNode.text, lineNumber =
      tagNameNode.startPosition.row + 1;

      -        const symbolId = `${file.path}#${tagName}:${lineNumber}`;

      -        if (nodes.some(n => n.id === symbolId)) return symbolId;

      -      }

      -    }

      -    const nameNode = current.childForFieldName('name');

      -    if (nameNode) {

      -      let symbolName = nameNode.text;

      -      if (current.type === 'method_definition' || (current.type ===
      'public_field_definition' && !current.text.includes('=>'))) {

      -        const classNode = current.parent?.parent;

      -        if (classNode?.type === 'class_declaration') symbolName =
      `${classNode.childForFieldName('name')?.text}.${symbolName}`;

      -      }

      -      const symbolId = `${file.path}#${symbolName}`;

      -      if (nodes.some(n => n.id === symbolId)) return symbolId;

      -    }

      -    current = current.parent;

      -  }

      -  return file.path;

      -}

      -

      -function processSymbol(context: ProcessSymbolContext, langConfig:
      LanguageConfig): void {

      -  const { nodes, file, node, symbolType, processedSymbols, childCaptures
      } = context;

      -  const handler = getLangHandler(langConfig.name);

      -

      -  if (handler.shouldSkipSymbol(node, symbolType, langConfig.name))
      return;

      -  if (handler.processComplexSymbol?.(context)) return;

      -

      -  // Skip local variable declarations inside functions

      -  if (symbolType === 'variable') {

      -    let current = node.parent;

      -    while (current) {

      -      if (['function_declaration', 'arrow_function',
      'method_definition'].includes(current.type)) {

      -        return; // Skip this variable as it's inside a function

      -      }

      -      current = current.parent;

      -    }

      -  }

      -

      -  let declarationNode = node;

      -  if (node.type === 'export_statement' && node.namedChildCount > 0)
      declarationNode = node.namedChildren[0] ?? node;

      -

      -  const q = extractQualifiers(childCaptures, file.content, handler);

      -  let nameNode = handler.getSymbolNameNode(declarationNode, node) ||
      q.qualifiers['html.tag'] || q.qualifiers['css.selector'];

      -

      -  if (symbolType === 'css_rule' && !nameNode) {

      -    const selectorsNode = node.childForFieldName('selectors') ||
      node.namedChildren.find(c => c && c.type === 'selectors');

      -    if (selectorsNode) nameNode = selectorsNode.namedChildren[0] ??
      undefined;

      -  }

      -

      -  let symbolName: string;

      -  if (!nameNode) {

      -    // Handle export default anonymous functions

      -    if (node.type === 'export_statement') {

      -      const firstChild = node.firstNamedChild;

      -      if (firstChild?.type === 'arrow_function' ||

      -        (firstChild?.type === 'function_declaration' &&
      !firstChild.childForFieldName('name'))) {

      -        symbolName = 'default';

      -      } else {

      -        return;

      -      }

      -    } else {

      -      return;

      -    }

      -  } else {

      -    symbolName = nameNode.text;

      -  }

      -

      -  let symbolId = `${file.path}#${symbolName}`;

      -  if (symbolType === 'html_element' && nameNode) symbolId =
      `${file.path}#${symbolName}:${nameNode.startPosition.row + 1}`;

      -

      -  if (symbolName && !processedSymbols.has(symbolId) && !nodes.some(n =>
      n.id === symbolId)) {

      -    processedSymbols.add(symbolId);

      -    const isHtmlElement = symbolType === 'html_element', isCssRule =
      symbolType === 'css_rule';

      -    const cssIntents = isCssRule ? getCssIntents(node, file.content) :
      undefined;

      -    const codeSnippet = extractCodeSnippet(symbolType, node);

      -    nodes.push({

      -      id: symbolId, type: symbolType, name: symbolName, filePath:
      file.path,

      -      startLine: getLineFromIndex(file.content, node.startIndex),
      endLine: getLineFromIndex(file.content, node.endIndex),

      -      codeSnippet, ...(q.isAsync && { isAsync: true }), ...(q.isStatic &&
      { isStatic: true }),

      -      ...(q.visibility && { visibility: q.visibility }), ...(q.returnType
      && { returnType: q.returnType }),

      -      ...(q.parameters && { parameters: q.parameters }), ...(q.canThrow
      && { canThrow: true }),

      -      ...(isHtmlElement && { htmlTag: symbolName }), ...(isCssRule && {
      cssSelector: symbolName }),

      -      ...(cssIntents && { cssIntents }),

      -    });

      -  }

      -}

      +import type { CodeNode, FileContent, UnresolvedRelation } from
      '../types';

      +import {

      +  findEnclosingSymbolId,

      +  getLangHandler,

      +  getNodeText,

      +  getSymbolTypeFromCapture,

      +  processSymbol,

      +} from './analyzer.util';
       
       // --- MAIN WORKER FUNCTION ---
    patchStrategy: new-unified
  - type: write
    path: src/tree-sitter/language-config.ts
    content: >-
      --- src/tree-sitter/language-config.ts

      +++ src/tree-sitter/language-config.ts

      @@ -1,4 +1,4 @@

      -import type { Language } from 'web-tree-sitter';

      +import type { Language as Language } from 'web-tree-sitter';
       
       export interface LanguageConfig {
         name: string;
      @@ -10,6 +10,14 @@
         config: LanguageConfig;
         language: Language;
       }
      +

      +/**

      + * Generates the expected path to a WASM file within its node_modules
      package.

      + * @param pkg The package name (e.g., 'tree-sitter-typescript')

      + * @param wasmFile The filename of the wasm file (e.g.,
      'tree-sitter-typescript.wasm')

      + * @returns The relative path to the wasm file.

      + */

      +const wasm = (pkg: string, wasmFile: string): string =>
      `${pkg}/${wasmFile}`;
       
       const TS_BASE_QUERY = `
       (import_statement
      @@ -131,23 +139,114 @@
         (#eq? @_p "id"))
       `;
       
      +const C_QUERY = `

      +(preproc_include) @import.statement

      +

      +(function_definition) @function.definition

      +(declaration declarator: (function_declarator)) @function.declaration

      +(struct_specifier) @struct.definition

      +(union_specifier) @union.definition

      +(enum_specifier) @enum.definition

      +(type_definition) @type.definition

      +`;

      +

      +const CPP_QUERY = `

      +${C_QUERY.replace('(type_definition) @type.definition\n', '')}

      +(class_specifier) @class.definition

      +(namespace_definition) @namespace.definition

      +(template_declaration) @template.definition

      +(function_definition declarator: (qualified_identifier))
      @method.definition

      +(field_declaration declarator: (function_declarator)) @method.definition

      +(field_declaration) @field.definition

      +(throw_expression) @qualifier.throws

      +`;

      +

      +const C_SHARP_FAMILY_BASE = `

      +(class_declaration) @class.definition

      +(interface_declaration) @interface.definition

      +(enum_declaration) @enum.definition

      +(method_declaration) @method.definition

      +(constructor_declaration) @constructor.definition

      +(field_declaration) @field.definition

      +(throw_statement) @qualifier.throws

      +`;

      +

      +const JAVA_QUERY = `

      +(import_declaration

      +  (scoped_identifier) @import.source) @import.statement

      +${C_SHARP_FAMILY_BASE.replace('(method_declaration) @method.definition',
      '(method_declaration (modifiers)? @qualifier.modifiers)
      @method.definition')}

      +(superclass (type_identifier) @class.inheritance)

      +(super_interfaces (type_list (type_identifier) @class.implementation))

      +`;

      +

      +const CSHARP_QUERY = `

      +(using_directive) @import.statement

      +${C_SHARP_FAMILY_BASE}

      +(struct_declaration) @struct.definition

      +(property_declaration) @property.definition

      +(namespace_declaration) @namespace.definition

      +`;

      +
       export const LANGUAGE_CONFIGS: LanguageConfig[] = [
         {
           name: 'typescript',
           extensions: ['.ts', '.js', '.mjs', '.cjs'],
      -    wasmPath: 'wasm/tree-sitter-typescript.wasm',

      +    wasmPath: wasm('tree-sitter-typescript',
      'tree-sitter-typescript.wasm'),
           query: TS_BASE_QUERY
         },
         {
           name: 'tsx',
           extensions: ['.tsx', '.jsx'],
      -    wasmPath: 'wasm/tree-sitter-tsx.wasm',

      +    wasmPath: wasm('tree-sitter-typescript', 'tree-sitter-tsx.wasm'),
           query: `${TS_BASE_QUERY}\n${TSX_SPECIFIC_QUERY}`
         },
         {
           name: 'python',
           extensions: ['.py', '.pyw'],
      -    wasmPath: 'wasm/tree-sitter-python.wasm',

      +    wasmPath: wasm('tree-sitter-python', 'tree-sitter-python.wasm'),
           query: `
       (import_statement) @import.statement
       (import_from_statement
      @@ -176,110 +275,56 @@
         {
           name: 'java',
           extensions: ['.java'],
      -    wasmPath: 'wasm/tree-sitter-java.wasm',

      -    query: `

      -(import_declaration

      -  (scoped_identifier) @import.source) @import.statement

      -

      -(class_declaration) @class.definition

      -(interface_declaration) @interface.definition

      -(enum_declaration) @enum.definition

      -

      -(method_declaration

      -  (modifiers)? @qualifier.modifiers

      -) @method.definition

      -

      -(constructor_declaration) @constructor.definition

      -

      -(field_declaration) @field.definition

      -

      -(throw_statement) @qualifier.throws

      -

      -; Java inheritance and implementation patterns

      -(superclass (type_identifier) @class.inheritance)

      -(super_interfaces (type_list (type_identifier) @class.implementation))

      -

      -`

      +    wasmPath: wasm('tree-sitter-java', 'tree-sitter-java.wasm'),

      +    query: JAVA_QUERY
         },
         {
           name: 'cpp',
           extensions: ['.cpp', '.cc', '.cxx', '.h', '.hpp', '.hh', '.hxx'],
      -    wasmPath: 'wasm/tree-sitter-cpp.wasm',

      -    query: `

      -(preproc_include) @import.statement

      -

      -(function_definition) @function.definition

      -(declaration

      -  declarator: (function_declarator)) @function.declaration

      -

      -(class_specifier) @class.definition

      -(struct_specifier) @struct.definition

      -(union_specifier) @union.definition

      -(enum_specifier) @enum.definition

      -

      -(namespace_definition) @namespace.definition

      -

      -(template_declaration) @template.definition

      -

      -(function_definition declarator: (qualified_identifier))
      @method.definition

      -(field_declaration declarator: (function_declarator)) @method.definition

      -(field_declaration) @field.definition

      -

      -(throw_expression) @qualifier.throws

      -`

      +    wasmPath: wasm('tree-sitter-cpp', 'tree-sitter-cpp.wasm'),

      +    query: CPP_QUERY
         },
         {
           name: 'c',
           extensions: ['.c'],
      -    wasmPath: 'wasm/tree-sitter-c.wasm',

      -    query: `

      -(preproc_include) @import.statement

      -

      -(function_definition) @function.definition

      -(declaration declarator: (function_declarator)) @function.declaration

      -(struct_specifier) @struct.definition

      -(union_specifier) @union.definition

      -(enum_specifier) @enum.definition

      -(type_definition) @type.definition

      -`

      +    wasmPath: wasm('tree-sitter-c', 'tree-sitter-c.wasm'),

      +    query: C_QUERY
         },
         {
           name: 'go',
           extensions: ['.go'],
      -    wasmPath: 'wasm/tree-sitter-go.wasm',

      +    wasmPath: wasm('tree-sitter-go', 'tree-sitter-go.wasm'),
           query: `
       (import_declaration) @import.statement
       
       (function_declaration) @function.definition
       (method_declaration) @method.definition
       
       (type_declaration) @type.definition
       
       (var_declaration) @variable.definition
       (const_declaration) @constant.definition
       `
         },
         {
           name: 'rust',
           extensions: ['.rs'],
      -    wasmPath: 'wasm/tree-sitter-rust.wasm',

      +    wasmPath: wasm('tree-sitter-rust', 'tree-sitter-rust.wasm'),
           query: `
       (mod_item
         name: (identifier) @import.source) @import.statement
       
       (function_item) @function.definition
       (impl_item) @impl.definition
       
       (struct_item) @struct.definition
       (enum_item) @enum.definition
       (trait_item) @trait.definition
       (function_signature_item) @method.definition
       
       (type_item) @type.definition
       (const_item) @constant.definition
       (static_item) @static.definition
       
       (function_signature_item) @function.declaration
       `
         },
         {
           name: 'csharp',
           extensions: ['.cs'],
      -    wasmPath: 'tree-sitter-c-sharp/tree-sitter-c_sharp.wasm',

      -    query: `

      -(using_directive) @import.statement

      -

      -(class_declaration) @class.definition

      -(interface_declaration) @interface.definition

      -(struct_declaration) @struct.definition

      -(enum_declaration) @enum.definition

      -

      -(method_declaration) @method.definition

      -(constructor_declaration) @constructor.definition

      -

      -(field_declaration) @field.definition

      -(property_declaration) @property.definition

      -

      -(namespace_declaration) @namespace.definition

      -

      -(throw_statement) @qualifier.throws

      -`

      +    wasmPath: wasm('tree-sitter-c-sharp', 'tree-sitter-c_sharp.wasm'),

      +    query: CSHARP_QUERY
         },
         {
           name: 'php',
           extensions: ['.php'],
      -    wasmPath: 'wasm/tree-sitter-php.wasm',

      +    wasmPath: wasm('tree-sitter-php', 'tree-sitter-php.wasm'),
           query: `
             (namespace_definition) @namespace.definition
             (class_declaration) @class.definition
      @@ -390,7 +335,7 @@
         {
           name: 'ruby',
           extensions: ['.rb'],
      -    wasmPath: 'wasm/tree-sitter-ruby.wasm',

      +    wasmPath: wasm('tree-sitter-ruby', 'tree-sitter-ruby.wasm'),
           query: `
             (module) @module.definition
             (class) @class.definition
      @@ -401,7 +346,7 @@
         {
           name: 'solidity',
           extensions: ['.sol'],
      -    wasmPath: 'tree-sitter-solidity/tree-sitter-solidity.wasm',

      +    wasmPath: wasm('tree-sitter-solidity', 'tree-sitter-solidity.wasm'),
           query: `
             (contract_declaration) @class.definition
             (function_definition) @function.definition
      @@ -411,7 +356,7 @@
         {
           name: 'swift',
           extensions: ['.swift'],
      -    wasmPath: 'tree-sitter-swift/tree-sitter-swift.wasm',

      +    wasmPath: wasm('tree-sitter-swift', 'tree-sitter-swift.wasm'),
           query: `
             (class_declaration) @class.definition
             (protocol_declaration) @trait.definition
      @@ -423,7 +368,7 @@
         {
           name: 'vue',
           extensions: ['.vue'],
      -    wasmPath: 'tree-sitter-vue/tree-sitter-vue.wasm',

      +    wasmPath: wasm('tree-sitter-vue', 'tree-sitter-vue.wasm'),
           query: `
             (script_element .
               [
      @@ -440,7 +385,7 @@
         {
           name: 'css',
           extensions: ['.css'],
      -    wasmPath: 'wasm/tree-sitter-css.wasm',

      +    wasmPath: wasm('tree-sitter-css', 'tree-sitter-css.wasm'),
           query: `
             (rule_set) @css.rule.definition
           `
    patchStrategy: new-unified
  - type: write
    path: tsup.config.ts
    content: |-
      <<<<<<< SEARCH
            'tree-sitter-c/tree-sitter-c.wasm',
            'tree-sitter-cpp/tree-sitter-cpp.wasm',
            'tree-sitter-c-sharp/tree-sitter-c-sharp.wasm',
            'tree-sitter-css/tree-sitter-css.wasm',
            'tree-sitter-go/tree-sitter-go.wasm',
      =======
            'tree-sitter-c/tree-sitter-c.wasm',
            'tree-sitter-cpp/tree-sitter-cpp.wasm',
            'tree-sitter-c-sharp/tree-sitter-c_sharp.wasm',
            'tree-sitter-css/tree-sitter-css.wasm',
            'tree-sitter-go/tree-sitter-go.wasm',
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/high-level.ts
    content: >-
      --- src/high-level.ts

      +++ src/high-level.ts

      @@ -1,11 +1,12 @@
       import { createDefaultDiscoverer } from './pipeline/discover';
       import { createTreeSitterAnalyzer } from './pipeline/analyze';
      -import { createPageRanker, createGitRanker } from './pipeline/rank';

      +import { createGitRanker, createPageRanker } from './pipeline/rank';
       import { createMarkdownRenderer } from './pipeline/render';
      -import type { RepoGraphOptions, Ranker, RankedCodeGraph, FileContent }
      from './types';

      +import type { FileContent, Ranker, RankedCodeGraph, RepoGraphOptions }
      from './types';
       import path from 'node:path';
       import { logger } from './utils/logger.util';
      -import { writeFile } from './utils/fs.util';
       import { RepoGraphError } from './utils/error.util';
      +import { createMapGenerator } from './composer';
       
       const selectRanker = (rankingStrategy: RepoGraphOptions['rankingStrategy'] = 'pagerank'): Ranker => {
         if (rankingStrategy === 'git-changes') {
      @@ -62,31 +63,28 @@
        * @param options The configuration object for generating the map.
        */
       export const generateMap = async (options: RepoGraphOptions = {}): Promise<void> => {
         const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
         if (isBrowser) {
           throw new RepoGraphError('`generateMap` is not supported in the browser because it cannot write to the file system. Use `analyzeProject` and a `Renderer` instead.');
         }
      -

      -  const finalOptions = { ...options, logLevel: options.logLevel ?? 'info'
      };

      -

      -  const {

      -    root = process.cwd(),

      -    output = './repograph.md',

      -  } = finalOptions;

      -

      -  try {

      -    // We get the full ranked graph first

      -    const rankedGraph = await analyzeProject(finalOptions);

      -

      -    logger.info('4/4 Rendering output...');

      -    const renderer = createMarkdownRenderer();

      -    const markdown = renderer(rankedGraph, finalOptions.rendererOptions);

      -    logger.debug('  -> Rendering complete.');

      -

      -    const outputPath = path.isAbsolute(output) ? output :
      path.resolve(root, output);

      -

      -    logger.info(`Writing report to ${path.relative(process.cwd(),
      outputPath)}...`);

      -    await writeFile(outputPath, markdown);

      -    logger.info('  -> Report saved.');

      -  } catch (error) {

      -    // The underlying `analyzeProject` already wraps the error, so we
      just re-throw.

      -    throw error;

      -  }

      +  

      +  // Set log level early

      +  logger.setLevel(options.logLevel ?? 'info');

      +  

      +  // This is the key: we compose the default pipeline

      +  const generator = createMapGenerator({

      +    discover: createDefaultDiscoverer(),

      +    analyze: createTreeSitterAnalyzer({ maxWorkers: options.maxWorkers
      }),

      +    rank: selectRanker(options.rankingStrategy),

      +    render: createMarkdownRenderer(),

      +  });

      +  

      +  // Then we run it with the remaining options, providing defaults

      +  await generator({

      +    root: options.root || process.cwd(),

      +    output: options.output || './repograph.md',

      +    include: options.include,

      +    ignore: options.ignore,

      +    noGitignore: options.noGitignore,

      +    rendererOptions: options.rendererOptions,

      +  });
       };
    patchStrategy: new-unified
  - type: write
    path: src/index.ts
    content: >-
      --- src/index.ts

      +++ src/index.ts

      @@ -107,93 +107,90 @@
             process.exit(0);
           }
       
      -    // We need a mutable version of the options to build it from
      arguments.

      -    const options: {

      -      root?: string;

      -      output?: string;

      -      include?: readonly string[];

      -      ignore?: readonly string[];

      -      noGitignore?: boolean;

      -      maxWorkers?: number;

      -      rankingStrategy?: 'pagerank' | 'git-changes';

      -      logLevel?: IRepoGraphOptions['logLevel'];

      -      rendererOptions?: IRepoGraphOptions['rendererOptions'];

      -    } = {};

      +    const options: any = {};
           const includePatterns: string[] = [];
           const ignorePatterns: string[] = [];
      -    // We need a mutable version of rendererOptions to build from CLI
      args

      -    const rendererOptions: {

      -      customHeader?: string;

      -      includeHeader?: boolean;

      -      includeOverview?: boolean;

      -      includeMermaidGraph?: boolean;

      -      includeFileList?: boolean;

      -      topFileCount?: number;

      -      includeSymbolDetails?: boolean;

      -      fileSectionSeparator?: string;

      -      symbolDetailOptions?: {

      -        includeRelations?: boolean;

      -        includeLineNumber?: boolean;

      -        includeCodeSnippet?: boolean;

      -        maxRelationsToShow?: number;

      -      };

      -    } = {};

      +    const rendererOptions: any = {};

      +    const symbolDetailOptions: any = {};

      +

      +    const argConfig: Record<string, (val?: string) => void> = {

      +      '--output': val => options.output = val,

      +      '--include': val => val && includePatterns.push(val),

      +      '--ignore': val => val && ignorePatterns.push(val),

      +      '--no-gitignore': () => options.noGitignore = true,

      +      '--ranking-strategy': val => options.rankingStrategy = val as any,

      +      '--max-workers': val => options.maxWorkers = parseInt(val!, 10),

      +      '--log-level': val => options.logLevel = val as any,

      +      '--no-header': () => rendererOptions.includeHeader = false,

      +      '--no-overview': () => rendererOptions.includeOverview = false,

      +      '--no-mermaid': () => rendererOptions.includeMermaidGraph = false,

      +      '--no-file-list': () => rendererOptions.includeFileList = false,

      +      '--no-symbol-details': () => rendererOptions.includeSymbolDetails =
      false,

      +      '--top-file-count': val => rendererOptions.topFileCount =
      parseInt(val!, 10),

      +      '--file-section-separator': val =>
      rendererOptions.fileSectionSeparator = val,

      +      '--no-symbol-relations': () => symbolDetailOptions.includeRelations
      = false,

      +      '--no-symbol-line-numbers': () =>
      symbolDetailOptions.includeLineNumber = false,

      +      '--no-symbol-snippets': () =>
      symbolDetailOptions.includeCodeSnippet = false,

      +      '--max-relations-to-show': val =>
      symbolDetailOptions.maxRelationsToShow = parseInt(val!, 10),

      +    };
       
           for (let i = 0; i < args.length; i++) {
             const arg = args[i];
      -      if (!arg) {

      -        continue;

      -      }

      -      switch (arg) {

      -        case '--output':

      -          options.output = args[++i];

      -          break;

      -        case '--include':

      -          includePatterns.push(args[++i] as string);

      -          break;

      -        case '--ignore':

      -          ignorePatterns.push(args[++i] as string);

      -          break;

      -        case '--no-gitignore':

      -          options.noGitignore = true;

      -          break;

      -        case '--ranking-strategy':

      -          options.rankingStrategy = args[++i] as
      IRepoGraphOptions['rankingStrategy'];

      -          break;

      -        case '--max-workers':

      -          options.maxWorkers = parseInt(args[++i] as string, 10);

      -          break;

      -        case '--log-level':

      -          options.logLevel = args[++i] as IRepoGraphOptions['logLevel'];

      -          break;

      -        // --- Renderer Options ---

      -        case '--no-header':

      -          rendererOptions.includeHeader = false;

      -          break;

      -        case '--no-overview':

      -          rendererOptions.includeOverview = false;

      -          break;

      -        case '--no-mermaid':

      -          rendererOptions.includeMermaidGraph = false;

      -          break;

      -        case '--no-file-list':

      -          rendererOptions.includeFileList = false;

      -          break;

      -        case '--no-symbol-details':

      -          rendererOptions.includeSymbolDetails = false;

      -          break;

      -        case '--top-file-count':

      -          rendererOptions.topFileCount = parseInt(args[++i] as string,
      10);

      -          break;

      -        case '--file-section-separator':

      -          rendererOptions.fileSectionSeparator = args[++i];

      -          break;

      -        case '--no-symbol-relations':

      -          rendererOptions.symbolDetailOptions = {
      ...(rendererOptions.symbolDetailOptions || {}), includeRelations: false };

      -          break;

      -        case '--no-symbol-line-numbers':

      -          rendererOptions.symbolDetailOptions = {
      ...(rendererOptions.symbolDetailOptions || {}), includeLineNumber: false
      };

      -          break;

      -        case '--no-symbol-snippets':

      -          rendererOptions.symbolDetailOptions = {
      ...(rendererOptions.symbolDetailOptions || {}), includeCodeSnippet: false
      };

      -          break;

      -        case '--max-relations-to-show':

      -          rendererOptions.symbolDetailOptions = {
      ...(rendererOptions.symbolDetailOptions || {}), maxRelationsToShow:
      parseInt(args[++i] as string, 10) };

      -          break;

      -        default:

      -          if (!arg.startsWith('-')) {

      -            options.root = arg;

      -          }

      -          break;

      +      if (!arg) continue;

      +

      +      const handler = argConfig[arg];

      +      if (handler) {

      +        // Check if handler takes a value

      +        if (handler.length === 1) {

      +          handler(args[++i]);

      +        } else {

      +          handler();

      +        }

      +      } else if (!arg.startsWith('-')) {

      +        options.root = arg;
             }
           }
       
           if (includePatterns.length > 0) {
             options.include = includePatterns;
           }
      +    
           if (ignorePatterns.length > 0) {
             options.ignore = ignorePatterns;
           }
      +    

      +    if (Object.keys(symbolDetailOptions).length > 0) {

      +      rendererOptions.symbolDetailOptions = symbolDetailOptions;

      +    }

      +    
           if (Object.keys(rendererOptions).length > 0) {
             options.rendererOptions = rendererOptions;
           }
       
           const finalOutput = path.resolve(options.root || process.cwd(), options.output || 'repograph.md');
       
           logger.info(`Starting RepoGraph analysis for "${path.resolve(options.root || process.cwd())}"...`);
       
           try {
      -      await executeGenerateMap(options);

      +      // Cast to the correct type for execution

      +      await executeGenerateMap(options as IRepoGraphOptions);
             const relativePath = path.relative(process.cwd(), finalOutput);
             logger.info(`\n✅ Success! RepoGraph map saved to ${relativePath}`);
           } catch (error: unknown) {
    patchStrategy: new-unified
snapshot:
  src/pipeline/analyzer.util.ts: null
  src/pipeline/analyzer.worker.ts: >
    import type { Node as TSNode, QueryCapture as TSMatch } from
    'web-tree-sitter';

    import { createParserForLanguage } from '../tree-sitter/languages';

    import type { LanguageConfig } from '../tree-sitter/language-config';

    import type { CodeNode, CodeNodeType, CodeNodeVisibility, FileContent,
    UnresolvedRelation } from '../types';


    // --- UTILITY FUNCTIONS (mirrored from original analyze.ts) ---


    const getNodeText = (node: TSNode, content: string): string =>
    content.slice(node.startIndex, node.endIndex);

    const getLineFromIndex = (content: string, index: number): number =>
    content.substring(0, index).split('\n').length;


    const extractCodeSnippet = (symbolType: CodeNodeType, node: TSNode): string
    => {
      const text = node.text;
      switch (symbolType) {
        case 'variable': case 'constant': case 'property': {
          const assignmentMatch = text.match(/=\s*(.+)$/s);
          return (assignmentMatch?.[1] ?? text).trim();
        }
        case 'field': {
          const colonIndex = text.indexOf(':');
          if (colonIndex !== -1) return text.substring(colonIndex).trim();
          const equalsIndex = text.indexOf('=');
          if (equalsIndex !== -1) return text.substring(equalsIndex).trim();
          return text.trim();
        }
        case 'function': case 'method': case 'constructor': {
          const bodyStart = text.indexOf('{');
          return (bodyStart > -1 ? text.slice(0, bodyStart) : text).trim();
        }
        case 'arrow_function': {
          const arrowIndex = text.indexOf('=>');
          return arrowIndex > -1 ? text.slice(0, arrowIndex).trim() : text.trim();
        }
        default: return text.trim();
      }
    };


    const extractQualifiers = (childCaptures: TSMatch[], fileContent: string,
    handler: Partial<LanguageHandler>) => {
      const qualifiers: { [key: string]: TSNode } = {};
      for (const capture of childCaptures) qualifiers[capture.name] = capture.node;

      const visibility = (qualifiers['qualifier.visibility'] ? getNodeText(qualifiers['qualifier.visibility'], fileContent) : undefined) as CodeNodeVisibility | undefined;
      const returnType = qualifiers['symbol.returnType'] ? getNodeText(qualifiers['symbol.returnType'], fileContent).replace(/^:\s*/, '') : undefined;
      const parameters = qualifiers['symbol.parameters'] && handler.parseParameters ? handler.parseParameters(qualifiers['symbol.parameters'], fileContent) : undefined;
      const canThrow = childCaptures.some(c => c.name === 'qualifier.throws');

      return { qualifiers, visibility, returnType, parameters, canThrow, isAsync: !!qualifiers['qualifier.async'], isStatic: !!qualifiers['qualifier.static'] };
    };


    const getCssIntents = (ruleNode: TSNode, content: string): readonly
    ('layout' | 'typography' | 'appearance')[] => {
      const intents = new Set<'layout' | 'typography' | 'appearance'>();
      const layoutProps = /^(display|position|flex|grid|width|height|margin|padding|transform|align-|justify-)/;
      const typographyProps = /^(font|text-|line-height|letter-spacing|word-spacing)/;
      const appearanceProps = /^(background|border|box-shadow|opacity|color|fill|stroke|cursor)/;
      const block = ruleNode.childForFieldName('body') ?? ruleNode.namedChildren.find(c => c && c.type === 'block');

      if (block) {
        for (const declaration of block.namedChildren) {
          if (declaration && declaration.type === 'declaration') {
            const propNode = declaration.namedChildren.find(c => c && c.type === 'property_name');
            if (propNode) {
              const propName = getNodeText(propNode, content);
              if (layoutProps.test(propName)) intents.add('layout');
              if (typographyProps.test(propName)) intents.add('typography');
              if (appearanceProps.test(propName)) intents.add('appearance');
            }
          }
        }
      }
      return Array.from(intents).sort();
    };


    // --- LANGUAGE-SPECIFIC LOGIC ---


    type LanguageHandler = {
      preProcessFile?: (file: FileContent, captures: TSMatch[]) => Record<string, any>;
      shouldSkipSymbol: (node: TSNode, symbolType: CodeNodeType, langName: string) => boolean;
      getSymbolNameNode: (declarationNode: TSNode, originalNode: TSNode) => TSNode | null;
      processComplexSymbol?: (context: ProcessSymbolContext) => boolean;
      parseParameters?: (paramsNode: TSNode, content: string) => { name: string; type?: string }[];
    };


    type ProcessSymbolContext = {
      nodes: CodeNode[];
      file: FileContent;
      node: TSNode;
      symbolType: CodeNodeType;
      processedSymbols: Set<string>;
      fileState: Record<string, any>;
      childCaptures: TSMatch[];
    };


    const pythonHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'expression_statement') {
          const assignmentNode = declarationNode.namedChild(0);
          if (assignmentNode?.type === 'assignment') return assignmentNode.childForFieldName('left');
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const goLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        const nodeType = declarationNode.type;
        if (['type_declaration', 'const_declaration', 'var_declaration'].includes(nodeType)) {
          const spec = declarationNode.namedChild(0);
          if (spec && ['type_spec', 'const_spec', 'var_spec'].includes(spec.type)) return spec.childForFieldName('name');
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const cLangHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'type_definition') {
          const lastChild = declarationNode.namedChild(declarationNode.namedChildCount - 1);
          if (lastChild?.type === 'type_identifier') return lastChild;
        }
        if (declarationNode.type === 'function_definition') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') {
            const nameNode = declarator.childForFieldName('declarator');
            if (nameNode?.type === 'identifier') return nameNode;
          }
        }
        if (declarationNode.type === 'field_declaration') {
          const declarator = declarationNode.childForFieldName('declarator');
          if (declarator?.type === 'function_declarator') return declarator.childForFieldName('declarator');
          return declarator;
        }
        return declarationNode.childForFieldName('name');
      },
    };


    const tsLangHandler: Partial<LanguageHandler> = {
      preProcessFile: (_file, captures) => {
        const classNames = new Map<string, number>(); const duplicateClassNames = new Set<string>(); const seenClassNodes = new Set<number>();
        for (const { name, node } of captures) {
          if (name === 'class.definition') {
            let classNode = node.type === 'export_statement' ? (node.namedChildren[0] ?? node) : node;
            if (classNode.type === 'class_declaration' && !seenClassNodes.has(classNode.startIndex)) {
              seenClassNodes.add(classNode.startIndex);
              const nameNode = classNode.childForFieldName('name');
              if (nameNode) {
                const className = nameNode.text; const count = classNames.get(className) || 0;
                classNames.set(className, count + 1);
                if (count + 1 > 1) duplicateClassNames.add(className);
              }
            }
          }
        }
        return { duplicateClassNames };
      },
      shouldSkipSymbol: (node, symbolType, langName) => {
        if (langName !== 'typescript') return false;
        const valueNode = node.childForFieldName('value');
        if (valueNode?.type !== 'arrow_function') return false;
        return (symbolType === 'field' && node.type === 'public_field_definition') || (symbolType === 'variable' && node.type === 'variable_declarator');
      },
      getSymbolNameNode: (declarationNode, originalNode) => {
        if (originalNode.type === 'variable_declarator' || originalNode.type === 'public_field_definition') return originalNode.childForFieldName('name');
        if (declarationNode.type === 'export_statement') {
          const { firstNamedChild } = declarationNode;
          if (firstNamedChild?.type === 'arrow_function') {
            // For export default arrow functions, create a synthetic 'default' name
            return null; // Will be handled by fallback logic below
          }
          // Handle `export default function() {}`
          if (firstNamedChild?.type === 'function_declaration' && !firstNamedChild.childForFieldName('name')) {
            return null; // Will be handled by fallback logic below
          }
          const lexicalDecl = declarationNode.namedChildren[0];
          if (lexicalDecl?.type === 'lexical_declaration') {
            const varDeclarator = lexicalDecl.namedChildren[0];
            if (varDeclarator?.type === 'variable_declarator') return varDeclarator.childForFieldName('name');
          }
        }
        return declarationNode.childForFieldName('name');
      },
      processComplexSymbol: ({ nodes, file, node, symbolType, processedSymbols, fileState, childCaptures }) => {
        if (symbolType !== 'method' && symbolType !== 'field') return false;
        const classParent = node.parent?.parent;
        if (classParent?.type === 'class_declaration') {
          const classNameNode = classParent.childForFieldName('name');
          if (classNameNode) {
            const className = classNameNode.text;
            const nameNode = node.childForFieldName('name');
            if (nameNode && !fileState['duplicateClassNames']?.has(className)) {
              const methodName = nameNode.text;
              const unqualifiedSymbolId = `${file.path}#${methodName}`;
              if (!processedSymbols.has(unqualifiedSymbolId) && !nodes.some(n => n.id === unqualifiedSymbolId)) {
                processedSymbols.add(unqualifiedSymbolId);
                const codeSnippet = extractCodeSnippet(symbolType, node);
                const q = extractQualifiers(childCaptures, file.content, tsLangHandler);
                nodes.push({
                  id: unqualifiedSymbolId, type: symbolType, name: methodName, filePath: file.path,
                  startLine: getLineFromIndex(file.content, node.startIndex), endLine: getLineFromIndex(file.content, node.endIndex),
                  codeSnippet, ...(q.isAsync && { isAsync: true }), ...(q.isStatic && { isStatic: true }),
                  ...(q.visibility && { visibility: q.visibility }), ...(q.returnType && { returnType: q.returnType }),
                  ...(q.parameters && { parameters: q.parameters }), ...(q.canThrow && { canThrow: true }),
                });
              }
              processedSymbols.add(`${file.path}#${methodName}`);
            }
          }
        }
        return true;
      },
      parseParameters: (paramsNode: TSNode, content: string): { name: string; type?: string }[] => {
        const params: { name: string; type?: string }[] = [];
        // Handle object destructuring in props: `({ prop1, prop2 })`
        if (paramsNode.type === 'object_pattern') {
          for (const child of paramsNode.namedChildren) {
            if (child && (child.type === 'shorthand_property_identifier' || child.type === 'property_identifier')) {
              params.push({ name: getNodeText(child, content), type: '#' });
            }
          }
          return params;
        }

        for (const child of paramsNode.namedChildren) {
          if (child && (child.type === 'required_parameter' || child.type === 'optional_parameter')) {
            const nameNode = child.childForFieldName('pattern');
            const typeNode = child.childForFieldName('type');
            if (nameNode) params.push({ name: getNodeText(nameNode, content), type: typeNode ? getNodeText(typeNode, content).replace(/^:\s*/, '') : undefined });
          }
        }
        return params;
      },
    };


    const phpHandler: Partial<LanguageHandler> = {
      getSymbolNameNode: (declarationNode: TSNode) => {
        if (declarationNode.type === 'namespace_definition') return declarationNode.childForFieldName('name');
        return declarationNode.childForFieldName('name');
      },
    };


    const languageHandlers: Record<string, Partial<LanguageHandler>> = {
      default: { shouldSkipSymbol: () => false, getSymbolNameNode: (declarationNode) => declarationNode.childForFieldName('name') },
      typescript: tsLangHandler, tsx: tsLangHandler,
      python: pythonHandler, go: goLangHandler, rust: goLangHandler,
      c: cLangHandler, cpp: cLangHandler, php: phpHandler,
    };


    const getLangHandler = (langName: string): LanguageHandler => ({
    ...languageHandlers['default'], ...languageHandlers[langName] } as
    LanguageHandler);


    function getSymbolTypeFromCapture(captureName: string, type: string):
    CodeNodeType | null {
      const baseMap = new Map<string, CodeNodeType>([
        ['class', 'class'], ['function', 'function'], ['function.arrow', 'arrow_function'], ['interface', 'interface'],
        ['type', 'type'], ['method', 'method'], ['field', 'field'], ['struct', 'struct'], ['enum', 'enum'],
        ['namespace', 'namespace'], ['trait', 'trait'], ['impl', 'impl'], ['constructor', 'constructor'], ['property', 'property'],
        ['html.element', 'html_element'], ['css.rule', 'css_rule'], ['variable', 'variable'], ['constant', 'constant'],
        ['static', 'static'], ['union', 'union'], ['template', 'template'],
      ]);
      return baseMap.get(captureName) ?? baseMap.get(type) ?? null;
    }


    function findEnclosingSymbolId(startNode: TSNode, file: FileContent, nodes:
    readonly CodeNode[]): string | null {
      let current: TSNode | null = startNode.parent;
      while (current) {
        const nodeType = current.type;
        // Prioritize function-like parents for accurate call linking
        if (['function_declaration', 'method_definition', 'arrow_function', 'function_definition'].includes(nodeType)) {
          const nameNode = current.childForFieldName('name');
          if (nameNode) {
            let symbolName = nameNode.text;
            // Handle class methods
            if (nodeType === 'method_definition') {
              const classNode = current.parent?.parent;
              if (classNode?.type === 'class_declaration') {
                const className = classNode.childForFieldName('name')?.text;
                if (className) symbolName = `${className}.${symbolName}`;
              }
            }
            const symbolId = `${file.path}#${symbolName}`;
            if (nodes.some(n => n.id === symbolId)) return symbolId;
          }
        }
        // Fallback for other symbol types
        if (current.type === 'jsx_opening_element') {
          const tagNameNode = current.childForFieldName('name');
          if (tagNameNode) {
            const tagName = tagNameNode.text, lineNumber = tagNameNode.startPosition.row + 1;
            const symbolId = `${file.path}#${tagName}:${lineNumber}`;
            if (nodes.some(n => n.id === symbolId)) return symbolId;
          }
        }
        const nameNode = current.childForFieldName('name');
        if (nameNode) {
          let symbolName = nameNode.text;
          if (current.type === 'method_definition' || (current.type === 'public_field_definition' && !current.text.includes('=>'))) {
            const classNode = current.parent?.parent;
            if (classNode?.type === 'class_declaration') symbolName = `${classNode.childForFieldName('name')?.text}.${symbolName}`;
          }
          const symbolId = `${file.path}#${symbolName}`;
          if (nodes.some(n => n.id === symbolId)) return symbolId;
        }
        current = current.parent;
      }
      return file.path;
    }


    function processSymbol(context: ProcessSymbolContext, langConfig:
    LanguageConfig): void {
      const { nodes, file, node, symbolType, processedSymbols, childCaptures } = context;
      const handler = getLangHandler(langConfig.name);

      if (handler.shouldSkipSymbol(node, symbolType, langConfig.name)) return;
      if (handler.processComplexSymbol?.(context)) return;

      // Skip local variable declarations inside functions
      if (symbolType === 'variable') {
        let current = node.parent;
        while (current) {
          if (['function_declaration', 'arrow_function', 'method_definition'].includes(current.type)) {
            return; // Skip this variable as it's inside a function
          }
          current = current.parent;
        }
      }

      let declarationNode = node;
      if (node.type === 'export_statement' && node.namedChildCount > 0) declarationNode = node.namedChildren[0] ?? node;

      const q = extractQualifiers(childCaptures, file.content, handler);
      let nameNode = handler.getSymbolNameNode(declarationNode, node) || q.qualifiers['html.tag'] || q.qualifiers['css.selector'];

      if (symbolType === 'css_rule' && !nameNode) {
        const selectorsNode = node.childForFieldName('selectors') || node.namedChildren.find(c => c && c.type === 'selectors');
        if (selectorsNode) nameNode = selectorsNode.namedChildren[0] ?? undefined;
      }

      let symbolName: string;
      if (!nameNode) {
        // Handle export default anonymous functions
        if (node.type === 'export_statement') {
          const firstChild = node.firstNamedChild;
          if (firstChild?.type === 'arrow_function' ||
            (firstChild?.type === 'function_declaration' && !firstChild.childForFieldName('name'))) {
            symbolName = 'default';
          } else {
            return;
          }
        } else {
          return;
        }
      } else {
        symbolName = nameNode.text;
      }

      let symbolId = `${file.path}#${symbolName}`;
      if (symbolType === 'html_element' && nameNode) symbolId = `${file.path}#${symbolName}:${nameNode.startPosition.row + 1}`;

      if (symbolName && !processedSymbols.has(symbolId) && !nodes.some(n => n.id === symbolId)) {
        processedSymbols.add(symbolId);
        const isHtmlElement = symbolType === 'html_element', isCssRule = symbolType === 'css_rule';
        const cssIntents = isCssRule ? getCssIntents(node, file.content) : undefined;
        const codeSnippet = extractCodeSnippet(symbolType, node);
        nodes.push({
          id: symbolId, type: symbolType, name: symbolName, filePath: file.path,
          startLine: getLineFromIndex(file.content, node.startIndex), endLine: getLineFromIndex(file.content, node.endIndex),
          codeSnippet, ...(q.isAsync && { isAsync: true }), ...(q.isStatic && { isStatic: true }),
          ...(q.visibility && { visibility: q.visibility }), ...(q.returnType && { returnType: q.returnType }),
          ...(q.parameters && { parameters: q.parameters }), ...(q.canThrow && { canThrow: true }),
          ...(isHtmlElement && { htmlTag: symbolName }), ...(isCssRule && { cssSelector: symbolName }),
          ...(cssIntents && { cssIntents }),
        });
      }
    }


    // --- MAIN WORKER FUNCTION ---


    export default async function processFile({ file, langConfig }: { file:
    FileContent; langConfig: LanguageConfig; }) {
      const nodes: CodeNode[] = [];
      const relations: UnresolvedRelation[] = [];
      const processedSymbols = new Set<string>();

      const parser = await createParserForLanguage(langConfig);
      if (!parser.language) return { nodes, relations };

      const query = new (await import('web-tree-sitter')).Query(parser.language, langConfig.query);
      const tree = parser.parse(file.content);
      if (!tree) return { nodes, relations };
      const captures = query.captures(tree.rootNode);

      // --- Phase 1: Definitions ---
      const handler = getLangHandler(langConfig.name);
      const fileState = handler.preProcessFile?.(file, captures) || {};
      const definitionCaptures = captures.filter(({ name }) => name.endsWith('.definition'));
      const otherCaptures = captures.filter(({ name }) => !name.endsWith('.definition'));

      for (const { name, node } of definitionCaptures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const symbolType = getSymbolTypeFromCapture(name, type);
        if (!symbolType) continue;

        const childCaptures = otherCaptures.filter((c) => c.node.startIndex >= node.startIndex && c.node.endIndex <= node.endIndex);
        processSymbol({ nodes, file, node, symbolType, processedSymbols, fileState, childCaptures }, langConfig);
      }

      // --- Phase 2: Relationships ---
      for (const { name, node } of captures) {
        const parts = name.split('.');
        const type = parts.slice(0, -1).join('.');
        const subtype = parts[parts.length - 1];

        if (type === 'import' && subtype === 'source') {
          const importPath = getNodeText(node, file.content).replace(/['"`]/g, '');
          relations.push({ fromId: file.path, toName: importPath, type: 'imports' });

          // Handle re-exports, e.g., `export * from './other';`
          const exportParent = node.parent?.parent;
          if (exportParent?.type === 'export_statement') {
            // This creates a file-level dependency, which is what SCN represents.
            // NOTE: The 'exports' relation type is not defined, causing a TS error.
            // A simple 'imports' relation is already created above, which is sufficient
            // for file-level dependency tracking. Deeper re-export symbol resolution
            // is not yet implemented.
            // relations.push({ fromId: file.path, toName: importPath, type: 'exports' });
          }
          continue;
        }

        if (name === 'css.class.reference' || name === 'css.id.reference') {
          const fromId = findEnclosingSymbolId(node, file, nodes);
          if (!fromId) continue;

          const fromNode = nodes.find(n => n.id === fromId);
          if (fromNode?.type !== 'html_element') continue;

          const text = getNodeText(node, file.content).replace(/['"`]/g, '');
          const prefix = name === 'css.id.reference' ? '#' : '.';
          const selectors = (prefix === '.') ? text.split(' ').filter(Boolean).map(s => '.' + s) : [prefix + text];

          for (const selector of selectors) relations.push({ fromId, toName: selector, type: 'reference' });
          continue;
        }

        if (subtype && ['inheritance', 'implementation', 'call', 'reference'].includes(subtype)) {
          const fromId = findEnclosingSymbolId(node, file, nodes);
          if (!fromId) continue;

          const toName = getNodeText(node, file.content).replace(/<.*>$/, '');
          const edgeType = subtype === 'inheritance' ? 'inherits' : subtype === 'implementation' ? 'implements' : 'reference';
          relations.push({ fromId, toName, type: edgeType });
        }
      }

      return { nodes, relations };
    }
  src/tree-sitter/language-config.ts: >-
    import type { Language } from 'web-tree-sitter';


    export interface LanguageConfig {
      name: string;
      extensions: string[];
      wasmPath: string;
      query: string;
    }


    export interface LoadedLanguage {
      config: LanguageConfig;
      language: Language;
    }


    const TS_BASE_QUERY = `

    (import_statement
      source: (string) @import.source) @import.statement

    (class_declaration) @class.definition

    (export_statement declaration: (class_declaration)) @class.definition


    (function_declaration
      ("async")? @qualifier.async
      parameters: (formal_parameters) @symbol.parameters
      return_type: (type_annotation)? @symbol.returnType
    ) @function.definition

    (export_statement
      declaration: (function_declaration
        ("async")? @qualifier.async
        parameters: (formal_parameters) @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.definition


    (variable_declarator
      value: (arrow_function
        ("async")? @qualifier.async
        parameters: (formal_parameters)? @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.arrow.definition

    (public_field_definition
      value: (arrow_function
        ("async")? @qualifier.async
        parameters: (formal_parameters)? @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.arrow.definition

    (export_statement
      declaration: (lexical_declaration
        (variable_declarator
          value: (arrow_function
            ("async")? @qualifier.async
            parameters: (formal_parameters)? @symbol.parameters
            return_type: (type_annotation)? @symbol.returnType
          )
        )
      )
    ) @function.arrow.definition


    ; Export default arrow function: export default () => {}

    (export_statement
      value: (arrow_function
        ("async")? @qualifier.async
        parameters: (formal_parameters)? @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.arrow.definition


    ; Alternative pattern for export default arrow function

    (export_statement
      (arrow_function
        ("async")? @qualifier.async
        parameters: (formal_parameters)? @symbol.parameters
        return_type: (type_annotation)? @symbol.returnType
      )
    ) @function.arrow.definition


    ; Export star statements: export * from './module'

    (export_statement
      source: (string) @import.source
    ) @import.statement


    (interface_declaration) @interface.definition

    (export_statement declaration: (interface_declaration))
    @interface.definition


    (type_alias_declaration) @type.definition

    (export_statement declaration: (type_alias_declaration)) @type.definition


    (enum_declaration) @enum.definition

    (export_statement declaration: (enum_declaration)) @enum.definition


    (internal_module) @namespace.definition

    (export_statement declaration: (internal_module)) @namespace.definition

    (ambient_declaration (module) @namespace.definition)


    (method_definition
      (accessibility_modifier)? @qualifier.visibility
      ("static")? @qualifier.static
      ("async")? @qualifier.async
      parameters: (formal_parameters) @symbol.parameters
      return_type: (type_annotation)? @symbol.returnType
    ) @method.definition


    (public_field_definition
      (accessibility_modifier)? @qualifier.visibility
      ("static")? @qualifier.static
      type: (type_annotation)? @symbol.returnType
    ) @field.definition


    (variable_declarator) @variable.definition

    (export_statement declaration: (lexical_declaration (variable_declarator)))
    @variable.definition


    (call_expression
      function: (identifier) @function.call)

    (call_expression
      function: (member_expression
        property: (property_identifier) @function.call))

    (identifier) @identifier.reference


    (throw_statement) @qualifier.throws


    ; Class inheritance and implementation patterns

    (extends_clause (identifier) @class.inheritance)

    (implements_clause (type_identifier) @class.implementation)

    `;


    const TSX_SPECIFIC_QUERY = `

    ; JSX/TSX specific

    (jsx_opening_element
      name: (_) @html.tag
    ) @html.element.definition


    ; className="..."

    (jsx_attribute
      (property_identifier) @_p
      (string) @css.class.reference
      (#eq? @_p "className"))

    ; id="..."

    (jsx_attribute
      (property_identifier) @_p
      (string) @css.id.reference
      (#eq? @_p "id"))
    `;


    export const LANGUAGE_CONFIGS: LanguageConfig[] = [
      {
        name: 'typescript',
        extensions: ['.ts', '.js', '.mjs', '.cjs'],
        wasmPath: 'wasm/tree-sitter-typescript.wasm',
        query: TS_BASE_QUERY
      },
      {
        name: 'tsx',
        extensions: ['.tsx', '.jsx'],
        wasmPath: 'wasm/tree-sitter-tsx.wasm',
        query: `${TS_BASE_QUERY}\n${TSX_SPECIFIC_QUERY}`
      },
      {
        name: 'python',
        extensions: ['.py', '.pyw'],
        wasmPath: 'wasm/tree-sitter-python.wasm',
        query: `
    (import_statement) @import.statement

    (import_from_statement
      module_name: (relative_import) @import.source) @import.statement
    (import_from_statement
      module_name: (dotted_name) @import.source) @import.statement

    (class_definition) @class.definition


    (function_definition) @function.definition


    (decorated_definition
      (function_definition)) @function.definition

    (decorated_definition
      (class_definition)) @class.definition

    (class_definition
      body: (block (function_definition) @method.definition))

    (expression_statement
      (assignment)) @variable.definition

    (raise_statement) @qualifier.throws


    ; Python inheritance patterns

    (class_definition
      superclasses: (argument_list (identifier) @class.inheritance))
    `
      },
      {
        name: 'java',
        extensions: ['.java'],
        wasmPath: 'wasm/tree-sitter-java.wasm',
        query: `
    (import_declaration
      (scoped_identifier) @import.source) @import.statement

    (class_declaration) @class.definition

    (interface_declaration) @interface.definition

    (enum_declaration) @enum.definition


    (method_declaration
      (modifiers)? @qualifier.modifiers
    ) @method.definition


    (constructor_declaration) @constructor.definition


    (field_declaration) @field.definition


    (throw_statement) @qualifier.throws


    ; Java inheritance and implementation patterns

    (superclass (type_identifier) @class.inheritance)

    (super_interfaces (type_list (type_identifier) @class.implementation))


    `
      },
      {
        name: 'cpp',
        extensions: ['.cpp', '.cc', '.cxx', '.h', '.hpp', '.hh', '.hxx'],
        wasmPath: 'wasm/tree-sitter-cpp.wasm',
        query: `
    (preproc_include) @import.statement


    (function_definition) @function.definition

    (declaration
      declarator: (function_declarator)) @function.declaration

    (class_specifier) @class.definition

    (struct_specifier) @struct.definition

    (union_specifier) @union.definition

    (enum_specifier) @enum.definition


    (namespace_definition) @namespace.definition


    (template_declaration) @template.definition


    (function_definition declarator: (qualified_identifier)) @method.definition

    (field_declaration declarator: (function_declarator)) @method.definition

    (field_declaration) @field.definition


    (throw_expression) @qualifier.throws

    `
      },
      {
        name: 'c',
        extensions: ['.c'],
        wasmPath: 'wasm/tree-sitter-c.wasm',
        query: `
    (preproc_include) @import.statement


    (function_definition) @function.definition

    (declaration declarator: (function_declarator)) @function.declaration

    (struct_specifier) @struct.definition

    (union_specifier) @union.definition

    (enum_specifier) @enum.definition

    (type_definition) @type.definition

    `
      },
      {
        name: 'go',
        extensions: ['.go'],
        wasmPath: 'wasm/tree-sitter-go.wasm',
        query: `
    (import_declaration) @import.statement


    (function_declaration) @function.definition

    (method_declaration) @method.definition


    (type_declaration) @type.definition


    (var_declaration) @variable.definition

    (const_declaration) @constant.definition

    `
      },
      {
        name: 'rust',
        extensions: ['.rs'],
        wasmPath: 'wasm/tree-sitter-rust.wasm',
        query: `
    (mod_item
      name: (identifier) @import.source) @import.statement

    (function_item) @function.definition

    (impl_item) @impl.definition


    (struct_item) @struct.definition

    (enum_item) @enum.definition

    (trait_item) @trait.definition

    (function_signature_item) @method.definition


    (type_item) @type.definition

    (const_item) @constant.definition

    (static_item) @static.definition


    (function_signature_item) @function.declaration

    `
      },
      {
        name: 'csharp',
        extensions: ['.cs'],
        wasmPath: 'tree-sitter-c-sharp/tree-sitter-c_sharp.wasm',
        query: `
    (using_directive) @import.statement


    (class_declaration) @class.definition

    (interface_declaration) @interface.definition

    (struct_declaration) @struct.definition

    (enum_declaration) @enum.definition


    (method_declaration) @method.definition

    (constructor_declaration) @constructor.definition


    (field_declaration) @field.definition

    (property_declaration) @property.definition


    (namespace_declaration) @namespace.definition


    (throw_statement) @qualifier.throws

    `
      },
      {
        name: 'php',
        extensions: ['.php'],
        wasmPath: 'wasm/tree-sitter-php.wasm',
        query: `
          (namespace_definition) @namespace.definition
          (class_declaration) @class.definition
          (function_definition) @function.definition
          (method_declaration) @method.definition
        `
      },
      {
        name: 'ruby',
        extensions: ['.rb'],
        wasmPath: 'wasm/tree-sitter-ruby.wasm',
        query: `
          (module) @module.definition
          (class) @class.definition
          (method) @method.definition
          (singleton_method) @method.definition
        `
      },
      {
        name: 'solidity',
        extensions: ['.sol'],
        wasmPath: 'tree-sitter-solidity/tree-sitter-solidity.wasm',
        query: `
          (contract_declaration) @class.definition
          (function_definition) @function.definition
          (event_definition) @enum.definition
        `
      },
      {
        name: 'swift',
        extensions: ['.swift'],
        wasmPath: 'tree-sitter-swift/tree-sitter-swift.wasm',
        query: `
          (class_declaration) @class.definition
          (protocol_declaration) @trait.definition
          (function_declaration) @function.definition
          (protocol_function_declaration) @function.definition
          (property_declaration) @field.definition
        `
      },
      {
        name: 'vue',
        extensions: ['.vue'],
        wasmPath: 'tree-sitter-vue/tree-sitter-vue.wasm',
        query: `
          (script_element .
            [
              (lexical_declaration (variable_declarator)) @variable.definition
              (function_declaration) @function.definition
            ])

          (element
            (start_tag
              (tag_name) @html.tag
            )
          ) @html.element.definition
    `
      },
      {
        name: 'css',
        extensions: ['.css'],
        wasmPath: 'wasm/tree-sitter-css.wasm',
        query: `
          (rule_set) @css.rule.definition
        `
      }
    ];


    /**
     * Get the language configuration for a given file extension
     */
    export function getLanguageConfigForFile(filePath: string): LanguageConfig |
    null {
      const extension = filePath.substring(filePath.lastIndexOf('.'));
      
      for (const config of LANGUAGE_CONFIGS) {
        if (config.extensions.includes(extension)) {
          return config;
        }
      }
      
      return null;
    }


    /**
     * Get all supported file extensions
     */
    export function getSupportedExtensions(): string[] {
      return LANGUAGE_CONFIGS.flatMap(config => config.extensions);
    }
  src/high-level.ts: >-
    import { createDefaultDiscoverer } from './pipeline/discover';

    import { createTreeSitterAnalyzer } from './pipeline/analyze';

    import { createPageRanker, createGitRanker } from './pipeline/rank';

    import { createMarkdownRenderer } from './pipeline/render';

    import type { RepoGraphOptions, Ranker, RankedCodeGraph, FileContent } from
    './types';

    import path from 'node:path';

    import { logger } from './utils/logger.util';

    import { writeFile } from './utils/fs.util';

    import { RepoGraphError } from './utils/error.util';


    const selectRanker = (rankingStrategy: RepoGraphOptions['rankingStrategy'] =
    'pagerank'): Ranker => {
      if (rankingStrategy === 'git-changes') {
        return createGitRanker();
      }
      if (rankingStrategy === 'pagerank') {
        return createPageRanker();
      }
      throw new Error(`Invalid ranking strategy: '${rankingStrategy}'. Available options are 'pagerank', 'git-changes'.`);
    };


    /**
     * A mid-level API for programmatically generating and receiving the code graph
     * without rendering it to a file. Ideal for integration with other tools.
     *
     * @param options The configuration object for generating the map.
     * @returns The generated `RankedCodeGraph`.
     */
    export const analyzeProject = async (options: RepoGraphOptions = {}):
    Promise<RankedCodeGraph> => {
      const { root, logLevel, include, ignore, noGitignore, maxWorkers, files: inputFiles } = options;
      const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';

      if (logLevel) {
        logger.setLevel(logLevel);
      }

      // Validate options before entering the main try...catch block to provide clear errors.
      const ranker = selectRanker(options.rankingStrategy);

      try {
        let files: readonly FileContent[];
        if (inputFiles && inputFiles.length > 0) {
          logger.info('1/3 Using provided files...');
          files = inputFiles;
        } else {
          if (isBrowser) {
            throw new RepoGraphError('File discovery is not supported in the browser. Please provide the `files` option with file content.');
          }
          const effectiveRoot = root || process.cwd();
          logger.info(`1/3 Discovering files in "${effectiveRoot}"...`);
          const discoverer = createDefaultDiscoverer();
          files = await discoverer({ root: path.resolve(effectiveRoot), include, ignore, noGitignore });
        }
        logger.debug(`  -> Found ${files.length} files to analyze.`);

        logger.info('2/3 Analyzing code and building graph...');
        const analyzer = createTreeSitterAnalyzer({ maxWorkers });
        const graph = await analyzer(files);
        logger.debug(`  -> Built graph with ${graph.nodes.size} nodes and ${graph.edges.length} edges.`);

        logger.info('3/3 Ranking graph nodes...');
        const rankedGraph = await ranker(graph);
        logger.debug('  -> Ranking complete.');

        return rankedGraph;
      } catch (error) {
        throw new RepoGraphError(`Failed to analyze project`, error);
      }
    };


    /**
     * The primary, easy-to-use entry point for RepoGraph. It orchestrates the
     * default pipeline based on a configuration object to generate a codemap.
     *
     * @param options The configuration object for generating the map.
     */
    export const generateMap = async (options: RepoGraphOptions = {}):
    Promise<void> => {
      const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
      if (isBrowser) {
        throw new RepoGraphError('`generateMap` is not supported in the browser because it cannot write to the file system. Use `analyzeProject` and a `Renderer` instead.');
      }

      const finalOptions = { ...options, logLevel: options.logLevel ?? 'info' };

      const {
        root = process.cwd(),
        output = './repograph.md',
      } = finalOptions;

      try {
        // We get the full ranked graph first
        const rankedGraph = await analyzeProject(finalOptions);

        logger.info('4/4 Rendering output...');
        const renderer = createMarkdownRenderer();
        const markdown = renderer(rankedGraph, finalOptions.rendererOptions);
        logger.debug('  -> Rendering complete.');

        const outputPath = path.isAbsolute(output) ? output : path.resolve(root, output);

        logger.info(`Writing report to ${path.relative(process.cwd(), outputPath)}...`);
        await writeFile(outputPath, markdown);
        logger.info('  -> Report saved.');
      } catch (error) {
        // The underlying `analyzeProject` already wraps the error, so we just re-throw.
        throw error;
      }
    };
  src/index.ts: |
    #!/usr/bin/env bun

    import { logger } from './utils/logger.util';
    import { RepoGraphError } from './utils/error.util';
    // High-Level API for simple use cases
    import { generateMap as executeGenerateMap } from './high-level';
    import { type RepoGraphOptions as IRepoGraphOptions } from './types';

    export { analyzeProject, generateMap } from './high-level';
    export { initializeParser } from './tree-sitter/languages';

    // Low-Level API for composition and advanced use cases
    export { createMapGenerator } from './composer';

    // Default pipeline component factories
    export { createDefaultDiscoverer } from './pipeline/discover';
    export { createTreeSitterAnalyzer } from './pipeline/analyze';
    export { createPageRanker, createGitRanker } from './pipeline/rank';
    export { createMarkdownRenderer } from './pipeline/render';

    // Logger utilities
    export { logger } from './utils/logger.util';
    export type { LogLevel, Logger } from './utils/logger.util';
    export type { ParserInitializationOptions } from './tree-sitter/languages';

    // Core types for building custom components
    export type {
      Analyzer,
      FileContent,
      CodeNode,
      CodeNodeType,
      CodeNodeVisibility,
      CodeEdge,
      CodeGraph,
      RankedCodeGraph,
      RepoGraphMap,
      RepoGraphOptions,
      CssIntent,
      Ranker,
      Renderer,
      RendererOptions,
      FileDiscoverer,
    } from './types';

    // This section runs only when the script is executed directly from the CLI
    import { fileURLToPath } from 'node:url';
    import path from 'node:path';

    const isRunningDirectly = () => {
      if (typeof process.argv[1] === 'undefined') return false;
      const runningFile = path.resolve(process.argv[1]);
      const currentFile = fileURLToPath(import.meta.url);
      return runningFile === currentFile;
    };

    const copyWasmFiles = async (destination: string) => {
      const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
      if (isBrowser) {
        logger.error('File system operations are not available in the browser.');
        return;
      }

      try {
        const { promises: fs } = await import('node:fs');
        const path = await import('node:path');

        // Source is relative to the running script (dist/index.js)
        const sourceDir = path.resolve(fileURLToPath(import.meta.url), '..', 'wasm');

        await fs.mkdir(destination, { recursive: true });

        const wasmFiles = (await fs.readdir(sourceDir)).filter(file => file.endsWith('.wasm'));
        for (const file of wasmFiles) {
          const srcPath = path.join(sourceDir, file);
          const destPath = path.join(destination, file);
          await fs.copyFile(srcPath, destPath);
          logger.info(`Copied ${file} to ${path.relative(process.cwd(), destPath)}`);
        }
        logger.info(`\n✅ All ${wasmFiles.length} WASM files copied successfully.`);
      } catch (err) {
        logger.error('Error copying WASM files.', err);
      }
    };

    if (isRunningDirectly()) {
      (async () => {
        const args = process.argv.slice(2);

        if (args.includes('--help') || args.includes('-h')) {
          console.log(`
    Usage: repograph [root] [options]
           repograph copy-wasm [destination]

    Commands:
      [root]                   Analyze a repository at the given root path. This is the default command.
      copy-wasm [destination]  Copy the necessary Tree-sitter WASM files to a specified directory
                               for browser-based usage.
                               (default destination: "./public/wasm")

    Arguments:
      root                     The root directory of the repository to analyze. Defaults to the current working directory.

    Options:
      -h, --help               Display this help message.
      -v, --version            Display the version number.
      --output <path>          Path to the output Markdown file. (default: "repograph.md")
      --include <pattern>      Glob pattern for files to include. Can be specified multiple times.
      --ignore <pattern>       Glob pattern for files to ignore. Can be specified multiple times.
      --no-gitignore           Do not respect .gitignore files.
      --ranking-strategy <name> The ranking strategy to use. (default: "pagerank", options: "pagerank", "git-changes")
      --max-workers <num>      Set the maximum number of parallel workers for analysis. (default: 1)
      --log-level <level>      Set the logging level. (default: "info", options: "silent", "error", "warn", "info", "debug")

    Output Formatting:
      --no-header              Do not include the main "RepoGraph" header.
      --no-overview            Do not include the project overview section.
      --no-mermaid             Do not include the Mermaid dependency graph.
      --no-file-list           Do not include the list of top-ranked files.
      --no-symbol-details      Do not include the detailed file and symbol breakdown.
      --top-file-count <num>   Set the number of files in the top list. (default: 10)
      --file-section-separator <str> Custom separator for file sections. (default: "---")
      --no-symbol-relations    Hide symbol relationship details (e.g., calls, implements).
      --no-symbol-line-numbers Hide line numbers for symbols.
      --no-symbol-snippets     Hide code snippets for symbols.
      --max-relations-to-show <num> Max number of 'calls' relations to show per symbol. (default: 3)
        `);
          process.exit(0);
        }

        if (args[0] === 'copy-wasm') {
          const destDir = args[1] || './public/wasm';
          logger.info(`Copying WASM files to "${path.resolve(destDir)}"...`);
          await copyWasmFiles(destDir);
          process.exit(0);
        }

        if (args.includes('--version') || args.includes('-v')) {
          const { readFileSync } = await import('node:fs');
          const pkgPath = new URL('../package.json', import.meta.url);
          const pkg = JSON.parse(readFileSync(pkgPath, 'utf-8'));
          console.log(pkg.version);
          process.exit(0);
        }

        // We need a mutable version of the options to build it from arguments.
        const options: {
          root?: string;
          output?: string;
          include?: readonly string[];
          ignore?: readonly string[];
          noGitignore?: boolean;
          maxWorkers?: number;
          rankingStrategy?: 'pagerank' | 'git-changes';
          logLevel?: IRepoGraphOptions['logLevel'];
          rendererOptions?: IRepoGraphOptions['rendererOptions'];
        } = {};
        const includePatterns: string[] = [];
        const ignorePatterns: string[] = [];
        // We need a mutable version of rendererOptions to build from CLI args
        const rendererOptions: {
          customHeader?: string;
          includeHeader?: boolean;
          includeOverview?: boolean;
          includeMermaidGraph?: boolean;
          includeFileList?: boolean;
          topFileCount?: number;
          includeSymbolDetails?: boolean;
          fileSectionSeparator?: string;
          symbolDetailOptions?: {
            includeRelations?: boolean;
            includeLineNumber?: boolean;
            includeCodeSnippet?: boolean;
            maxRelationsToShow?: number;
          };
        } = {};

        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (!arg) {
            continue;
          }
          switch (arg) {
            case '--output':
              options.output = args[++i];
              break;
            case '--include':
              includePatterns.push(args[++i] as string);
              break;
            case '--ignore':
              ignorePatterns.push(args[++i] as string);
              break;
            case '--no-gitignore':
              options.noGitignore = true;
              break;
            case '--ranking-strategy':
              options.rankingStrategy = args[++i] as IRepoGraphOptions['rankingStrategy'];
              break;
            case '--max-workers':
              options.maxWorkers = parseInt(args[++i] as string, 10);
              break;
            case '--log-level':
              options.logLevel = args[++i] as IRepoGraphOptions['logLevel'];
              break;
            // --- Renderer Options ---
            case '--no-header':
              rendererOptions.includeHeader = false;
              break;
            case '--no-overview':
              rendererOptions.includeOverview = false;
              break;
            case '--no-mermaid':
              rendererOptions.includeMermaidGraph = false;
              break;
            case '--no-file-list':
              rendererOptions.includeFileList = false;
              break;
            case '--no-symbol-details':
              rendererOptions.includeSymbolDetails = false;
              break;
            case '--top-file-count':
              rendererOptions.topFileCount = parseInt(args[++i] as string, 10);
              break;
            case '--file-section-separator':
              rendererOptions.fileSectionSeparator = args[++i];
              break;
            case '--no-symbol-relations':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeRelations: false };
              break;
            case '--no-symbol-line-numbers':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeLineNumber: false };
              break;
            case '--no-symbol-snippets':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), includeCodeSnippet: false };
              break;
            case '--max-relations-to-show':
              rendererOptions.symbolDetailOptions = { ...(rendererOptions.symbolDetailOptions || {}), maxRelationsToShow: parseInt(args[++i] as string, 10) };
              break;
            default:
              if (!arg.startsWith('-')) {
                options.root = arg;
              }
              break;
          }
        }

        if (includePatterns.length > 0) {
          options.include = includePatterns;
        }
        if (ignorePatterns.length > 0) {
          options.ignore = ignorePatterns;
        }
        if (Object.keys(rendererOptions).length > 0) {
          options.rendererOptions = rendererOptions;
        }

        const finalOutput = path.resolve(options.root || process.cwd(), options.output || 'repograph.md');

        logger.info(`Starting RepoGraph analysis for "${path.resolve(options.root || process.cwd())}"...`);

        try {
          await executeGenerateMap(options);
          const relativePath = path.relative(process.cwd(), finalOutput);
          logger.info(`\n✅ Success! RepoGraph map saved to ${relativePath}`);
        } catch (error: unknown) {
          if (error instanceof RepoGraphError) {
            logger.error(`\n❌ Error generating RepoGraph map: ${error.message}`);
          } else {
            logger.error('\n❌ An unknown error occurred while generating the RepoGraph map.', error);
          }
          process.exit(1);
        }
      })().catch((error) => {
        console.error('Fatal error:', error);
        process.exit(1);
      });
    }
  tsup.config.ts: |-
    import { defineConfig } from 'tsup';
    import { copyFileSync, mkdirSync, existsSync } from 'fs';
    import { join } from 'path';

    export default defineConfig({
      entry: ['src/index.ts', 'src/browser.ts', 'src/pipeline/analyzer.worker.ts'],
      format: ['esm', 'cjs'],
      target: 'es2022',
      dts: true,
      sourcemap: true,
      clean: true,
      splitting: false, // Disable splitting for CJS compatibility
      treeshake: true,
      minify: false,
      outDir: 'dist',
      onSuccess: async () => {
        // Copy WASM files to dist folder
        const wasmDir = join('dist', 'wasm');
        if (!existsSync(wasmDir)) {
          mkdirSync(wasmDir, { recursive: true });
        }

        const wasmFiles = [
          'tree-sitter-typescript/tree-sitter-typescript.wasm',
          'tree-sitter-typescript/tree-sitter-tsx.wasm',
          'tree-sitter-javascript/tree-sitter-javascript.wasm',
          'tree-sitter-python/tree-sitter-python.wasm',
          'tree-sitter-java/tree-sitter-java.wasm',
          'tree-sitter-c/tree-sitter-c.wasm',
          'tree-sitter-cpp/tree-sitter-cpp.wasm',
          'tree-sitter-c-sharp/tree-sitter-c-sharp.wasm',
          'tree-sitter-css/tree-sitter-css.wasm',
          'tree-sitter-go/tree-sitter-go.wasm',
          'tree-sitter-php/tree-sitter-php.wasm',
          'tree-sitter-ruby/tree-sitter-ruby.wasm',
          'tree-sitter-rust/tree-sitter-rust.wasm',
          'tree-sitter-solidity/tree-sitter-solidity.wasm',
          'tree-sitter-swift/tree-sitter-swift.wasm',
          'tree-sitter-vue/tree-sitter-vue.wasm',
        ];

        for (const wasmFile of wasmFiles) {
          const srcPath = join('node_modules', wasmFile);
          const wasmFileName = wasmFile.split('/')[1];
          if (!wasmFileName) {
            console.warn(`Skipping invalid wasmFile path: ${wasmFile}`);
            continue;
          }
          const destPath = join('dist', 'wasm', wasmFileName);
          
          if (existsSync(srcPath)) {
            copyFileSync(srcPath, destPath);
            console.log(`Copied ${wasmFileName} to dist/wasm/`);
          }
        }
      },
    });
approved: true
